<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nyan Escape</title>
    <style>
        :root {
            color-scheme: dark;
            --primary-font-stack: "Flight Time", "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        }

        @font-face {
            font-family: "Flight Time";
            src: url("assets/FlightTime.ttf") format("truetype");
            font-display: swap;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: var(--primary-font-stack);
            color: #fff;
            overflow: hidden;
            position: relative;
        }

        #loadingScreen {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 28px;
            background:
                linear-gradient(rgba(15, 23, 42, 0.82), rgba(15, 23, 42, 0.82)),
                url('assets/background.png') center / cover no-repeat;
            z-index: 999;
            transition: opacity 400ms ease;
        }

        #loadingScreen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        #loadingImage {
            width: min(420px, 80vw);
            max-width: 520px;
        }

        #loadingStatus {
            text-align: center;
            font-family: "Consolas", "Lucida Console", "Courier New", monospace;
            letter-spacing: 0.2em;
            color: #0f172a;
            text-transform: uppercase;
            line-height: 1.6;
        }

        #loadingStatus .loading-prefix {
            display: block;
            font-size: 0.72rem;
            letter-spacing: 0.35em;
            color: #475569;
            margin-bottom: 8px;
        }

        #loadingStatus .loading-line {
            display: block;
            font-size: 1.05rem;
            font-weight: 600;
            color: #111827;
        }

        #loadingStatus .loading-percent {
            color: #0284c7;
        }

        #backgroundContainer {
            position: fixed;
            inset: 0;
            z-index: -2;
            overflow: hidden;
            background: radial-gradient(circle at top, #1a237e 0%, #0d0221 40%, #000 100%);
        }

        .backgroundLayer {
            position: absolute;
            inset: 0;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            opacity: 0;
            transition: opacity 4s ease-in-out;
            will-change: opacity;
        }

        .backgroundLayer.visible {
            opacity: 1;
        }

        canvas {
            position: relative;
            z-index: 0;
            border: 1px solid rgba(255, 255, 255, 0.4);
            background: linear-gradient(180deg, rgba(5, 18, 55, 0.95) 0%, rgba(8, 27, 70, 0.95) 45%, rgba(0, 4, 20, 0.98) 100%);
            border-radius: 10px;
            box-shadow: 0 20px 45px rgba(0, 0, 0, 0.55);
        }

        #stats {
            position: relative;
            font-size: 15px;
            line-height: 1.4;
            text-align: left;
            text-shadow: 0 0 6px rgba(0, 0, 0, 0.35);
            padding: 18px 20px 16px;
            border-radius: 18px;
            background: linear-gradient(165deg, rgba(15, 23, 42, 0.88), rgba(8, 16, 32, 0.82));
            box-shadow:
                0 18px 38px rgba(2, 6, 23, 0.45),
                inset 0 0 0 1px rgba(94, 234, 212, 0.08);
            border: 1px solid rgba(148, 163, 184, 0.22);
            backdrop-filter: blur(12px);
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 14px;
        }

        #stats .stat-row {
            width: 100%;
        }

        #stats .value {
            font-variant-numeric: tabular-nums;
            font-feature-settings: 'tnum' 1;
        }

        #stats .stat-list {
            display: grid;
            gap: 10px;
            margin: 0;
            padding: 0;
            list-style: none;
        }

        #stats .stat-row {
            display: flex;
            align-items: baseline;
            justify-content: space-between;
            gap: 16px;
            color: rgba(226, 232, 240, 0.9);
        }

        #stats .stat-label {
            font-size: 0.68rem;
            text-transform: uppercase;
            letter-spacing: 0.16em;
            color: rgba(148, 163, 184, 0.85);
        }

        #survivalTimer {
            position: absolute;
            top: 12px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 16px;
            font-weight: 600;
            letter-spacing: 0.04em;
            padding: 6px 16px;
            border-radius: 999px;
            background: rgba(15, 23, 42, 0.7);
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.35);
            text-shadow: 0 0 6px rgba(0, 0, 0, 0.35);
            z-index: 2;
        }

        #survivalTimer .value {
            color: #7dd3fc;
        }

        #stats span.value {
            font-weight: 700;
            color: #ffd54f;
        }

        #stats #comboMeter {
            width: 100%;
            margin: 4px 0 0;
        }

        #instructions {
            position: absolute;
            top: 12px;
            left: 16px;
            display: flex;
            flex-direction: column;
            gap: 14px;
            width: min(260px, 28vw);
            font-size: 14px;
            text-align: left;
            opacity: 0.95;
            line-height: 1.6;
            z-index: 1;
        }

        #instructions .hud-card {
            background: linear-gradient(165deg, rgba(15, 23, 42, 0.85), rgba(8, 16, 32, 0.78));
            border-radius: 16px;
            padding: 16px 18px;
            box-shadow: 0 18px 38px rgba(2, 6, 23, 0.45), inset 0 0 0 1px rgba(94, 234, 212, 0.08);
            border: 1px solid rgba(148, 163, 184, 0.18);
            backdrop-filter: blur(12px);
        }

        #instructions .hud-card.collapsible {
            padding: 0;
            overflow: hidden;
        }

        #instructions .card-title {
            font-size: 0.78rem;
            text-transform: uppercase;
            letter-spacing: 0.18em;
            color: rgba(148, 210, 255, 0.9);
            margin: 0 0 12px 0;
        }

        #instructions .hud-card.collapsible .card-title {
            margin: 0;
        }

        #instructions .hud-card.collapsible .card-toggle {
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            padding: 16px 20px;
            background: transparent;
            border: none;
            color: inherit;
            font: inherit;
            text-align: left;
            cursor: pointer;
            transition: background 160ms ease;
        }

        #instructions .hud-card.collapsible .card-toggle:focus-visible {
            outline: 2px solid rgba(148, 210, 255, 0.75);
            outline-offset: 4px;
        }

        #instructions .hud-card.collapsible .card-toggle:hover {
            background: rgba(15, 23, 42, 0.35);
        }

        #instructions .hud-card.collapsible .toggle-icon {
            width: 20px;
            height: 20px;
            border-radius: 6px;
            border: 1px solid rgba(148, 210, 255, 0.45);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
            color: rgba(148, 210, 255, 0.9);
            transition: transform 160ms ease;
        }

        #instructions .hud-card.collapsible.open .toggle-icon {
            transform: rotate(180deg);
        }

        #instructions .hud-card.collapsible .toggle-icon::before {
            content: '\25BC';
            display: block;
            line-height: 1;
        }

        #instructions .hud-card.collapsible .card-content {
            padding: 0 20px;
            max-height: 0;
            overflow: hidden;
            transition: max-height 220ms ease, padding 220ms ease;
        }

        #instructions .hud-card.collapsible.open .card-content {
            padding: 14px 20px 18px;
            max-height: var(--collapsible-max-height, clamp(220px, 32vh, 420px));
            overflow-y: auto;
        }

        #instructions .hud-card.collapsible .card-content::-webkit-scrollbar {
            width: 6px;
        }

        #instructions .hud-card.collapsible .card-content::-webkit-scrollbar-thumb {
            background: rgba(148, 210, 255, 0.35);
            border-radius: 999px;
        }

        #instructions .control-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin: 0;
            padding: 0;
        }

        #instructions .control-row {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        #instructions .control-keys {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            min-width: 96px;
        }

        #instructions .keycap {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 28px;
            height: 28px;
            padding: 0 8px;
            border-radius: 8px;
            border: 1px solid rgba(148, 163, 184, 0.35);
            background: linear-gradient(135deg, rgba(30, 41, 59, 0.95), rgba(15, 23, 42, 0.85));
            color: rgba(226, 232, 240, 0.95);
            font-size: 0.78rem;
            letter-spacing: 0.04em;
            box-shadow: inset 0 -2px 6px rgba(13, 148, 136, 0.25);
        }

        #instructions .keycap.wide {
            min-width: 58px;
        }

        #instructions .control-action {
            flex: 1;
            color: rgba(226, 232, 240, 0.86);
            font-size: 0.88rem;
        }

        #instructions .mission-list {
            list-style: none;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        #instructions .mission-list li {
            position: relative;
            padding-left: 18px;
            color: rgba(226, 232, 240, 0.82);
        }

        #instructions .mission-list li::before {
            content: '';
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: linear-gradient(135deg, #38bdf8, #6366f1);
            box-shadow: 0 0 10px rgba(99, 102, 241, 0.6);
        }

        #instructions .card-body {
            margin: 0;
            color: rgba(148, 199, 255, 0.86);
            font-size: 0.86rem;
        }

        #socialFeed {
            list-style: none;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        #socialFeed li {
            display: flex;
            flex-direction: column;
            gap: 4px;
            color: rgba(226, 232, 240, 0.9);
            padding-left: 12px;
            border-left: 2px solid rgba(96, 165, 250, 0.35);
        }

        #socialFeed li .timestamp {
            font-size: 0.7rem;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            color: rgba(148, 163, 184, 0.7);
        }

        #socialFeed li.empty {
            border: none;
            padding-left: 0;
            font-style: italic;
            color: rgba(148, 163, 184, 0.8);
        }

        #intelCard .card-body {
            transition: opacity 220ms ease;
        }

        #intelCard .card-body.updating {
            opacity: 0;
        }

        #touchControls {
            position: fixed;
            inset: 0;
            display: none;
            pointer-events: none;
            z-index: 1;
        }

        @media (pointer: coarse) {
            #touchControls {
                display: block;
            }
        }

        #joystickZone {
            position: absolute;
            width: clamp(132px, 26vw, 188px);
            height: clamp(132px, 26vw, 188px);
            left: max(16px, calc(50% - 450px - 108px));
            bottom: clamp(16px, 8vh, 72px);
            border-radius: 50%;
            background: rgba(15, 23, 42, 0.58);
            border: 2px solid rgba(148, 163, 184, 0.32);
            box-shadow: 0 12px 28px rgba(15, 23, 42, 0.45);
            backdrop-filter: blur(2px);
            pointer-events: auto;
            touch-action: none;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        #joystickZone .joystick-ring {
            position: absolute;
            inset: 14%;
            border-radius: 50%;
            border: 2px dashed rgba(148, 163, 184, 0.28);
        }

        #joystickZone .joystick-thumb {
            position: absolute;
            left: 50%;
            top: 50%;
            width: 38%;
            height: 38%;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, rgba(125, 211, 252, 0.9), rgba(2, 132, 199, 0.75));
            box-shadow: 0 6px 16px rgba(14, 116, 144, 0.65);
            transform: translate(calc(-50% + var(--thumb-x, 0px)), calc(-50% + var(--thumb-y, 0px)));
            transition: transform 80ms ease-out;
        }

        #fireButton {
            position: absolute;
            right: max(16px, calc(50% - 450px - 96px));
            bottom: clamp(20px, 8vh, 84px);
            width: clamp(108px, 24vw, 160px);
            height: clamp(108px, 24vw, 160px);
            border-radius: 40px;
            border: none;
            pointer-events: auto;
            font-size: clamp(1rem, 4vw, 1.2rem);
            font-weight: 700;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: #fff;
            background: radial-gradient(circle at 30% 30%, rgba(255, 107, 214, 0.92), rgba(255, 64, 129, 0.88));
            box-shadow: 0 18px 38px rgba(255, 64, 129, 0.45);
            transition: transform 120ms ease, box-shadow 120ms ease;
            touch-action: manipulation;
        }

        #fireButton:active,
        #fireButton.active {
            transform: translateY(2px) scale(0.98);
            box-shadow: 0 12px 28px rgba(255, 64, 129, 0.35);
        }

        #overlay {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(6px);
            background: rgba(9, 11, 31, 0.6);
            text-align: center;
            padding: 24px;
            gap: 18px;
            transition: opacity 200ms ease;
            z-index: 2;
        }

        #overlay.hidden {
            pointer-events: none;
            opacity: 0;
        }

        #overlay h1 {
            font-size: 2.2rem;
            margin: 0;
            letter-spacing: 4px;
            color: #ff8ad4;
            text-shadow: 0 0 12px rgba(255, 138, 212, 0.6);
        }

        #overlay h1:empty {
            display: none;
        }

        #overlay p {
            margin: 0;
            font-size: 1rem;
            max-width: 360px;
            color: rgba(255, 255, 255, 0.82);
            white-space: pre-line;
        }

        #overlay button {
            background: linear-gradient(90deg, #ff6bd6, #ff4081);
            border: none;
            border-radius: 999px;
            padding: 12px 32px;
            color: #fff;
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            box-shadow: 0 12px 30px rgba(255, 105, 180, 0.45);
            transition: transform 150ms ease, box-shadow 150ms ease;
        }

        #overlay button:hover {
            transform: translateY(-2px);
            box-shadow: 0 15px 36px rgba(255, 105, 180, 0.6);
        }

        #overlay button:active {
            transform: translateY(0);
        }

        #overlay button[disabled] {
            cursor: not-allowed;
            opacity: 0.6;
            box-shadow: none;
        }

        #overlay.unsupported #highScorePanel {
            display: none;
        }

        #comboMeter {
            width: 160px;
            height: 8px;
            border-radius: 999px;
            overflow: hidden;
            background: rgba(255, 255, 255, 0.12);
            margin-top: 8px;
        }

        #comboFill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #6a5acd, #00e5ff);
            transition: width 100ms ease-out;
        }

        #comboMeter.charged {
            background: rgba(16, 185, 129, 0.32);
            box-shadow: 0 0 14px rgba(16, 185, 129, 0.45);
        }

        #comboMeter.charged #comboFill {
            filter: drop-shadow(0 0 6px rgba(16, 185, 129, 0.75));
        }

        #overlayPanels {
            display: flex;
            flex-wrap: wrap;
            gap: 18px;
            justify-content: center;
            width: 100%;
            max-width: 720px;
        }

        #highScorePanel,
        #leaderboardPanel,
        #sharePanel {
            margin-top: 8px;
            padding: 12px 18px;
            border-radius: 12px;
            background: rgba(12, 15, 35, 0.6);
            box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.18);
            text-align: left;
            max-width: 320px;
        }

        #highScoreTitle {
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.18em;
            margin-bottom: 8px;
            color: rgba(148, 163, 184, 0.95);
        }

        #leaderboardPanel .panel-title,
        #sharePanel .panel-title {
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.18em;
            margin-bottom: 8px;
            color: rgba(148, 163, 184, 0.95);
        }

        #highScoreList {
            list-style: decimal inside;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            gap: 6px;
            font-size: 0.9rem;
        }

        #highScoreList li {
            color: rgba(226, 232, 240, 0.92);
        }

        #highScoreList li.empty {
            list-style: none;
            color: rgba(148, 163, 184, 0.85);
            font-style: italic;
        }

        #highScoreList li .time {
            font-weight: 600;
            color: #7dd3fc;
        }

        #highScoreList li .score {
            color: #facc15;
        }

        #leaderboardList {
            list-style: decimal inside;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            gap: 6px;
            font-size: 0.9rem;
        }

        #leaderboardList li {
            color: rgba(226, 232, 240, 0.92);
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        #leaderboardList li .meta {
            font-size: 0.72rem;
            letter-spacing: 0.08em;
            color: rgba(148, 163, 184, 0.78);
        }

        #leaderboardList li.empty {
            list-style: none;
            color: rgba(148, 163, 184, 0.85);
            font-style: italic;
        }

        #sharePanel {
            max-width: 420px;
        }

        #sharePanel .share-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 10px;
        }

        #sharePanel button.share-button {
            background: linear-gradient(135deg, #38bdf8, #6366f1);
            padding: 10px 18px;
            font-size: 0.9rem;
            border-radius: 12px;
            border: none;
            color: #fff;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 10px 26px rgba(14, 165, 233, 0.35);
            transition: transform 140ms ease, box-shadow 140ms ease;
        }

        #sharePanel button.share-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 14px 32px rgba(14, 165, 233, 0.45);
        }

        #sharePanel button.share-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            box-shadow: none;
        }

        #shareStatus {
            margin: 0;
            font-size: 0.82rem;
            color: rgba(148, 210, 255, 0.85);
            min-height: 1.4em;
        }

        #shareStatus.success {
            color: rgba(129, 230, 217, 0.9);
        }

        #shareStatus.error {
            color: rgba(248, 113, 113, 0.9);
        }
    </style>
</head>
<body>
    <div id="loadingScreen">
        <img src="assets/logo.png" alt="Cyborg boot sequence" id="loadingImage">
        <div id="loadingStatus">
            <span class="loading-prefix">[SYS-BOOT:00]</span>
            <span class="loading-line">Initializing quantum cores — <span class="loading-percent">000%</span></span>
        </div>
    </div>
    <div id="backgroundContainer">
        <div class="backgroundLayer visible" id="backgroundLayerA"></div>
        <div class="backgroundLayer" id="backgroundLayerB"></div>
    </div>
    <canvas id="gameCanvas" width="900" height="600" tabindex="0" aria-label="Nyan Escape flight deck"></canvas>
    <div id="survivalTimer">Flight Time: <span class="value" id="timerValue">00:00.0</span></div>
    <aside id="instructions" aria-label="Flight telemetry, controls, and mission information">
        <section id="stats" role="complementary" aria-live="polite">
            <h2 class="card-title">Flight Telemetry</h2>
            <div class="stat-list" role="presentation">
                <div class="stat-row">
                    <span class="stat-label">Score</span>
                    <span class="value" id="score">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Points</span>
                    <span class="value" id="nyan">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Streak</span>
                    <span class="value" id="streak">x1</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Best Tail</span>
                    <span class="value" id="bestStreak">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">MCAP</span>
                    <span class="value" id="mcap">6.6K</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">VOL</span>
                    <span class="value" id="vol">2.8K</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Boosts</span>
                    <span class="value" id="powerUps">None</span>
                </div>
            </div>
            <div id="comboMeter" role="progressbar" aria-label="Combo charge" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
                <div id="comboFill"></div>
            </div>
        </section>
        <div class="hud-card collapsible open" id="controlsCard">
            <button class="card-toggle" type="button" id="controlsToggle" aria-expanded="true" aria-controls="controlsContent">
                <span class="card-title">Flight Controls</span>
                <span class="toggle-icon" aria-hidden="true"></span>
            </button>
            <div class="card-content" id="controlsContent" role="region" aria-labelledby="controlsToggle">
                <div class="control-list" role="list">
                    <div class="control-row" role="listitem">
                        <div class="control-keys" aria-label="Movement keys">
                            <span class="keycap" aria-hidden="true">←</span>
                            <span class="keycap" aria-hidden="true">↑</span>
                            <span class="keycap" aria-hidden="true">↓</span>
                            <span class="keycap" aria-hidden="true">→</span>
                        </div>
                        <div class="control-action">Vector the catship through hazards.</div>
                    </div>
                    <div class="control-row" role="listitem">
                        <div class="control-keys" aria-label="Fire control">
                            <span class="keycap wide" aria-hidden="true">Space</span>
                        </div>
                        <div class="control-action">Launch precision plasma bolts.</div>
                    </div>
                    <div class="control-row" role="listitem">
                        <div class="control-keys" aria-label="Touch controls">
                            <span class="keycap wide" aria-hidden="true">Touch</span>
                        </div>
                        <div class="control-action">Drag the left pad to steer, tap Fire to engage.</div>
                    </div>
                </div>
            </div>
        </div>
        <div class="hud-card collapsible open" id="missionCard">
            <button class="card-toggle" type="button" id="missionToggle" aria-expanded="true" aria-controls="missionContent">
                <span class="card-title">Mission Brief</span>
                <span class="toggle-icon" aria-hidden="true"></span>
            </button>
            <div class="card-content" id="missionContent" role="region" aria-labelledby="missionToggle">
                <ul class="mission-list">
                    <li>Collect Points to fuel the escape and grow your score.</li>
                    <li>Slip between asteroids and hostile fire to stay in the fight.</li>
                    <li>Secure booster cores for temporary firepower and agility.</li>
                    <li>Snag the Radiant Shield to ricochet villains and asteroids away.</li>
                    <li>Channel Hyper Beam cores to carve safe corridors when the lane is crowded.</li>
                    <li>Keep the combo meter charged to amplify every point.</li>
                </ul>
            </div>
        </div>
        <div class="hud-card collapsible open" id="intelCard">
            <button class="card-toggle" type="button" id="intelToggle" aria-expanded="true" aria-controls="intelContent">
                <span class="card-title">Tactical Intel</span>
                <span class="toggle-icon" aria-hidden="true"></span>
            </button>
            <div class="card-content" id="intelContent" role="region" aria-labelledby="intelToggle">
                <p class="card-body" id="intelMessage" aria-live="polite"></p>
            </div>
        </div>
        <div class="hud-card collapsible open" id="socialCard">
            <button class="card-toggle" type="button" id="socialToggle" aria-expanded="true" aria-controls="socialContent">
                <span class="card-title">Squadron Feed</span>
                <span class="toggle-icon" aria-hidden="true"></span>
            </button>
            <div class="card-content" id="socialContent" role="region" aria-labelledby="socialToggle">
                <ul id="socialFeed" role="list"></ul>
            </div>
        </div>
    </aside>
    <div id="touchControls" aria-hidden="true">
        <div id="joystickZone">
            <div class="joystick-ring"></div>
            <div class="joystick-thumb"></div>
        </div>
        <button id="fireButton" type="button" aria-label="Fire cosmic arrows">Fire</button>
    </div>
    <div id="overlay">
        <h1>NYAN ESCAPE</h1>
        <p id="overlayMessage">Thread the cosmic needle, gather Points, and charge Nova Pulses to vaporize space junk. Ready to glide?</p>
        <button id="overlayButton">Start Flight</button>
        <div id="overlayPanels">
            <div id="highScorePanel">
                <div id="highScoreTitle">Top Flight Times</div>
                <ol id="highScoreList"></ol>
            </div>
            <div id="leaderboardPanel">
                <div class="panel-title">Galaxy Standings</div>
                <ol id="leaderboardList"></ol>
            </div>
        </div>
        <div id="sharePanel">
            <div class="panel-title">Broadcast Run</div>
            <div class="share-buttons">
                <button id="shareButton" class="share-button" type="button">Share Flight Log</button>
                <button id="copyShareButton" class="share-button" type="button">Copy to Clipboard</button>
            </div>
            <p id="shareStatus" role="status" aria-live="polite"></p>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas?.getContext ? canvas.getContext('2d') : null;
            const supportsPointerEvents = typeof window !== 'undefined' && 'PointerEvent' in window;

            const audioManager = (() => {
                const isSupported = typeof window !== 'undefined' && typeof Audio === 'function';
                const clamp01 = (value) => Math.max(0, Math.min(1, value));
                const audioCapabilityProbe = isSupported ? document.createElement('audio') : null;

                const normalizeSources = (definition) => {
                    if (!definition) {
                        return [];
                    }

                    if (Array.isArray(definition)) {
                        return definition;
                    }

                    if (typeof definition === 'string') {
                        return [definition];
                    }

                    if (Array.isArray(definition.sources)) {
                        return definition.sources;
                    }

                    if (typeof definition.src === 'string') {
                        return [definition.src];
                    }

                    return [];
                };

                const resolveAudioSource = (definition) => {
                    const sources = normalizeSources(definition);

                    if (!sources.length) {
                        return '';
                    }

                    if (!audioCapabilityProbe) {
                        return sources[0];
                    }

                    const mimeForExtension = (ext) => {
                        switch (ext) {
                            case 'mp3':
                                return 'audio/mpeg';
                            case 'ogg':
                                return 'audio/ogg';
                            case 'wav':
                                return 'audio/wav';
                            case 'aac':
                                return 'audio/aac';
                            default:
                                return '';
                        }
                    };

                    for (const candidate of sources) {
                        const extension = candidate.split('?')[0].split('#')[0].split('.').pop()?.toLowerCase();
                        if (!extension) {
                            continue;
                        }

                        const mimeType = mimeForExtension(extension);
                        if (!mimeType) {
                            continue;
                        }

                        if (audioCapabilityProbe.canPlayType(mimeType) !== '') {
                            return candidate;
                        }
                    }

                    return sources[0];
                };

                const soundDefinitions = {
                    projectile: {
                        standard: { sources: ['assets/audio/projectile-standard.mp3', 'assets/audio/projectile-standard.wav'], voices: 6, volume: 0.55 },
                        spread: { sources: ['assets/audio/projectile-spread.mp3', 'assets/audio/projectile-spread.wav'], voices: 6, volume: 0.52 },
                        missile: { sources: ['assets/audio/projectile-missile.mp3', 'assets/audio/projectile-missile.wav'], voices: 4, volume: 0.6 }
                    },
                    collect: {
                        point: { sources: ['assets/audio/point.mp3', 'assets/audio/point.wav'], voices: 4, volume: 0.6 }
                    },
                    explosion: {
                        villain1: { sources: ['assets/audio/explosion-villain1.mp3', 'assets/audio/explosion-villain1.wav'], voices: 3, volume: 0.7 },
                        villain2: { sources: ['assets/audio/explosion-villain2.mp3', 'assets/audio/explosion-villain2.wav'], voices: 3, volume: 0.7 },
                        villain3: { sources: ['assets/audio/explosion-villain3.mp3', 'assets/audio/explosion-villain3.wav'], voices: 3, volume: 0.75 },
                        asteroid: { sources: ['assets/audio/explosion-asteroid.mp3', 'assets/audio/explosion-asteroid.wav'], voices: 3, volume: 0.68 },
                        powerbomb: { sources: ['assets/audio/explosion-powerbomb.mp3', 'assets/audio/explosion-powerbomb.wav'], voices: 2, volume: 0.76 },
                        generic: { sources: ['assets/audio/explosion-generic.mp3', 'assets/audio/explosion-generic.wav'], voices: 3, volume: 0.66 }
                    }
                };

                const state = {
                    masterVolume: 0.85,
                    muted: false,
                    unlocked: !isSupported
                };

                const pools = new Map();
                const musicDefinition = { sources: ['assets/audio/gameplay.mp3', 'assets/audio/gameplay.wav'], volume: 0.52 };
                const hyperBeamDefinition = { sources: ['assets/audio/hyperbeam.mp3', 'assets/audio/hyperbeam.wav'], volume: 0.62 };
                let gameplayMusic = null;
                let shouldResumeGameplayMusic = false;
                let hyperBeamAudio = null;
                let shouldResumeHyperBeam = false;
                let resumeGameplayAfterVisibility = false;
                let resumeHyperAfterVisibility = false;
                const fadeControllers = new WeakMap();
                const stopTimers = new WeakMap();

                const scheduleAnimationFrame = typeof window !== 'undefined' && typeof window.requestAnimationFrame === 'function'
                    ? window.requestAnimationFrame.bind(window)
                    : null;
                const cancelAnimationFrame = typeof window !== 'undefined' && typeof window.cancelAnimationFrame === 'function'
                    ? window.cancelAnimationFrame.bind(window)
                    : null;

                const clearStopTimer = (audio) => {
                    const timerId = stopTimers.get(audio);
                    if (timerId != null) {
                        window.clearTimeout(timerId);
                        stopTimers.delete(audio);
                    }
                };

                const stopExistingFade = (audio) => {
                    const cancel = fadeControllers.get(audio);
                    if (typeof cancel === 'function') {
                        cancel();
                        fadeControllers.delete(audio);
                    }
                };

                const fadeAudio = (audio, targetVolume, duration = 220) => {
                    if (!audio) {
                        return;
                    }

                    const resolvedTarget = clamp01(targetVolume ?? 0);
                    const currentVolume = clamp01(audio.volume ?? 0);

                    if (Math.abs(currentVolume - resolvedTarget) < 0.001 || duration <= 0) {
                        stopExistingFade(audio);
                        audio.volume = resolvedTarget;
                        return;
                    }

                    stopExistingFade(audio);

                    const startVolume = currentVolume;
                    const startTime = performance.now();
                    let rafId = null;
                    let timeoutId = null;
                    const useRaf = typeof scheduleAnimationFrame === 'function';

                    const cancel = () => {
                        if (useRaf && rafId != null) {
                            cancelAnimationFrame?.(rafId);
                        } else if (!useRaf && timeoutId != null) {
                            window.clearTimeout(timeoutId);
                        }
                    };

                    const step = (now) => {
                        const progress = clamp01((now - startTime) / duration);
                        const nextVolume = startVolume + (resolvedTarget - startVolume) * progress;
                        audio.volume = clamp01(nextVolume);

                        if (progress < 1) {
                            if (useRaf) {
                                rafId = scheduleAnimationFrame(step);
                            } else {
                                timeoutId = window.setTimeout(() => step(performance.now()), 16);
                            }
                        } else {
                            fadeControllers.delete(audio);
                        }
                    };

                    fadeControllers.set(audio, cancel);

                    if (useRaf) {
                        rafId = scheduleAnimationFrame(step);
                    } else {
                        timeoutId = window.setTimeout(() => step(performance.now()), 16);
                    }
                };

                const getLoopTargetVolume = (definition) => clamp01((definition.volume ?? 1) * state.masterVolume);

                const prepareLoopForPlayback = (audio, definition) => {
                    if (!audio) {
                        return;
                    }

                    clearStopTimer(audio);
                    stopExistingFade(audio);

                    const target = getLoopTargetVolume(definition);
                    if (audio.paused) {
                        audio.volume = 0;
                    } else {
                        audio.volume = Math.min(audio.volume ?? target, target);
                    }
                };

                const fadeOutLoop = (audio, duration, { reset = true } = {}) => {
                    if (!audio) {
                        return;
                    }

                    stopExistingFade(audio);
                    clearStopTimer(audio);

                    if (duration <= 0) {
                        audio.volume = 0;
                        if (!audio.paused) {
                            audio.pause();
                        }
                        if (reset) {
                            try {
                                audio.currentTime = 0;
                            } catch {
                                // Ignore reset failures
                            }
                        }
                        return;
                    }

                    fadeAudio(audio, 0, duration);
                    const stopDelay = duration + 32;
                    const timerId = window.setTimeout(() => {
                        stopTimers.delete(audio);
                        try {
                            audio.volume = 0;
                            if (!audio.paused) {
                                audio.pause();
                            }
                            if (reset) {
                                audio.currentTime = 0;
                            }
                        } catch {
                            // Ignore errors when pausing/resetting
                        }
                    }, stopDelay);
                    stopTimers.set(audio, timerId);
                };

                const attemptPlayLoop = (audio, definition) => {
                    if (!audio || !state.unlocked || state.muted) {
                        return false;
                    }

                    prepareLoopForPlayback(audio, definition);
                    const playPromise = audio.play();
                    if (playPromise?.catch) {
                        playPromise.catch(() => undefined);
                    }
                    fadeAudio(audio, getLoopTargetVolume(definition), 320);
                    return true;
                };

                if (isSupported) {
                    try {
                        const musicSrc = resolveAudioSource(musicDefinition);
                        if (musicSrc) {
                            gameplayMusic = new Audio(musicSrc);
                            gameplayMusic.preload = 'auto';
                            gameplayMusic.crossOrigin = 'anonymous';
                            gameplayMusic.loop = true;
                            gameplayMusic.volume = clamp01((musicDefinition.volume ?? 1) * state.masterVolume);
                            gameplayMusic.addEventListener('error', () => {
                                gameplayMusic = null;
                                shouldResumeGameplayMusic = false;
                            });
                        }
                    } catch {
                        gameplayMusic = null;
                    }

                    try {
                        const hyperBeamSrc = resolveAudioSource(hyperBeamDefinition);
                        if (hyperBeamSrc) {
                            hyperBeamAudio = new Audio(hyperBeamSrc);
                            hyperBeamAudio.preload = 'auto';
                            hyperBeamAudio.crossOrigin = 'anonymous';
                            hyperBeamAudio.loop = true;
                            hyperBeamAudio.volume = clamp01((hyperBeamDefinition.volume ?? 1) * state.masterVolume);
                            hyperBeamAudio.addEventListener('error', () => {
                                hyperBeamAudio = null;
                                shouldResumeHyperBeam = false;
                            });
                        }
                    } catch {
                        hyperBeamAudio = null;
                        shouldResumeHyperBeam = false;
                    }
                }

                function createSoundPool(definition) {
                    const { voices = 4 } = definition;
                    const src = resolveAudioSource(definition);
                    const elements = [];
                    let disabled = !src;

                    if (!disabled) {
                        for (let i = 0; i < voices; i++) {
                            try {
                                const audio = new Audio(src);
                                audio.preload = 'auto';
                                audio.crossOrigin = 'anonymous';
                                audio.volume = clamp01((definition.volume ?? 1) * state.masterVolume);
                                if (typeof audio.load === 'function') {
                                    audio.load();
                                }
                                audio.addEventListener('error', () => {
                                    disabled = true;
                                });
                                elements.push(audio);
                            } catch {
                                disabled = true;
                                break;
                            }
                        }
                    }

                    let index = 0;

                    return {
                        play() {
                            if (!isSupported || disabled || state.muted || !state.unlocked) {
                                return;
                            }

                            const audio = elements[index];
                            index = (index + 1) % elements.length;
                            if (!audio) return;

                            clearStopTimer(audio);
                            stopExistingFade(audio);
                            audio.volume = clamp01((definition.volume ?? 1) * state.masterVolume);
                            try {
                                audio.currentTime = 0;
                            } catch {
                                // Ignore if resetting currentTime fails
                            }

                            const playPromise = audio.play();
                            if (playPromise?.catch) {
                                playPromise.catch(() => undefined);
                            }
                        }
                    };
                }

                function getPool(category, key) {
                    const definition = soundDefinitions[category]?.[key];
                    if (!definition) {
                        return null;
                    }

                    const mapKey = `${category}:${key}`;
                    if (!pools.has(mapKey)) {
                        pools.set(mapKey, createSoundPool(definition));
                    }
                    return pools.get(mapKey);
                }

                function play(category, key, fallbackKey) {
                    if (!isSupported || state.muted) return;
                    const pool = getPool(category, key) ?? (fallbackKey ? getPool(category, fallbackKey) : null);
                    pool?.play();
                }

                function updateGameplayMusicVolume({ immediate = false } = {}) {
                    if (!gameplayMusic) return;
                    const target = getLoopTargetVolume(musicDefinition);
                    if (immediate) {
                        stopExistingFade(gameplayMusic);
                        clearStopTimer(gameplayMusic);
                        gameplayMusic.volume = target;
                    } else {
                        fadeAudio(gameplayMusic, target, 200);
                    }
                }

                function updateHyperBeamVolume({ immediate = false } = {}) {
                    if (!hyperBeamAudio) return;
                    const target = getLoopTargetVolume(hyperBeamDefinition);
                    if (immediate) {
                        stopExistingFade(hyperBeamAudio);
                        clearStopTimer(hyperBeamAudio);
                        hyperBeamAudio.volume = target;
                    } else {
                        fadeAudio(hyperBeamAudio, target, 200);
                    }
                }

                function attemptPlayGameplayMusic() {
                    if (!attemptPlayLoop(gameplayMusic, musicDefinition)) {
                        return;
                    }
                }

                function attemptPlayHyperBeam() {
                    if (!attemptPlayLoop(hyperBeamAudio, hyperBeamDefinition)) {
                        return;
                    }
                }

                function playGameplayMusic() {
                    if (!isSupported || !gameplayMusic) {
                        shouldResumeGameplayMusic = false;
                        return;
                    }
                    shouldResumeGameplayMusic = true;
                    clearStopTimer(gameplayMusic);
                    try {
                        gameplayMusic.currentTime = 0;
                    } catch {
                        // Ignore if resetting currentTime fails (e.g., not yet loaded)
                    }
                    attemptPlayGameplayMusic();
                }

                function stopGameplayMusic({ reset = true } = {}) {
                    shouldResumeGameplayMusic = false;
                    if (!gameplayMusic) {
                        return;
                    }
                    fadeOutLoop(gameplayMusic, 220, { reset });
                }

                function playHyperBeam() {
                    if (!isSupported || !hyperBeamAudio) {
                        shouldResumeHyperBeam = false;
                        return;
                    }
                    shouldResumeHyperBeam = true;
                    clearStopTimer(hyperBeamAudio);
                    try {
                        hyperBeamAudio.currentTime = 0;
                    } catch {
                        // Ignore if resetting currentTime fails (e.g., not yet loaded)
                    }
                    attemptPlayHyperBeam();
                }

                function stopHyperBeam({ reset = true } = {}) {
                    shouldResumeHyperBeam = false;
                    if (!hyperBeamAudio) {
                        return;
                    }
                    fadeOutLoop(hyperBeamAudio, 200, { reset });
                }

                function suspendForVisibilityChange() {
                    if (!isSupported) {
                        return;
                    }

                    resumeGameplayAfterVisibility = shouldResumeGameplayMusic && !!(gameplayMusic && !gameplayMusic.paused);
                    resumeHyperAfterVisibility = shouldResumeHyperBeam && !!(hyperBeamAudio && !hyperBeamAudio.paused);

                    if (resumeGameplayAfterVisibility) {
                        fadeOutLoop(gameplayMusic, 140, { reset: false });
                    }
                    if (resumeHyperAfterVisibility) {
                        fadeOutLoop(hyperBeamAudio, 140, { reset: false });
                    }
                }

                function resumeAfterVisibilityChange() {
                    if (!isSupported) {
                        return;
                    }

                    if (resumeGameplayAfterVisibility) {
                        attemptPlayGameplayMusic();
                        resumeGameplayAfterVisibility = false;
                    }
                    if (resumeHyperAfterVisibility) {
                        attemptPlayHyperBeam();
                        resumeHyperAfterVisibility = false;
                    }
                }

                function unlock() {
                    if (state.unlocked) return;
                    state.unlocked = true;
                    if (shouldResumeGameplayMusic) {
                        attemptPlayGameplayMusic();
                    }
                    if (shouldResumeHyperBeam) {
                        attemptPlayHyperBeam();
                    }
                }

                return {
                    playProjectile(type) {
                        play('projectile', type, 'standard');
                    },
                    playCollect(type = 'point') {
                        play('collect', type, 'point');
                    },
                    playExplosion(type) {
                        play('explosion', type, 'generic');
                    },
                    playGameplayMusic,
                    stopGameplayMusic,
                    playHyperBeam,
                    stopHyperBeam,
                    suspendForVisibilityChange,
                    resumeAfterVisibilityChange,
                    unlock
                };
            })();

            window.addEventListener('pointerdown', audioManager.unlock, { once: true });
            window.addEventListener('keydown', audioManager.unlock, { once: true });
            if (typeof window !== 'undefined' && 'ontouchstart' in window) {
                window.addEventListener('touchstart', audioManager.unlock, { once: true });
            }

            const handleAudioSuspend = () => {
                audioManager.suspendForVisibilityChange();
            };
            const handleAudioResume = () => {
                audioManager.resumeAfterVisibilityChange();
            };

            window.addEventListener('blur', handleAudioSuspend);
            window.addEventListener('focus', handleAudioResume);

            if (typeof document !== 'undefined' && typeof document.addEventListener === 'function') {
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) {
                        handleAudioSuspend();
                    } else {
                        handleAudioResume();
                    }
                });
            }

            const assetOverrides =
                typeof window !== 'undefined' && window.NYAN_ASSET_OVERRIDES && typeof window.NYAN_ASSET_OVERRIDES === 'object'
                    ? window.NYAN_ASSET_OVERRIDES
                    : {};

            function resolveAssetConfig(override, defaultSrc) {
                if (override == null) {
                    return defaultSrc;
                }

                if (typeof override === 'string') {
                    return override.trim() || defaultSrc;
                }

                if (typeof override === 'object') {
                    const config = { ...override };
                    if ((!config.src || typeof config.src !== 'string' || !config.src.trim()) && defaultSrc) {
                        config.src = defaultSrc;
                    }
                    if (typeof config.src === 'string') {
                        config.src = config.src.trim();
                        if (!config.src) {
                            delete config.src;
                        }
                    }
                    if (typeof config.fallback === 'string') {
                        config.fallback = config.fallback.trim();
                        if (!config.fallback) {
                            delete config.fallback;
                        }
                    }
                    return config;
                }

                return defaultSrc;
            }

            const defaultBackgrounds = ['assets/background1.png', 'assets/background2.png', 'assets/background3.png'];
            const backgroundOverrideEntries =
                Array.isArray(assetOverrides.backgrounds) && assetOverrides.backgrounds.length
                    ? assetOverrides.backgrounds
                    : defaultBackgrounds;
            let backgroundImages = backgroundOverrideEntries
                .map((entry, index) => resolveAssetConfig(entry, defaultBackgrounds[index % defaultBackgrounds.length]))
                .map((config) => (typeof config === 'string' ? config : config?.src))
                .filter((src) => typeof src === 'string' && src.length);
            if (backgroundImages.length === 0) {
                backgroundImages = [...defaultBackgrounds];
            }
            const backgroundLayers = [
                document.getElementById('backgroundLayerA'),
                document.getElementById('backgroundLayerB')
            ];
            const backgroundChangeInterval = 20000;
            let currentBackgroundIndex = 0;
            let activeLayerIndex = 0;

            const scoreEl = document.getElementById('score');
            const nyanEl = document.getElementById('nyan');
            const streakEl = document.getElementById('streak');
            const bestStreakEl = document.getElementById('bestStreak');
            const mcapEl = document.getElementById('mcap');
            const volEl = document.getElementById('vol');
            const powerUpsEl = document.getElementById('powerUps');
            const comboFillEl = document.getElementById('comboFill');
            const comboMeterEl = document.getElementById('comboMeter');
            const joystickZone = document.getElementById('joystickZone');
            const joystickThumb = joystickZone?.querySelector('.joystick-thumb') ?? null;
            const fireButton = document.getElementById('fireButton');

            const overlay = document.getElementById('overlay');
            const overlayMessage = document.getElementById('overlayMessage');
            const overlayButton = document.getElementById('overlayButton');
            const overlayTitle = overlay?.querySelector('h1') ?? null;
            const overlayDefaultTitle = overlayTitle?.textContent ?? '';
            const loadingScreen = document.getElementById('loadingScreen');
            const loadingStatus = document.getElementById('loadingStatus');
            const loadingImageEl = document.getElementById('loadingImage');
            const timerValueEl = document.getElementById('timerValue');
            const highScoreListEl = document.getElementById('highScoreList');
            const highScoreTitleEl = document.getElementById('highScoreTitle');
            const leaderboardListEl = document.getElementById('leaderboardList');
            const shareButton = document.getElementById('shareButton');
            const copyShareButton = document.getElementById('copyShareButton');
            const shareStatusEl = document.getElementById('shareStatus');
            const socialFeedEl = document.getElementById('socialFeed');
            const socialCard = document.getElementById('socialCard');
            const socialContent = document.getElementById('socialContent');
            const collapsibleCards = Array.from(document.querySelectorAll('#instructions .hud-card.collapsible'));
            const intelCard = document.getElementById('intelCard');
            const intelContent = document.getElementById('intelContent');
            const intelMessageEl = document.getElementById('intelMessage');

            const hudCache = {
                score: '',
                nyan: '',
                comboMultiplier: '',
                bestTailLength: '',
                marketCap: '',
                volume: '',
                powerUps: ''
            };
            let lastComboPercent = -1;
            let lastFormattedTimer = '';

            if (!(canvas instanceof HTMLCanvasElement) || !ctx) {
                console.error('Unable to initialize the Nyan Escape flight deck: canvas support is unavailable.');

                loadingScreen?.classList.add('hidden');
                if (overlay) {
                    overlay.classList.add('unsupported');
                }
                if (overlayTitle) {
                    overlayTitle.textContent = 'Flight Deck Unsupported';
                }
                if (overlayMessage) {
                    overlayMessage.textContent =
                        'Your current browser is missing HTML canvas support, so Nyan Escape cannot launch. ' +
                        'Try again with a modern browser to enter the cosmic corridor.';
                }
                if (overlayButton) {
                    overlayButton.textContent = 'Unavailable';
                    overlayButton.setAttribute('aria-disabled', 'true');
                    overlayButton.disabled = true;
                }
                if (intelMessageEl) {
                    intelMessageEl.textContent =
                        'Canvas rendering is disabled. Upgrade your browser to restore full mission control visuals.';
                }

                return;
            }

            if (loadingImageEl) {
                const defaultLogo = loadingImageEl.getAttribute('src') || 'assets/logo.png';
                const loadingLogoConfig = resolveAssetConfig(assetOverrides.loadingLogo, defaultLogo);
                if (typeof loadingLogoConfig === 'string') {
                    loadingImageEl.src = loadingLogoConfig;
                } else if (loadingLogoConfig && typeof loadingLogoConfig === 'object') {
                    if (loadingLogoConfig.crossOrigin === true) {
                        loadingImageEl.crossOrigin = 'anonymous';
                    } else if (typeof loadingLogoConfig.crossOrigin === 'string' && loadingLogoConfig.crossOrigin) {
                        loadingImageEl.crossOrigin = loadingLogoConfig.crossOrigin;
                    }
                    if (typeof loadingLogoConfig.src === 'string' && loadingLogoConfig.src) {
                        loadingImageEl.src = loadingLogoConfig.src;
                    }
                }
            }

            function createCanvasTexture(width, height, draw) {
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const context = canvas.getContext('2d');
                if (!context) {
                    return null;
                }
                draw(context, width, height);
                return canvas.toDataURL('image/png');
            }

            function loadImageWithFallback(config, fallbackFactory) {
                const image = new Image();
                image.decoding = 'async';

                let src = null;
                let fallbackSrc = null;

                if (typeof config === 'string') {
                    src = config;
                } else if (config && typeof config === 'object') {
                    if (config.crossOrigin === true) {
                        image.crossOrigin = 'anonymous';
                    } else if (typeof config.crossOrigin === 'string' && config.crossOrigin) {
                        image.crossOrigin = config.crossOrigin;
                    }

                    if (typeof config.src === 'string' && config.src) {
                        src = config.src;
                    }

                    if (typeof config.fallback === 'string' && config.fallback) {
                        fallbackSrc = config.fallback;
                    }
                }

                if (!fallbackSrc && typeof fallbackFactory === 'function') {
                    fallbackSrc = fallbackFactory() ?? null;
                }

                const assignFallback = () => {
                    if (fallbackSrc) {
                        image.src = fallbackSrc;
                    } else if (!src) {
                        image.removeAttribute('src');
                    }
                };

                if (fallbackSrc && src && src !== fallbackSrc) {
                    const handleError = () => {
                        image.removeEventListener('error', handleError);
                        assignFallback();
                    };
                    image.addEventListener('error', handleError, { once: true });
                }

                if (src) {
                    image.src = src;
                } else {
                    assignFallback();
                }

                return image;
            }

            function createCollectibleFallbackDataUrl(tier) {
                const size = 128;
                const font = '700 28px "Segoe UI", Tahoma, sans-serif';
                return (
                    createCanvasTexture(size, size, (context, width, height) => {
                        context.clearRect(0, 0, width, height);
                        const center = width / 2;
                        const radius = width * 0.42;
                        const glow = tier?.glow ?? {};
                        const innerGlow = glow.inner ?? 'rgba(255, 255, 255, 0.95)';
                        const outerGlow = glow.outer ?? 'rgba(255, 215, 0, 0.28)';
                        const gradient = context.createRadialGradient(
                            center,
                            center,
                            radius * 0.2,
                            center,
                            center,
                            radius
                        );
                        gradient.addColorStop(0, innerGlow);
                        gradient.addColorStop(1, outerGlow);
                        context.fillStyle = gradient;
                        context.beginPath();
                        context.arc(center, center, radius, 0, Math.PI * 2);
                        context.fill();
                        context.lineWidth = 4;
                        context.strokeStyle = 'rgba(255, 255, 255, 0.85)';
                        context.stroke();
                        const label = tier?.label ?? 'POINT';
                        context.font = font;
                        context.textAlign = 'center';
                        context.textBaseline = 'middle';
                        context.fillStyle = 'rgba(15, 23, 42, 0.82)';
                        context.fillText(label, center, center);
                    }) ?? tier?.src
                );
            }

            function createAsteroidFallbackDataUrl(seed = 0) {
                const size = 196;
                return createCanvasTexture(size, size, (context, width, height) => {
                    context.clearRect(0, 0, width, height);
                    context.save();
                    context.translate(width / 2, height / 2);
                    const radius = width * 0.42;
                    const sides = 9;
                    context.beginPath();
                    for (let i = 0; i < sides; i++) {
                        const angle = (i / sides) * Math.PI * 2;
                        const noise = 0.74 + (Math.sin(angle * (seed + 2.3)) + 1) * 0.12;
                        const r = radius * noise;
                        const x = Math.cos(angle) * r;
                        const y = Math.sin(angle) * r;
                        if (i === 0) {
                            context.moveTo(x, y);
                        } else {
                            context.lineTo(x, y);
                        }
                    }
                    context.closePath();
                    const gradient = context.createRadialGradient(0, -radius * 0.25, radius * 0.15, 0, 0, radius);
                    gradient.addColorStop(0, '#f8fafc');
                    gradient.addColorStop(0.6, '#a1a1aa');
                    gradient.addColorStop(1, '#4b5563');
                    context.fillStyle = gradient;
                    context.fill();
                    context.lineWidth = 6;
                    context.strokeStyle = 'rgba(15, 23, 42, 0.45)';
                    context.stroke();

                    const craterCount = 3 + (seed % 3);
                    for (let i = 0; i < craterCount; i++) {
                        const angle = (i / craterCount) * Math.PI * 2;
                        const distance = radius * 0.45;
                        const cx = Math.cos(angle + seed) * distance * 0.55;
                        const cy = Math.sin(angle * 1.2 + seed) * distance * 0.55;
                        const craterRadius = radius * (0.12 + (i / (craterCount + 2)) * 0.12);
                        const craterGradient = context.createRadialGradient(
                            cx,
                            cy,
                            craterRadius * 0.15,
                            cx,
                            cy,
                            craterRadius
                        );
                        craterGradient.addColorStop(0, 'rgba(226, 232, 240, 0.7)');
                        craterGradient.addColorStop(1, 'rgba(15, 23, 42, 0.7)');
                        context.fillStyle = craterGradient;
                        context.beginPath();
                        context.arc(cx, cy, craterRadius, 0, Math.PI * 2);
                        context.fill();
                    }
                    context.restore();
                });
            }

            function createPlayerFallbackDataUrl() {
                const width = 160;
                const height = 120;
                return createCanvasTexture(width, height, (context) => {
                    const gradient = context.createLinearGradient(0, 0, width, height);
                    gradient.addColorStop(0, '#38bdf8');
                    gradient.addColorStop(1, '#6366f1');
                    context.fillStyle = gradient;
                    context.fillRect(0, 0, width, height);

                    context.fillStyle = 'rgba(15, 23, 42, 0.65)';
                    context.beginPath();
                    context.moveTo(width * 0.22, height * 0.78);
                    context.lineTo(width * 0.5, height * 0.18);
                    context.lineTo(width * 0.78, height * 0.78);
                    context.closePath();
                    context.fill();

                    context.fillStyle = '#fdf4ff';
                    context.beginPath();
                    context.ellipse(width * 0.5, height * 0.58, width * 0.28, height * 0.2, 0, 0, Math.PI * 2);
                    context.fill();
                });
            }

            const villainFallbackPalette = ['#f472b6', '#34d399', '#fde68a'];
            function createVillainFallbackDataUrl(index = 0) {
                const size = 128;
                const baseColor = villainFallbackPalette[index % villainFallbackPalette.length];
                return createCanvasTexture(size, size, (context, width, height) => {
                    context.clearRect(0, 0, width, height);
                    context.save();
                    context.translate(width / 2, height / 2);
                    context.rotate((index % 4) * Math.PI * 0.12);
                    const gradient = context.createLinearGradient(-width / 2, -height / 2, width / 2, height / 2);
                    gradient.addColorStop(0, baseColor);
                    gradient.addColorStop(1, '#111827');
                    context.fillStyle = gradient;
                    context.beginPath();
                    context.moveTo(0, -height * 0.38);
                    context.lineTo(width * 0.32, 0);
                    context.lineTo(0, height * 0.38);
                    context.lineTo(-width * 0.32, 0);
                    context.closePath();
                    context.fill();
                    context.strokeStyle = 'rgba(15, 23, 42, 0.65)';
                    context.lineWidth = 6;
                    context.stroke();

                    context.fillStyle = 'rgba(15, 23, 42, 0.75)';
                    context.beginPath();
                    context.arc(0, 0, width * 0.14, 0, Math.PI * 2);
                    context.fill();
                    context.restore();
                });
            }

            const intelTips = [
                "Nova Pulses clear the field when charged—time them with debris clusters to stretch your lead.",
                "Hyper Beam slices through villain armor—align your strafing run to tunnel past blockades.",
                "Power cores boost both fire rate and agility—snag them when the sky is most crowded.",
                "Keep the combo meter glowing by chaining pickups and takedowns without breaking stride.",
                "Diagonal drifts slip past enemy fire—small corrections keep your streak intact.",
                "Pulse the plasma cannon in bursts to manage recoil while keeping threats in check.",
                "Sweep up stray Points before they fade to keep the leaderboard within reach."
            ];

            let intelTipIndex = -1;

            const setIntelTip = (index) => {
                if (!intelMessageEl || intelTips.length === 0) return;

                const normalizedIndex = ((index % intelTips.length) + intelTips.length) % intelTips.length;
                if (normalizedIndex === intelTipIndex && intelMessageEl.textContent?.trim()) {
                    return;
                }

                intelMessageEl.classList.add('updating');

                window.setTimeout(() => {
                    intelMessageEl.textContent = intelTips[normalizedIndex];
                    intelTipIndex = normalizedIndex;

                    if (intelCard?.classList.contains('open') && intelContent) {
                        updateCardMaxHeight(intelCard, intelContent);
                    }

                    window.requestAnimationFrame(() => {
                        intelMessageEl.classList.remove('updating');
                    });
                }, 160);
            };

            if (intelMessageEl && intelTips.length > 0) {
                setIntelTip(0);

                if (intelTips.length > 1) {
                    const intelRotationInterval = 26000;
                    window.setInterval(() => {
                        const nextIndex = intelTipIndex + 1;
                        setIntelTip(nextIndex);
                    }, intelRotationInterval);
                }
            }

            const updateCardMaxHeight = (card, content) => {
                const viewportLimit = Math.max(window.innerHeight * 0.45, 220);
                const naturalHeight = content.scrollHeight + 1;
                const capped = Math.min(naturalHeight, viewportLimit, 420);
                content.style.setProperty('--collapsible-max-height', `${Math.round(capped)}px`);
            };

            const updateAllCardHeights = () => {
                collapsibleCards.forEach(card => {
                    const content = card.querySelector('.card-content');
                    if (!content) return;
                    if (card.classList.contains('open')) {
                        updateCardMaxHeight(card, content);
                    }
                });
            };

            collapsibleCards.forEach(card => {
                const toggle = card.querySelector('.card-toggle');
                const contentId = toggle?.getAttribute('aria-controls') ?? '';
                const content = contentId ? document.getElementById(contentId) : card.querySelector('.card-content');
                if (!toggle || !content) return;

                const setState = (isOpen) => {
                    card.classList.toggle('open', isOpen);
                    if (isOpen) {
                        updateCardMaxHeight(card, content);
                    } else {
                        content.scrollTop = 0;
                        content.style.removeProperty('--collapsible-max-height');
                    }
                    toggle.setAttribute('aria-expanded', String(isOpen));
                };

                setState(card.classList.contains('open'));

                toggle.addEventListener('click', () => {
                    setState(!card.classList.contains('open'));
                });
            });

            window.addEventListener('resize', updateAllCardHeights);
            requestAnimationFrame(updateAllCardHeights);

            const fallbackFontStack = '"Segoe UI", Tahoma, Geneva, Verdana, sans-serif';
            const customFontFamily = 'Flight Time';
            const primaryFontStack = customFontFamily
                ? `"${customFontFamily}", ${fallbackFontStack}`
                : fallbackFontStack;
            const fontsReady = customFontFamily ? loadCustomFont(customFontFamily) : Promise.resolve();
            fontsReady.catch(() => undefined).then(updateAllCardHeights);

            const STORAGE_KEYS = {
                playerName: 'nyanEscape.playerName',
                highScores: 'nyanEscape.highScores',
                leaderboard: 'nyanEscape.leaderboard',
                socialFeed: 'nyanEscape.socialFeed'
            };

            let storageAvailable = false;
            try {
                const testKey = '__nyanEscapeTest__';
                localStorage.setItem(testKey, '1');
                localStorage.removeItem(testKey);
                storageAvailable = true;
            } catch (error) {
                storageAvailable = false;
            }

            function readStorage(key) {
                if (!storageAvailable) return null;
                try {
                    return localStorage.getItem(key);
                } catch (error) {
                    storageAvailable = false;
                    return null;
                }
            }

            function writeStorage(key, value) {
                if (!storageAvailable) return;
                try {
                    localStorage.setItem(key, value);
                } catch (error) {
                    storageAvailable = false;
                }
            }

            function loadHighScores() {
                const raw = readStorage(STORAGE_KEYS.highScores);
                if (!raw) return {};
                try {
                    const parsed = JSON.parse(raw);
                    return typeof parsed === 'object' && parsed !== null ? parsed : {};
                } catch (error) {
                    return {};
                }
            }

            function persistHighScores(data) {
                if (!storageAvailable) return;
                writeStorage(STORAGE_KEYS.highScores, JSON.stringify(data));
            }

            function loadLeaderboard() {
                const raw = readStorage(STORAGE_KEYS.leaderboard);
                if (!raw) return [];
                try {
                    const parsed = JSON.parse(raw);
                    return Array.isArray(parsed) ? parsed : [];
                } catch (error) {
                    return [];
                }
            }

            function persistLeaderboard(entries) {
                if (!storageAvailable) return;
                writeStorage(STORAGE_KEYS.leaderboard, JSON.stringify(entries));
            }

            function loadSocialFeed() {
                const raw = readStorage(STORAGE_KEYS.socialFeed);
                if (!raw) return [];
                try {
                    const parsed = JSON.parse(raw);
                    return Array.isArray(parsed) ? parsed : [];
                } catch (error) {
                    return [];
                }
            }

            function persistSocialFeed(entries) {
                if (!storageAvailable) return;
                writeStorage(STORAGE_KEYS.socialFeed, JSON.stringify(entries));
            }

            function requestPlayerName() {
                const defaultName = 'Ace Pilot';
                const storedName = readStorage(STORAGE_KEYS.playerName);
                if (storedName) {
                    return storedName;
                }
                const canPrompt = typeof prompt === 'function';
                const prompted = canPrompt ? prompt('Choose your pilot callsign to track high scores:', defaultName) : null;
                const name = (prompted ?? '').trim() || defaultName;
                writeStorage(STORAGE_KEYS.playerName, name);
                return name;
            }

            let highScoreData = loadHighScores();
            let playerName = requestPlayerName();
            let leaderboardEntries = loadLeaderboard();
            let socialFeedData = loadSocialFeed();
            const canNativeShare = typeof navigator !== 'undefined' && typeof navigator.share === 'function';
            let lastRunSummary = null;

            function formatTime(milliseconds) {
                const totalSeconds = Math.floor(milliseconds / 1000);
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                const tenths = Math.floor((milliseconds % 1000) / 100);
                return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}.${tenths}`;
            }

            function formatRelativeTime(timestamp) {
                if (!timestamp) return '';
                const now = Date.now();
                const diff = Math.max(0, now - timestamp);
                const seconds = Math.floor(diff / 1000);
                if (seconds < 60) return 'Just now';
                const minutes = Math.floor(seconds / 60);
                if (minutes < 60) return `${minutes}m ago`;
                const hours = Math.floor(minutes / 60);
                if (hours < 24) return `${hours}h ago`;
                const days = Math.floor(hours / 24);
                return `${days}d ago`;
            }

            function updateTimerDisplay() {
                if (!timerValueEl) return;
                const formatted = formatTime(state.elapsedTime);
                if (formatted !== lastFormattedTimer) {
                    lastFormattedTimer = formatted;
                    timerValueEl.textContent = formatted;
                }
            }

            function recordHighScore(durationMs, score, metadata = {}) {
                if (!playerName || durationMs <= 0) return null;
                const entry = {
                    timeMs: durationMs,
                    score,
                    recordedAt: metadata.recordedAt ?? Date.now(),
                    bestStreak: metadata.bestStreak ?? 0,
                    nyan: metadata.nyan ?? 0
                };
                const userScores = highScoreData[playerName] ? [...highScoreData[playerName]] : [];
                userScores.push(entry);
                userScores.sort((a, b) => {
                    if (b.timeMs !== a.timeMs) return b.timeMs - a.timeMs;
                    if (b.score !== a.score) return b.score - a.score;
                    return b.recordedAt - a.recordedAt;
                });
                highScoreData[playerName] = userScores.slice(0, 3);
                persistHighScores(highScoreData);
                const placement = recordLeaderboardEntry({
                    player: playerName,
                    timeMs: entry.timeMs,
                    score: entry.score,
                    bestStreak: entry.bestStreak,
                    nyan: entry.nyan,
                    recordedAt: entry.recordedAt
                });
                return placement;
            }

            function updateHighScorePanel() {
                if (!highScoreListEl || !highScoreTitleEl) return;
                highScoreTitleEl.textContent = `Top Flight Times — ${playerName}`;
                highScoreListEl.innerHTML = '';
                const entries = highScoreData[playerName] ?? [];
                if (!entries.length) {
                    const emptyItem = document.createElement('li');
                    emptyItem.className = 'empty';
                    emptyItem.textContent = 'No recorded runs yet. Survive to set a record!';
                    highScoreListEl.appendChild(emptyItem);
                    return;
                }
                for (const entry of entries) {
                    const item = document.createElement('li');
                    const timeSpan = document.createElement('span');
                    timeSpan.className = 'time';
                    timeSpan.textContent = formatTime(entry.timeMs);
                    const scoreSpan = document.createElement('span');
                    scoreSpan.className = 'score';
                    scoreSpan.textContent = ` — ${entry.score.toLocaleString()} pts`;
                    item.appendChild(timeSpan);
                    item.appendChild(scoreSpan);
                    highScoreListEl.appendChild(item);
                }
            }

            function recordLeaderboardEntry(entry) {
                if (!entry || !entry.player) return null;
                const normalized = {
                    player: entry.player,
                    timeMs: entry.timeMs ?? 0,
                    score: entry.score ?? 0,
                    bestStreak: entry.bestStreak ?? 0,
                    nyan: entry.nyan ?? 0,
                    recordedAt: entry.recordedAt ?? Date.now()
                };
                leaderboardEntries.push(normalized);
                leaderboardEntries.sort((a, b) => {
                    if (b.score !== a.score) return b.score - a.score;
                    if (b.timeMs !== a.timeMs) return b.timeMs - a.timeMs;
                    return a.recordedAt - b.recordedAt;
                });
                const limit = 7;
                const placementIndex = leaderboardEntries.indexOf(normalized);
                leaderboardEntries = leaderboardEntries.slice(0, limit);
                persistLeaderboard(leaderboardEntries);
                updateLeaderboardPanel();
                if (placementIndex >= 0 && placementIndex < limit) {
                    return placementIndex + 1;
                }
                return null;
            }

            function updateLeaderboardPanel() {
                if (!leaderboardListEl) return;
                leaderboardListEl.innerHTML = '';
                if (!leaderboardEntries.length) {
                    const empty = document.createElement('li');
                    empty.className = 'empty';
                    empty.textContent = 'No galaxy standings yet. Finish a run to seed the board!';
                    leaderboardListEl.appendChild(empty);
                    return;
                }

                leaderboardEntries.forEach((entry) => {
                    const item = document.createElement('li');
                    const main = document.createElement('span');
                    main.textContent = `${entry.player} — ${entry.score.toLocaleString()} pts`;
                    const meta = document.createElement('span');
                    meta.className = 'meta';
                    const streakText = entry.bestStreak ? ` • x${entry.bestStreak} streak` : '';
                    meta.textContent = `${formatTime(entry.timeMs)}${streakText}`;
                    item.appendChild(main);
                    item.appendChild(meta);
                    leaderboardListEl.appendChild(item);
                });
            }

            function updateSocialFeedPanel() {
                if (!socialFeedEl) return;
                socialFeedEl.innerHTML = '';
                if (!socialFeedData.length) {
                    const empty = document.createElement('li');
                    empty.className = 'empty';
                    empty.textContent = 'Complete missions to broadcast your squadron exploits.';
                    socialFeedEl.appendChild(empty);
                    return;
                }

                const visibleEntries = socialFeedData.slice(0, 8);
                for (const entry of visibleEntries) {
                    const item = document.createElement('li');
                    const textSpan = document.createElement('span');
                    textSpan.textContent = entry.message;
                    const timeSpan = document.createElement('span');
                    timeSpan.className = 'timestamp';
                    timeSpan.textContent = formatRelativeTime(entry.timestamp);
                    item.appendChild(textSpan);
                    item.appendChild(timeSpan);
                    socialFeedEl.appendChild(item);
                }
                if (socialCard?.classList.contains('open') && socialContent) {
                    updateCardMaxHeight(socialCard, socialContent);
                }
            }

            function addSocialMoment(message, { type = 'run', timestamp = Date.now() } = {}) {
                if (!message) return;
                socialFeedData.unshift({ message, type, timestamp });
                const limit = 12;
                socialFeedData = socialFeedData.slice(0, limit);
                persistSocialFeed(socialFeedData);
                updateSocialFeedPanel();
            }

            function getShareText(summary) {
                if (!summary) return '';
                const formattedTime = formatTime(summary.timeMs);
                const streakText = summary.bestStreak ? ` x${summary.bestStreak}` : '';
                const core = `${summary.player} survived ${formattedTime} for ${summary.score.toLocaleString()} pts${streakText} in Nyan Escape.`;
                const pickups = summary.nyan ? ` Pickups: ${summary.nyan.toLocaleString()} energy.` : '';
                const placementText = summary.placement ? ` Ranked #${summary.placement} on the local galaxy board.` : '';
                const locationUrl = typeof window !== 'undefined' && window.location ? ` Play: ${window.location.href}` : '';
                return `${core}${pickups}${placementText}${locationUrl}`.trim();
            }

            function showShareStatus(message, type = 'info') {
                if (!shareStatusEl) return;
                shareStatusEl.textContent = message;
                shareStatusEl.className = '';
                if (type === 'success') {
                    shareStatusEl.classList.add('success');
                } else if (type === 'error') {
                    shareStatusEl.classList.add('error');
                }
            }

            function updateSharePanel() {
                if (shareButton) {
                    if (!canNativeShare) {
                        shareButton.setAttribute('title', 'Web Share API not available in this browser.');
                    }
                    shareButton.disabled = !lastRunSummary || !canNativeShare;
                }
                if (copyShareButton) {
                    copyShareButton.disabled = !lastRunSummary;
                }
                if (!lastRunSummary) {
                    showShareStatus('Complete a run to generate a broadcast log.');
                } else if (!canNativeShare) {
                    showShareStatus('Copy the flight log and rally your crew!');
                } else {
                    showShareStatus('Flight log armed. Share your escape!');
                }
            }

            async function handleShareClick(event) {
                event?.preventDefault?.();
                if (!lastRunSummary || !canNativeShare || typeof navigator === 'undefined' || typeof navigator.share !== 'function') {
                    return;
                }
                try {
                    await navigator.share({
                        title: 'Nyan Escape — Flight Log',
                        text: getShareText(lastRunSummary)
                    });
                    showShareStatus('Flight log transmitted to the squadron!', 'success');
                } catch (error) {
                    if (error?.name !== 'AbortError') {
                        showShareStatus('Broadcast cancelled. Try again when ready.', 'error');
                    }
                }
            }

            async function handleCopyShareClick(event) {
                event?.preventDefault?.();
                if (!lastRunSummary) {
                    return;
                }
                const text = getShareText(lastRunSummary);
                const clipboard = typeof navigator !== 'undefined' ? navigator.clipboard : null;
                try {
                    if (clipboard?.writeText) {
                        await clipboard.writeText(text);
                    } else {
                        const textarea = document.createElement('textarea');
                        textarea.value = text;
                        textarea.setAttribute('readonly', '');
                        textarea.style.position = 'absolute';
                        textarea.style.left = '-9999px';
                        document.body.appendChild(textarea);
                        textarea.select();
                        document.execCommand('copy');
                        document.body.removeChild(textarea);
                    }
                    showShareStatus('Flight log copied. Rally the crew!', 'success');
                } catch (error) {
                    showShareStatus('Clipboard unavailable. Manually copy from the log.', 'error');
                }
            }

            updateHighScorePanel();
            updateLeaderboardPanel();
            updateSocialFeedPanel();
            updateSharePanel();

            if (shareButton) {
                shareButton.addEventListener('click', handleShareClick);
            }
            if (copyShareButton) {
                copyShareButton.addEventListener('click', handleCopyShareClick);
            }

            if (highScoreTitleEl && typeof highScoreTitleEl.addEventListener === 'function') {
                highScoreTitleEl.addEventListener('click', () => {
                    if (typeof prompt !== 'function') return;
                    const nextName = prompt('Update your pilot callsign:', playerName);
                    const trimmed = (nextName ?? '').trim();
                    if (!trimmed || trimmed === playerName) {
                        return;
                    }
                    playerName = trimmed;
                    writeStorage(STORAGE_KEYS.playerName, playerName);
                    if (!highScoreData[playerName]) {
                        highScoreData[playerName] = [];
                    }
                    persistHighScores(highScoreData);
                    updateHighScorePanel();
                    if (lastRunSummary) {
                        lastRunSummary.player = playerName;
                        updateSharePanel();
                    }
                });
            }

            function loadCustomFont(fontFamily) {
                if (!document.fonts?.load) {
                    return Promise.resolve();
                }

                const variantsToLoad = [
                    `400 16px "${fontFamily}"`,
                    `700 16px "${fontFamily}"`
                ];

                return Promise.all(variantsToLoad.map((descriptor) => document.fonts.load(descriptor)))
                    .then(() => undefined)
                    .catch(() => undefined);
            }

            function runCyborgLoadingSequence() {
                if (!loadingScreen || !loadingStatus) {
                    fontsReady.catch(() => undefined).then(() => {
                        startGame();
                    });
                    return;
                }

                const steps = [
                    'Booting cybernetics kernel',
                    'Calibrating optic relays',
                    'Decrypting nav matrices',
                    'Spooling plasma capacitors',
                    'Synchronizing nyan drives',
                    'Authorizing flight sequence'
                ].map((step) => step.toUpperCase());

                let progress = 0;
                let stepIndex = 0;
                const maxIndex = steps.length - 1;

                const updateStatus = () => {
                    const prefix = `[SYS-BOOT:${String(stepIndex + 1).padStart(2, '0')}]`;
                    const percentText = `${progress.toString().padStart(3, '0')}%`;
                    loadingStatus.innerHTML = `
                        <span class="loading-prefix">${prefix}</span>
                        <span class="loading-line">${steps[stepIndex]} — <span class="loading-percent">${percentText}</span></span>
                    `;
                };

                const advance = () => {
                    const increment = Math.floor(Math.random() * 11) + 4;
                    progress = Math.min(progress + increment, 100);
                    const ratio = progress / 100;
                    stepIndex = Math.min(maxIndex, Math.floor(ratio * steps.length));
                    updateStatus();

                    if (progress >= 100) {
                        setTimeout(() => {
                            fontsReady.catch(() => undefined).then(() => {
                                startGame();
                                loadingScreen.classList.add('hidden');
                                setTimeout(() => {
                                    if (loadingScreen.parentElement) {
                                        loadingScreen.parentElement.removeChild(loadingScreen);
                                    }
                                }, 520);
                            });
                        }, 480);
                        return;
                    }

                    const delay = Math.random() * 320 + 160;
                    setTimeout(advance, delay);
                };

                updateStatus();
                setTimeout(advance, 420);
            }

            function preloadImages(sources) {
                if (!Array.isArray(sources) || sources.length === 0) {
                    return Promise.resolve([]);
                }
                const validSources = sources.filter((src) => typeof src === 'string' && src.length);
                if (validSources.length === 0) {
                    return Promise.resolve([]);
                }
                return Promise.all(validSources.map((src) => new Promise((resolve) => {
                    const img = new Image();
                    img.onload = resolve;
                    img.onerror = resolve;
                    img.src = src;
                })));
            }

            function setLayerBackground(layer, src) {
                if (layer) {
                    layer.style.backgroundImage = `url('${src}')`;
                }
            }

            function showLayer(layer) {
                if (layer) {
                    layer.classList.add('visible');
                }
            }

            function hideLayer(layer) {
                if (layer) {
                    layer.classList.remove('visible');
                }
            }

            function cycleBackground() {
                if (backgroundImages.length <= 1) {
                    return;
                }
                const nextIndex = (currentBackgroundIndex + 1) % backgroundImages.length;
                const nextLayerIndex = 1 - activeLayerIndex;
                const nextLayer = backgroundLayers[nextLayerIndex];
                const currentLayer = backgroundLayers[activeLayerIndex];

                setLayerBackground(nextLayer, backgroundImages[nextIndex]);

                requestAnimationFrame(() => {
                    showLayer(nextLayer);
                    hideLayer(currentLayer);
                    activeLayerIndex = nextLayerIndex;
                    currentBackgroundIndex = nextIndex;
                });
            }

            preloadImages(backgroundImages).then(() => {
                setLayerBackground(backgroundLayers[activeLayerIndex], backgroundImages[currentBackgroundIndex]);
                showLayer(backgroundLayers[activeLayerIndex]);
                if (backgroundImages.length > 1) {
                    setLayerBackground(backgroundLayers[1 - activeLayerIndex], backgroundImages[(currentBackgroundIndex + 1) % backgroundImages.length]);
                    setInterval(cycleBackground, backgroundChangeInterval);
                }
            });

            const playerImage = loadImageWithFallback(
                resolveAssetConfig(assetOverrides.player, 'assets/player.png'),
                createPlayerFallbackDataUrl
            );

            const asteroidImageSources =
                Array.isArray(assetOverrides.asteroids) && assetOverrides.asteroids.length
                    ? assetOverrides.asteroids
                    : ['assets/asteroid1.png', 'assets/asteroid2.png', 'assets/asteroid3.png'];
            const asteroidImages = asteroidImageSources.map((entry, index) =>
                loadImageWithFallback(resolveAssetConfig(entry, null), () => createAsteroidFallbackDataUrl(index))
            );

            const powerUpOverrides =
                assetOverrides.powerUps && typeof assetOverrides.powerUps === 'object' ? assetOverrides.powerUps : {};
            const powerUpImageSources = {
                powerBomb: 'assets/powerbomb.png',
                bulletSpread: 'assets/powerburger.png',
                missiles: 'assets/powerpizza.png',
                hyperBeam: 'assets/powerbeam.svg'
            };

            const powerUpImages = {};
            for (const [type, defaultSrc] of Object.entries(powerUpImageSources)) {
                powerUpImages[type] = loadImageWithFallback(
                    resolveAssetConfig(powerUpOverrides[type], defaultSrc),
                    () => defaultSrc
                );
            }

            const baseCollectScore = 80;

            const config = {
                baseGameSpeed: 160,
                speedGrowth: 5,
                obstacleSpawnInterval: 950,
                collectibleSpawnInterval: 1400,
                powerUpSpawnInterval: 11000,
                trailSpacing: 18,
                baseTrailLength: 20,
                trailGrowthPerStreak: 0.4,
                tailSmoothing: {
                    growth: 32,
                    shrink: 64
                },
                comboDecayWindow: 3200,
                projectileCooldown: 200,
                projectileSpeed: 900,
                difficulty: {
                    rampDuration: 90000,
                    speedRamp: { start: 0.28, end: 0.9 },
                    spawnIntensity: {
                        obstacle: { start: 0.38, end: 1.08 },
                        collectible: { start: 0.68, end: 1.02 },
                        powerUp: { start: 0.58, end: 0.95 }
                    },
                    healthRamp: { start: 0.7, end: 1.25 }
                },
                player: {
                    width: 120,
                    height: 120,
                    acceleration: 2100,
                    drag: 5.2,
                    maxSpeed: 480,
                    verticalBleed: 0.069,
                    dash: {
                        boostSpeed: 960,
                        duration: 220,
                        doubleTapWindow: 260,
                        dragMultiplier: 0.35
                    }
                },
                obstacle: {
                    minSize: 42,
                    maxSize: 128,
                    minSpeed: -20,
                    maxSpeed: 70
                },
                collectible: {
                    size: 42,
                    minSpeed: -30,
                    maxSpeed: 30,
                    verticalPadding: 48
                },
                powerUp: {
                    size: 85,
                    minSpeed: -20,
                    maxSpeed: 20,
                    wobbleAmplitude: 28,
                    wobbleSpeed: 3.4,
                    duration: {
                        powerBomb: 5200,
                        bulletSpread: 6200,
                        missiles: 5600,
                        hyperBeam: 5600,
                        radiantShield: 7200
                    }
                },
                hyperBeam: {
                    beamHeight: 190,
                    extraLength: 60,
                    rampUp: 280,
                    fadeOut: 220,
                    damagePerSecond: 24,
                    asteroidDamagePerSecond: 30,
                    sparkInterval: 140,
                    hitSparkRate: 7,
                    jitterAmplitude: 18,
                    waveSpeed: 0.006
                },
                defensePower: {
                    clearance: 18,
                    obstacleBounceDuration: 620,
                    obstacleKnockback: 520,
                    obstacleSpeedMultiplier: 1.15,
                    asteroidKnockback: 460,
                    hitCooldown: 520,
                    particleColor: { r: 148, g: 210, b: 255 },
                    auraColor: { r: 150, g: 214, b: 255 },
                    auraPulse: 0.18,
                    bounceDrag: 3.6
                },
                star: {
                    count: 120,
                    baseSpeed: 120
                },
                asteroid: {
                    initialCount: 4,
                    maxCount: 6,
                    spawnInterval: 2600,
                    clusterRadius: 160,
                    minSpacing: 14,
                    scale: 0.4,
                    bounceRestitution: 0.88,
                    collisionRadiusMultiplier: 0.88,
                    sizeRange: [90, 210],
                    speedRange: [40, 140],
                    rotationSpeedRange: [-0.6, 0.6],
                    driftRange: [-18, 18],
                    depthRange: [0.35, 1],
                    meteorShowerInterval: 22000,
                    meteorShowerVariance: 8000,
                    meteorShowerCount: 5,
                    meteorShowerSpeedMultiplier: 1.15
                },
                comboMultiplierStep: 0.15,
                score: {
                    collect: baseCollectScore,
                    destroy: 120,
                    asteroid: 60,
                    dodge: 18,
                    villainEscape: 140
                }
            };

            const collectibleTiers = [
                {
                    key: 'point',
                    label: 'POINT',
                    src: 'assets/point.png',
                    points: baseCollectScore,
                    weight: 0.62,
                    sizeMultiplier: 1,
                    glow: {
                        inner: 'rgba(255, 215, 0, 0.9)',
                        outer: 'rgba(255, 215, 0, 0.25)'
                    },
                    particleColor: { r: 255, g: 215, b: 0 }
                },
                {
                    key: 'point2',
                    label: 'POINT+',
                    src: 'assets/point2.png',
                    points: Math.round(baseCollectScore * 1.75),
                    weight: 0.26,
                    sizeMultiplier: 1.08,
                    glow: {
                        inner: 'rgba(96, 165, 250, 0.9)',
                        outer: 'rgba(96, 165, 250, 0.22)'
                    },
                    particleColor: { r: 96, g: 165, b: 250 }
                },
                {
                    key: 'point3',
                    label: 'POINT++',
                    src: 'assets/point3.png',
                    points: Math.round(baseCollectScore * 2.5),
                    weight: 0.12,
                    sizeMultiplier: 1.16,
                    glow: {
                        inner: 'rgba(192, 132, 252, 0.95)',
                        outer: 'rgba(192, 132, 252, 0.28)'
                    },
                    particleColor: { r: 192, g: 132, b: 252 }
                }
            ];

            const collectibleOverrides =
                assetOverrides.collectibles && typeof assetOverrides.collectibles === 'object'
                    ? assetOverrides.collectibles
                    : {};
            for (const tier of collectibleTiers) {
                tier.asset = resolveAssetConfig(collectibleOverrides[tier.key], tier.src ?? null);
                if (typeof tier.asset === 'string') {
                    tier.src = tier.asset;
                } else if (tier.asset && typeof tier.asset === 'object' && typeof tier.asset.src === 'string') {
                    tier.src = tier.asset.src;
                }
            }

            const collectibleImages = {};
            for (const tier of collectibleTiers) {
                const fallbackSrc = createCollectibleFallbackDataUrl(tier);
                const assetConfig = tier.asset ?? tier.src ?? null;
                collectibleImages[tier.key] = loadImageWithFallback(
                    assetConfig ?? fallbackSrc,
                    () => fallbackSrc ?? tier.src ?? null
                );
            }

            const totalCollectibleWeight = collectibleTiers.reduce((sum, tier) => sum + tier.weight, 0);

            const state = {
                score: 0,
                nyan: 0,
                streak: 0,
                bestStreak: 0,
                tailLength: config.baseTrailLength,
                tailTarget: config.baseTrailLength,
                comboTimer: 0,
                gameSpeed: config.baseGameSpeed,
                timeSinceLastShot: 0,
                gameState: 'ready',
                elapsedTime: 0,
                powerUpTimers: {
                    powerBomb: 0,
                    bulletSpread: 0,
                    missiles: 0,
                    hyperBeam: 0,
                    radiantShield: 0
                },
                powerBombPulseTimer: 0,
                lastVillainKey: null,
                recentVillains: [],
                meteorShowerTimer: 0,
                nextMeteorShower: 0,
                dashTimer: 0,
                shieldHitPulse: 0
            };

            updateTimerDisplay();

            const keys = new Set();
            const dashTapTracker = new Map();
            const keyAliasMap = {
                ArrowUp: 'ArrowUp',
                Up: 'ArrowUp',
                Numpad8: 'ArrowUp',
                ArrowDown: 'ArrowDown',
                Down: 'ArrowDown',
                Numpad2: 'ArrowDown',
                ArrowLeft: 'ArrowLeft',
                Left: 'ArrowLeft',
                Numpad4: 'ArrowLeft',
                ArrowRight: 'ArrowRight',
                Right: 'ArrowRight',
                Numpad6: 'ArrowRight',
                Space: 'Space',
                Spacebar: 'Space',
                ' ': 'Space'
            };
            const preventDefaultKeys = new Set([
                'ArrowUp',
                'ArrowDown',
                'ArrowLeft',
                'ArrowRight',
                'KeyW',
                'KeyA',
                'KeyS',
                'KeyD',
                'Space'
            ]);
            function normalizeKey(event) {
                const { code, key } = event;
                if (code && keyAliasMap[code]) {
                    return keyAliasMap[code];
                }
                if (code) {
                    return code;
                }
                if (key && keyAliasMap[key]) {
                    return keyAliasMap[key];
                }
                if (key && key.length === 1) {
                    const upper = key.toUpperCase();
                    if (upper >= 'A' && upper <= 'Z') {
                        return `Key${upper}`;
                    }
                }
                return key ?? code;
            }
            const dashDirections = {
                ArrowUp: { x: 0, y: -1 },
                KeyW: { x: 0, y: -1 },
                ArrowDown: { x: 0, y: 1 },
                KeyS: { x: 0, y: 1 },
                ArrowLeft: { x: -1, y: 0 },
                KeyA: { x: -1, y: 0 },
                ArrowRight: { x: 1, y: 0 },
                KeyD: { x: 1, y: 0 }
            };
            const virtualInput = {
                moveX: 0,
                moveY: 0,
                firing: false
            };
            const joystickState = {
                pointerId: null,
                touchId: null
            };
            let firePointerId = null;
            let fireTouchId = null;
            const projectiles = [];
            const obstacles = [];
            const collectibles = [];
            const powerUps = [];
            const stars = [];
            const asteroids = [];
            let asteroidSpawnTimer = 0;
            const particles = [];
            const villainExplosions = [];
            const trail = [];
            const areaBursts = [];
            const floatingTexts = [];
            const cameraShake = { intensity: 0, duration: 0, elapsed: 0, offsetX: 0, offsetY: 0 };
            const hyperBeamState = {
                intensity: 0,
                wave: 0,
                sparkTimer: 0,
                bounds: null
            };
            const spawnTimers = {
                obstacle: 0,
                collectible: 0,
                powerUp: 0
            };

            const HYPER_BEAM_POWER = 'hyperBeam';
            const SHIELD_POWER = 'radiantShield';
            const powerUpTypes = ['powerBomb', 'bulletSpread', 'missiles', HYPER_BEAM_POWER, SHIELD_POWER];
            const powerUpLabels = {
                powerBomb: 'Nova Pulse',
                bulletSpread: 'Starlight Spread',
                missiles: 'Comet Missiles',
                [HYPER_BEAM_POWER]: 'Hyper Beam',
                [SHIELD_POWER]: 'Radiant Shield'
            };
            const powerUpColors = {
                powerBomb: { r: 255, g: 168, b: 112 },
                bulletSpread: { r: 255, g: 128, b: 255 },
                missiles: { r: 255, g: 182, b: 92 },
                [HYPER_BEAM_POWER]: { r: 147, g: 197, b: 253 },
                [SHIELD_POWER]: { r: 148, g: 210, b: 255 }
            };

            const villainExplosionPalettes = {
                villain1: {
                    core: { r: 255, g: 170, b: 255 },
                    halo: { r: 140, g: 195, b: 255 },
                    spark: { r: 210, g: 240, b: 255 }
                },
                villain2: {
                    core: { r: 120, g: 255, b: 214 },
                    halo: { r: 90, g: 200, b: 255 },
                    spark: { r: 180, g: 255, b: 220 }
                },
                villain3: {
                    core: { r: 255, g: 120, b: 160 },
                    halo: { r: 255, g: 200, b: 120 },
                    spark: { r: 255, g: 180, b: 140 }
                }
            };

            const villainTypes = [
                {
                    key: 'villain1',
                    name: 'Void Raider',
                    imageSrc: 'assets/villain1.png',
                    size: { min: 44, max: 58 },
                    speedOffset: { min: 14, max: 34 },
                    rotation: { min: -1.8, max: 1.8 },
                    baseHealth: 1,
                    healthGrowth: 0.7,
                    behavior: { type: 'sine', amplitude: 36, speed: 2.8 }
                },
                {
                    key: 'villain2',
                    name: 'Nebula Marauder',
                    imageSrc: 'assets/villain2.png',
                    size: { min: 70, max: 96 },
                    speedOffset: { min: 8, max: 30 },
                    rotation: { min: -1.4, max: 1.4 },
                    baseHealth: 2.3,
                    healthGrowth: 1.2,
                    behavior: { type: 'drift', verticalSpeed: 120 }
                },
                {
                    key: 'villain3',
                    name: 'Abyss Overlord',
                    imageSrc: 'assets/villain3.png',
                    size: { min: 102, max: 138 },
                    speedOffset: { min: -2, max: 32 },
                    rotation: { min: -1, max: 1 },
                    baseHealth: 3.4,
                    healthGrowth: 1.8,
                    behavior: { type: 'tracker', acceleration: 200, maxSpeed: 260 }
                }
            ];

            const villainOverrides =
                assetOverrides.villains && typeof assetOverrides.villains === 'object'
                    ? assetOverrides.villains
                    : {};
            for (const villain of villainTypes) {
                villain.asset = resolveAssetConfig(villainOverrides[villain.key], villain.imageSrc);
                if (typeof villain.asset === 'string') {
                    villain.imageSrc = villain.asset;
                } else if (villain.asset && typeof villain.asset === 'object' && typeof villain.asset.src === 'string') {
                    villain.imageSrc = villain.asset.src;
                }
            }

            function getVillainWeights() {
                const progress = getDifficultyProgress();
                const eased = easeInOutQuad(progress);
                const baseWeights = [0.55, 0.32, 0.13];
                const villain2Boost = lerp(0, 0.12, eased);
                const villain3Boost = lerp(0, 0.07, Math.pow(progress, 1.4));

                const weights = [
                    Math.max(0.28, baseWeights[0] - (villain2Boost * 0.45 + villain3Boost)),
                    baseWeights[1] + villain2Boost,
                    Math.max(0.08, baseWeights[2] + villain3Boost)
                ];

                const total = weights.reduce((sum, weight) => sum + weight, 0);
                return weights.map((weight) => (total > 0 ? weight / total : 1 / weights.length));
            }

            function selectVillainType() {
                const weights = getVillainWeights();
                const adjustedWeights = [...weights];

                if (state.lastVillainKey) {
                    const lastIndex = villainTypes.findIndex((villain) => villain.key === state.lastVillainKey);
                    if (lastIndex >= 0) {
                        adjustedWeights[lastIndex] *= 0.45;
                    }
                }

                if (state.recentVillains.length) {
                    const recentCounts = {};
                    for (const key of state.recentVillains) {
                        recentCounts[key] = (recentCounts[key] ?? 0) + 1;
                    }
                    const historySize = Math.max(1, state.recentVillains.length);
                    for (let i = 0; i < villainTypes.length; i++) {
                        const key = villainTypes[i].key;
                        const recentCount = recentCounts[key] ?? 0;
                        if (recentCount > 0) {
                            const dampen = 1 + recentCount / historySize;
                            adjustedWeights[i] /= dampen;
                        }
                    }
                }

                if (villainTypes.length > 0) {
                    adjustedWeights[villainTypes.length - 1] *= 0.85;
                }

                const adjustedTotal = adjustedWeights.reduce((sum, weight) => sum + weight, 0);
                const normalizedTotal = adjustedTotal > 0 ? adjustedTotal : 1;
                const roll = Math.random();
                let cumulative = 0;

                for (let i = 0; i < villainTypes.length; i++) {
                    cumulative += adjustedWeights[i] / normalizedTotal;
                    if (roll <= cumulative) {
                        return villainTypes[i];
                    }
                }

                return villainTypes[villainTypes.length - 1];
            }

            const villainImages = {};
            for (const [index, villain] of villainTypes.entries()) {
                const image = loadImageWithFallback(
                    villain.asset ?? villain.imageSrc,
                    () => createVillainFallbackDataUrl(index) ?? villain.imageSrc
                );
                villainImages[villain.key] = image;
                villain.image = image;
            }

            const player = {
                x: canvas.width * 0.18,
                y: canvas.height * 0.5,
                width: config.player.width,
                height: config.player.height,
                vx: 0,
                vy: 0
            };

            function resetGame() {
                state.score = 0;
                state.nyan = 0;
                state.streak = 0;
                state.bestStreak = 0;
                state.tailLength = config.baseTrailLength;
                state.tailTarget = config.baseTrailLength;
                state.comboTimer = 0;
                state.gameSpeed = config.baseGameSpeed;
                state.timeSinceLastShot = 0;
                state.elapsedTime = 0;
                state.powerUpTimers.powerBomb = 0;
                state.powerUpTimers.bulletSpread = 0;
                state.powerUpTimers.missiles = 0;
                state.powerUpTimers.radiantShield = 0;
                state.powerUpTimers[HYPER_BEAM_POWER] = 0;
                state.powerBombPulseTimer = 0;
                state.shieldHitPulse = 0;
                state.lastVillainKey = null;
                state.recentVillains.length = 0;
                state.dashTimer = 0;
                hyperBeamState.intensity = 0;
                hyperBeamState.wave = 0;
                hyperBeamState.sparkTimer = 0;
                hyperBeamState.bounds = null;
                player.x = canvas.width * 0.18;
                player.y = canvas.height * 0.5;
                player.vx = 0;
                player.vy = 0;
                projectiles.length = 0;
                obstacles.length = 0;
                collectibles.length = 0;
                powerUps.length = 0;
                villainExplosions.length = 0;
                particles.length = 0;
                trail.length = 0;
                areaBursts.length = 0;
                spawnTimers.obstacle = 0;
                spawnTimers.collectible = 0;
                spawnTimers.powerUp = 0;
                state.meteorShowerTimer = 0;
                state.nextMeteorShower = 0;
                audioManager.stopHyperBeam();
                createInitialStars();
                scheduleNextMeteorShower();
                comboFillEl.style.width = '100%';
                if (comboMeterEl) {
                    comboMeterEl.setAttribute('aria-valuenow', '100');
                }
                lastComboPercent = 100;
                lastFormattedTimer = '';
                updateHUD();
                updateTimerDisplay();
                resetVirtualControls();
            }

            function createInitialStars() {
                stars.length = 0;
                for (let i = 0; i < config.star.count; i++) {
                    stars.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        speed: (Math.random() * 0.8 + 0.4) * config.star.baseSpeed,
                        size: Math.random() * 2.5 + 0.6,
                        twinkleOffset: Math.random() * Math.PI * 2
                    });
                }
            }

            function createAsteroid(initial = false) {
                const settings = config.asteroid;
                const scale = settings?.scale ?? 1;
                const depth = randomBetween(settings.depthRange[0], settings.depthRange[1]);
                const baseSize = lerp(settings.sizeRange[0], settings.sizeRange[1], depth);
                const size = baseSize * scale;
                const asteroid = {
                    depth,
                    baseSize,
                    size,
                    radius: size * 0.5,
                    mass: Math.max(1, size * size * 0.0004),
                    speed: lerp(settings.speedRange[0], settings.speedRange[1], depth),
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed:
                        randomBetween(settings.rotationSpeedRange[0], settings.rotationSpeedRange[1]) *
                        (0.4 + depth),
                    drift:
                        randomBetween(settings.driftRange[0], settings.driftRange[1]) *
                        Math.max(0.12, 1 - depth * 0.6),
                    vx: 0,
                    vy: 0,
                    x: 0,
                    y: 0,
                    image: asteroidImages[Math.floor(Math.random() * asteroidImages.length)] ?? null,
                    bobOffset: Math.random() * Math.PI * 2,
                    health: Math.max(1, Math.round(size / 32)),
                    hitFlash: 0,
                    shieldCooldown: 0
                };
                placeAsteroid(asteroid, initial);
                asteroid.vx = -asteroid.speed * (0.6 + asteroid.depth * 0.8);
                asteroid.vy = asteroid.drift;
                return asteroid;
            }

            function placeAsteroid(asteroid, initial = false) {
                const settings = config.asteroid ?? {};
                const clusterRadius = settings.clusterRadius ?? 160;
                const minSpacing = settings.minSpacing ?? 12;
                const spawnOffset = settings.spawnOffset ?? 140;
                const attempts = settings.placementAttempts ?? 24;

                for (let attempt = 0; attempt < attempts; attempt++) {
                    let anchor = null;
                    if (asteroids.length && (initial || Math.random() < 0.85)) {
                        anchor = asteroids[Math.floor(Math.random() * asteroids.length)];
                    }

                    let candidateX;
                    let candidateY;

                    if (anchor) {
                        candidateX = anchor.x + randomBetween(-clusterRadius, clusterRadius);
                        if (!initial) {
                            candidateX = Math.max(candidateX, canvas.width - clusterRadius * 0.8);
                        }
                        candidateY = anchor.y + randomBetween(-clusterRadius * 0.6, clusterRadius * 0.6);
                    } else if (initial) {
                        candidateX = Math.random() * canvas.width;
                        candidateY = Math.random() * canvas.height;
                    } else {
                        candidateX = canvas.width + spawnOffset + Math.random() * clusterRadius;
                        candidateY = Math.random() * canvas.height;
                    }

                    candidateX = clamp(candidateX, asteroid.radius + minSpacing, canvas.width + clusterRadius);
                    candidateY = clamp(
                        candidateY,
                        asteroid.radius + minSpacing,
                        canvas.height - asteroid.radius - minSpacing
                    );

                    let overlaps = false;
                    for (const other of asteroids) {
                        const dx = other.x - candidateX;
                        const dy = other.y - candidateY;
                        const minDist = asteroid.radius + other.radius + minSpacing;
                        if (dx * dx + dy * dy < minDist * minDist) {
                            overlaps = true;
                            break;
                        }
                    }

                    if (!overlaps) {
                        asteroid.x = candidateX;
                        asteroid.y = candidateY;
                        return;
                    }
                }

                asteroid.x = initial ? Math.random() * canvas.width : canvas.width + asteroid.size;
                asteroid.y = clamp(Math.random() * canvas.height, asteroid.radius, canvas.height - asteroid.radius);
            }

            function resolveAsteroidCollisions() {
                if (asteroids.length < 2) return;
                const settings = config.asteroid ?? {};
                const minSpacing = settings.minSpacing ?? 12;
                const restitution = settings.bounceRestitution ?? 0.9;

                for (let i = 0; i < asteroids.length - 1; i++) {
                    const a = asteroids[i];
                    for (let j = i + 1; j < asteroids.length; j++) {
                        const b = asteroids[j];
                        const dx = b.x - a.x;
                        const dy = b.y - a.y;
                        const minDistance = a.radius + b.radius + minSpacing;
                        const distanceSq = dx * dx + dy * dy;
                        if (distanceSq === 0 || distanceSq >= minDistance * minDistance) {
                            continue;
                        }

                        const distance = Math.sqrt(distanceSq);
                        const nx = dx / distance;
                        const ny = dy / distance;
                        const overlap = minDistance - distance;
                        const massA = a.mass ?? 1;
                        const massB = b.mass ?? 1;
                        const totalMass = massA + massB;

                        const moveA = overlap * (massB / totalMass);
                        const moveB = overlap * (massA / totalMass);

                        a.x -= nx * moveA;
                        a.y -= ny * moveA;
                        b.x += nx * moveB;
                        b.y += ny * moveB;

                        const relativeVelocity = (a.vx - b.vx) * nx + (a.vy - b.vy) * ny;
                        if (relativeVelocity > 0) {
                            continue;
                        }

                        const impulse = -(1 + restitution) * relativeVelocity;
                        const impulsePerMassA = impulse * (massB / totalMass);
                        const impulsePerMassB = impulse * (massA / totalMass);

                        a.vx += nx * impulsePerMassA;
                        a.vy += ny * impulsePerMassA;
                        b.vx -= nx * impulsePerMassB;
                        b.vy -= ny * impulsePerMassB;
                    }
                }
            }

            function createInitialAsteroids() {
                asteroids.length = 0;
                asteroidSpawnTimer = 0;
                const settings = config.asteroid ?? {};
                const count = settings.initialCount ?? settings.maxCount ?? 0;
                for (let i = 0; i < count; i++) {
                    asteroids.push(createAsteroid(true));
                }
                resolveAsteroidCollisions();
            }

            function scheduleNextMeteorShower() {
                const settings = config.asteroid ?? {};
                const interval = settings.meteorShowerInterval ?? 0;
                state.meteorShowerTimer = 0;
                if (!interval || interval <= 0) {
                    state.nextMeteorShower = 0;
                    return;
                }
                const variance = settings.meteorShowerVariance ?? 0;
                if (!variance) {
                    state.nextMeteorShower = interval;
                    return;
                }
                const minInterval = Math.max(2000, interval - variance);
                const maxInterval = interval + variance;
                state.nextMeteorShower = randomBetween(minInterval, maxInterval);
            }

            function spawnMeteorShower() {
                const settings = config.asteroid ?? {};
                const formation = settings.meteorShowerFormation ?? [
                    { x: 0, y: 0 },
                    { x: 70, y: -56 },
                    { x: 70, y: 56 },
                    { x: 140, y: -112 },
                    { x: 140, y: 112 }
                ];
                const desiredCount = settings.meteorShowerCount ?? formation.length;
                if (!desiredCount || desiredCount < 1) {
                    return false;
                }

                const offsets = formation.slice(0, desiredCount);
                if (!offsets.length) {
                    return false;
                }

                const required = offsets.length;
                if (settings.maxCount && required > settings.maxCount) {
                    return false;
                }
                if (settings.maxCount && asteroids.length + required > settings.maxCount) {
                    const excess = asteroids.length + required - settings.maxCount;
                    if (excess > 0) {
                        const removable = asteroids
                            .map((asteroid, index) => ({ index, x: asteroid.x }))
                            .sort((a, b) => b.x - a.x)
                            .slice(0, excess)
                            .map((item) => item.index)
                            .sort((a, b) => b - a);
                        for (const removeIndex of removable) {
                            asteroids.splice(removeIndex, 1);
                        }
                    }
                }

                const spawnOffset = settings.spawnOffset ?? 140;
                const spawnX = canvas.width + spawnOffset;
                const scale = settings.scale ?? 1;
                const minSize = Array.isArray(settings.sizeRange) ? settings.sizeRange[0] ?? 40 : 40;
                const actualSize = minSize * scale;
                const minSpacing = settings.minSpacing ?? 12;
                const minY = actualSize * 0.5 + minSpacing;
                const maxY = canvas.height - actualSize * 0.5 - minSpacing;
                const centerY = clamp(Math.random() * (maxY - minY) + minY, minY, maxY);
                const speedMultiplier = settings.meteorShowerSpeedMultiplier ?? 1;

                let spawnedAny = false;
                for (const offset of offsets) {
                    const asteroid = createAsteroid(false);
                    asteroid.depth = settings.depthRange ? settings.depthRange[0] : asteroid.depth;
                    asteroid.baseSize = minSize;
                    asteroid.size = actualSize;
                    asteroid.radius = asteroid.size * 0.5;
                    asteroid.mass = Math.max(1, asteroid.size * asteroid.size * 0.0004);
                    const hasSpeedRange = Array.isArray(settings.speedRange);
                    const baseSpeed = hasSpeedRange
                        ? lerp(settings.speedRange[0], settings.speedRange[1], 1)
                        : asteroid.speed;
                    asteroid.speed = baseSpeed * speedMultiplier;
                    asteroid.rotationSpeed = randomBetween(
                        settings.rotationSpeedRange?.[0] ?? -0.6,
                        settings.rotationSpeedRange?.[1] ?? 0.6
                    ) * (0.4 + asteroid.depth);
                    const driftRangeMin = settings.driftRange?.[0] ?? -18;
                    const driftRangeMax = settings.driftRange?.[1] ?? 18;
                    const driftScale = Math.max(0.18, 1 - asteroid.depth * 0.6);
                    asteroid.drift = randomBetween(driftRangeMin * 0.4, driftRangeMax * 0.4) * driftScale;
                    asteroid.vx = -asteroid.speed * (0.6 + asteroid.depth * 0.8);
                    asteroid.vy = asteroid.drift;
                    asteroid.x = spawnX + offset.x;
                    asteroid.y = clamp(centerY + offset.y, minY, maxY);
                    asteroid.health = Math.max(1, Math.round(asteroid.size / 32));
                    asteroid.hitFlash = 0;
                    asteroids.push(asteroid);
                    spawnedAny = true;
                }

                if (spawnedAny) {
                    asteroidSpawnTimer = 0;
                }

                return spawnedAny;
            }

            function updateAsteroids(delta) {
                const settings = config.asteroid ?? {};
                const spawnInterval = settings.spawnInterval ?? 0;
                if (state.gameState === 'running') {
                    asteroidSpawnTimer += delta;
                }

                let spawned = false;
                if (state.gameState === 'running' && settings.maxCount > 0 && spawnInterval > 0) {
                    while (asteroidSpawnTimer >= spawnInterval && asteroids.length < settings.maxCount) {
                        asteroidSpawnTimer -= spawnInterval;
                        asteroids.push(createAsteroid(false));
                        spawned = true;
                    }

                    if (asteroids.length >= settings.maxCount) {
                        asteroidSpawnTimer = Math.min(asteroidSpawnTimer, spawnInterval);
                    }
                }

                if (state.gameState !== 'running') {
                    state.meteorShowerTimer = 0;
                } else if (state.nextMeteorShower > 0) {
                    state.meteorShowerTimer += delta;
                    if (state.meteorShowerTimer >= state.nextMeteorShower) {
                        const created = spawnMeteorShower();
                        if (created) {
                            spawned = true;
                            scheduleNextMeteorShower();
                        } else {
                            state.meteorShowerTimer = state.nextMeteorShower * 0.6;
                        }
                    }
                }

                if (spawned) {
                    resolveAsteroidCollisions();
                }

                if (!asteroids.length) return;

                const deltaSeconds = delta / 1000;
                const parallaxFactor = 0.4 + state.gameSpeed / 900;
                const flowLerp = settings.flowLerp ?? 0.08;

                for (let i = asteroids.length - 1; i >= 0; i--) {
                    const asteroid = asteroids[i];
                    const targetVx = -asteroid.speed * parallaxFactor * (0.6 + asteroid.depth * 0.8);
                    asteroid.vx += (targetVx - asteroid.vx) * flowLerp;
                    const targetVy = asteroid.drift;
                    asteroid.vy += (targetVy - asteroid.vy) * flowLerp;

                    asteroid.x += asteroid.vx * deltaSeconds;
                    asteroid.y += asteroid.vy * deltaSeconds;
                    asteroid.rotation += asteroid.rotationSpeed * deltaSeconds;

                    if (asteroid.hitFlash > 0) {
                        asteroid.hitFlash = Math.max(0, asteroid.hitFlash - delta);
                    }

                    if (asteroid.shieldCooldown > 0) {
                        asteroid.shieldCooldown = Math.max(0, asteroid.shieldCooldown - delta);
                    }

                    if (asteroid.y < asteroid.radius) {
                        asteroid.y = asteroid.radius;
                        asteroid.vy = Math.abs(asteroid.vy || targetVy);
                    } else if (asteroid.y > canvas.height - asteroid.radius) {
                        asteroid.y = canvas.height - asteroid.radius;
                        asteroid.vy = -Math.abs(asteroid.vy || targetVy);
                    }

                    if (asteroid.x < -asteroid.size) {
                        asteroids.splice(i, 1);
                        asteroidSpawnTimer = 0;
                        continue;
                    }

                    if (state.gameState === 'running') {
                        const collisionRadius = asteroid.radius * (settings.collisionRadiusMultiplier ?? 1);
                        if (circleRectOverlap({ x: asteroid.x, y: asteroid.y, radius: collisionRadius }, player)) {
                            if (isShieldActive() && asteroid.shieldCooldown <= 0) {
                                repelAsteroidFromPlayer(asteroid);
                                continue;
                            }
                            triggerGameOver('An asteroid shattered your shields!');
                            return;
                        }

                        for (let j = trail.length - 1; j >= 0; j--) {
                            const t = trail[j];
                            if (Math.hypot(asteroid.x - t.x, asteroid.y - t.y) <= collisionRadius + 10) {
                                if (isShieldActive()) {
                                    if (asteroid.shieldCooldown <= 0) {
                                        repelAsteroidFromPlayer(asteroid);
                                    }
                                    break;
                                }
                                triggerGameOver('Your tail clipped an asteroid!');
                                return;
                            }
                        }
                    }
                }

                resolveAsteroidCollisions();

                const maxX = canvas.width + (settings.clusterRadius ?? 160);
                for (const asteroid of asteroids) {
                    asteroid.y = clamp(asteroid.y, asteroid.radius, canvas.height - asteroid.radius);
                    asteroid.x = Math.min(asteroid.x, maxX);
                }
            }

            function getAsteroidScoreValue(asteroid) {
                const base = config.score?.asteroid ?? 0;
                return base + Math.round((asteroid.size ?? 0) * 0.4);
            }

            function createAsteroidDebris(asteroid) {
                createParticles({
                    x: asteroid.x,
                    y: asteroid.y,
                    color: { r: 196, g: 206, b: 220 },
                    count: Math.round(12 + asteroid.radius * 0.6),
                    speedRange: [80, 360],
                    sizeRange: [0.7, 2.4],
                    lifeRange: [380, 760]
                });
            }

            function destroyAsteroid(index, options = {}) {
                const asteroid = asteroids[index];
                if (!asteroid) return;
                createAsteroidDebris(asteroid);
                audioManager.playExplosion('asteroid');
                if (options.createSpark !== false) {
                    createHitSpark({ x: asteroid.x, y: asteroid.y, color: { r: 186, g: 198, b: 214 } });
                }
                if (state.gameState === 'running' && options.awardScore !== false) {
                    awardScore(getAsteroidScoreValue(asteroid), {
                        x: asteroid.x,
                        y: asteroid.y,
                        type: 'asteroid',
                        color: '#fca5a5'
                    });
                    triggerScreenShake(Math.min(10, 4 + asteroid.radius * 0.04), 220);
                }
                asteroids.splice(index, 1);
                asteroidSpawnTimer = 0;
            }

            function damageAsteroid(asteroid, damage, index) {
                asteroid.health -= damage;
                asteroid.hitFlash = 220;
                if (asteroid.health <= 0) {
                    destroyAsteroid(index);
                } else {
                    createHitSpark({ x: asteroid.x, y: asteroid.y, color: { r: 172, g: 184, b: 204 } });
                }
            }

            function drawAsteroids(time) {
                if (!asteroids.length) return;
                ctx.save();
                for (const asteroid of asteroids) {
                    const bob = Math.sin(time * 0.0012 + asteroid.bobOffset) * asteroid.depth * 8;
                    const alpha = clamp(0.25 + asteroid.depth * 0.6, 0, 1);
                    const drawSize = asteroid.size;
                    ctx.save();
                    ctx.translate(asteroid.x, asteroid.y + bob);
                    ctx.rotate(asteroid.rotation);
                    ctx.globalAlpha = alpha;
                    const image = asteroid.image;
                    const flashStrength = clamp((asteroid.hitFlash ?? 0) / 220, 0, 1);
                    if (flashStrength > 0) {
                        ctx.filter = `brightness(${1 + flashStrength * 0.6}) saturate(${1 + flashStrength * 0.3})`;
                    }
                    if (image && image.complete && image.naturalWidth > 0) {
                        ctx.drawImage(image, -drawSize / 2, -drawSize / 2, drawSize, drawSize);
                    } else {
                        ctx.fillStyle = `rgba(94, 106, 134, ${alpha})`;
                        ctx.beginPath();
                        ctx.arc(0, 0, drawSize / 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    if (flashStrength > 0) {
                        ctx.filter = 'none';
                    }
                    ctx.restore();
                }
                ctx.restore();
            }

            function clamp(value, min, max) {
                return Math.max(min, Math.min(max, value));
            }

            function randomBetween(min, max) {
                return Math.random() * (max - min) + min;
            }

            function lerp(a, b, t) {
                return a + (b - a) * t;
            }

            function easeInOutQuad(t) {
                return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
            }

            function getDifficultyProgress() {
                if (!config.difficulty) return 1;
                return clamp(state.elapsedTime / config.difficulty.rampDuration, 0, 1);
            }

            function getSpeedRampMultiplier() {
                if (!config.difficulty?.speedRamp) return 1;
                const eased = easeInOutQuad(getDifficultyProgress());
                return lerp(config.difficulty.speedRamp.start, config.difficulty.speedRamp.end, eased);
            }

            function getSpawnIntensity(type) {
                const settings = config.difficulty?.spawnIntensity?.[type];
                if (!settings) return 1;
                const eased = easeInOutQuad(getDifficultyProgress());
                return lerp(settings.start, settings.end, eased);
            }

            function getHealthRampMultiplier() {
                const settings = config.difficulty?.healthRamp;
                if (!settings) return 1;
                const eased = easeInOutQuad(getDifficultyProgress());
                return lerp(settings.start, settings.end, eased);
            }

            function showOverlay(message, buttonText, options = {}) {
                overlayMessage.textContent = message;
                overlayButton.textContent = buttonText;
                if (overlayTitle) {
                    const titleText = options.title ?? overlayDefaultTitle;
                    overlayTitle.textContent = titleText;
                }
                resetVirtualControls();
                if (overlay) {
                    overlay.classList.remove('hidden');
                    overlay.setAttribute('aria-hidden', 'false');
                }
                if (overlayButton) {
                    window.requestAnimationFrame(() => {
                        try {
                            overlayButton.focus({ preventScroll: true });
                        } catch {
                            // Ignore focus errors (e.g., if element is detached)
                        }
                    });
                }
            }

            function hideOverlay() {
                if (overlay) {
                    overlay.classList.add('hidden');
                    overlay.setAttribute('aria-hidden', 'true');
                }
                if (overlayButton && typeof document !== 'undefined') {
                    const activeElement = document.activeElement;
                    if (activeElement === overlayButton) {
                        overlayButton.blur();
                    }
                }
            }

            function setJoystickThumbPosition(dx, dy) {
                if (!joystickThumb) return;
                const xValue = typeof dx === 'number' ? `${dx}px` : dx;
                const yValue = typeof dy === 'number' ? `${dy}px` : dy;
                joystickThumb.style.setProperty('--thumb-x', xValue);
                joystickThumb.style.setProperty('--thumb-y', yValue);
            }

            function resetJoystick() {
                const pointerId = joystickState.pointerId;
                if (pointerId !== null && joystickZone?.hasPointerCapture?.(pointerId)) {
                    joystickZone.releasePointerCapture(pointerId);
                }
                joystickState.pointerId = null;
                joystickState.touchId = null;
                virtualInput.moveX = 0;
                virtualInput.moveY = 0;
                setJoystickThumbPosition('0px', '0px');
            }

            function resetFiring() {
                const pointerId = firePointerId;
                if (pointerId !== null && fireButton?.hasPointerCapture?.(pointerId)) {
                    fireButton.releasePointerCapture(pointerId);
                }
                firePointerId = null;
                fireTouchId = null;
                virtualInput.firing = false;
                if (fireButton) {
                    fireButton.classList.remove('active');
                }
            }

            function resetVirtualControls() {
                resetJoystick();
                resetFiring();
            }

            function updateJoystickFromPointer(event) {
                if (!joystickZone) return;
                const rect = joystickZone.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                let dx = event.clientX - centerX;
                let dy = event.clientY - centerY;
                const maxDistance = rect.width * 0.5;
                const distance = Math.hypot(dx, dy);
                if (distance > maxDistance && distance > 0) {
                    const scale = maxDistance / distance;
                    dx *= scale;
                    dy *= scale;
                }

                setJoystickThumbPosition(dx, dy);

                const normalizedX = clamp(dx / maxDistance, -1, 1);
                const normalizedY = clamp(dy / maxDistance, -1, 1);
                const deadZone = 0.14;
                virtualInput.moveX = Math.abs(normalizedX) < deadZone ? 0 : normalizedX;
                virtualInput.moveY = Math.abs(normalizedY) < deadZone ? 0 : normalizedY;
            }

            function endJoystickControl() {
                resetJoystick();
            }

            function handleJoystickPointerEnd(event) {
                if (joystickState.pointerId !== event.pointerId) {
                    return;
                }
                if (joystickZone?.hasPointerCapture?.(event.pointerId)) {
                    joystickZone.releasePointerCapture(event.pointerId);
                }
                endJoystickControl();
            }

            function getTouchById(touchList, identifier) {
                if (!touchList || identifier == null) {
                    return null;
                }
                for (let i = 0; i < touchList.length; i++) {
                    const touch = touchList.item ? touchList.item(i) : touchList[i];
                    if (touch?.identifier === identifier) {
                        return touch;
                    }
                }
                return null;
            }

            function handleJoystickTouchEnd(identifier) {
                if (joystickState.touchId !== identifier) {
                    return;
                }
                endJoystickControl();
            }

            function engageFireControl(event) {
                const pointerId = event?.pointerId ?? null;
                firePointerId = pointerId;
                fireTouchId = null;
                virtualInput.firing = true;
                if (fireButton) {
                    fireButton.classList.add('active');
                    if (pointerId !== null) {
                        fireButton.setPointerCapture?.(pointerId);
                    }
                }
            }

            function engageFireTouchControl(identifier) {
                firePointerId = null;
                fireTouchId = identifier;
                virtualInput.firing = true;
                if (fireButton) {
                    fireButton.classList.add('active');
                }
            }

            function handleFirePointerEnd(event) {
                if (firePointerId !== event.pointerId) {
                    return;
                }
                if (fireButton?.hasPointerCapture?.(event.pointerId)) {
                    fireButton.releasePointerCapture(event.pointerId);
                }
                resetFiring();
            }

            function handleFireTouchEnd(identifier) {
                if (fireTouchId !== identifier) {
                    return;
                }
                resetFiring();
            }

            function focusGameCanvas() {
                if (!canvas) return;
                try {
                    canvas.focus({ preventScroll: true });
                } catch {
                    canvas.focus();
                }
            }

            function startGame() {
                resetGame();
                state.gameState = 'running';
                lastTime = null;
                accumulatedDelta = 0;
                hideOverlay();
                audioManager.unlock();
                audioManager.playGameplayMusic();
                focusGameCanvas();
            }

            overlayButton.addEventListener('click', () => {
                if (state.gameState === 'ready' || state.gameState === 'gameover') {
                    startGame();
                }
            });

            if (!supportsPointerEvents && overlayButton) {
                overlayButton.addEventListener('touchstart', (event) => {
                    if (state.gameState === 'ready' || state.gameState === 'gameover') {
                        event.preventDefault();
                        startGame();
                    }
                }, { passive: false });
            }

            if (canvas) {
                canvas.addEventListener('pointerdown', () => {
                    focusGameCanvas();
                });
                if (!supportsPointerEvents) {
                    canvas.addEventListener('touchstart', () => {
                        focusGameCanvas();
                    }, { passive: true });
                }
            }

            if (joystickZone) {
                if (supportsPointerEvents) {
                    joystickZone.addEventListener('pointerdown', (event) => {
                        joystickState.pointerId = event.pointerId;
                        joystickState.touchId = null;
                        focusGameCanvas();
                        event.preventDefault();
                        joystickZone.setPointerCapture?.(event.pointerId);
                        updateJoystickFromPointer(event);
                    });

                    joystickZone.addEventListener('pointermove', (event) => {
                        if (joystickState.pointerId !== event.pointerId) return;
                        updateJoystickFromPointer(event);
                    });

                    joystickZone.addEventListener('pointerup', (event) => {
                        handleJoystickPointerEnd(event);
                    });

                    joystickZone.addEventListener('pointercancel', (event) => {
                        handleJoystickPointerEnd(event);
                    });

                    joystickZone.addEventListener('lostpointercapture', (event) => {
                        if (joystickState.pointerId === event.pointerId) {
                            endJoystickControl();
                        }
                    });
                } else {
                    const handleTouchMove = (event) => {
                        const touch = getTouchById(event.changedTouches, joystickState.touchId);
                        if (!touch) {
                            return;
                        }
                        event.preventDefault();
                        updateJoystickFromPointer(touch);
                    };

                    const handleTouchEnd = (event) => {
                        const touch = getTouchById(event.changedTouches, joystickState.touchId);
                        if (!touch) {
                            return;
                        }
                        event.preventDefault();
                        handleJoystickTouchEnd(touch.identifier);
                    };

                    joystickZone.addEventListener('touchstart', (event) => {
                        if (joystickState.touchId !== null) {
                            return;
                        }
                        const touch = event.changedTouches.item(0);
                        if (!touch) {
                            return;
                        }
                        joystickState.touchId = touch.identifier;
                        joystickState.pointerId = null;
                        focusGameCanvas();
                        event.preventDefault();
                        updateJoystickFromPointer(touch);
                    }, { passive: false });

                    joystickZone.addEventListener('touchmove', handleTouchMove, { passive: false });
                    joystickZone.addEventListener('touchend', handleTouchEnd, { passive: false });
                    joystickZone.addEventListener('touchcancel', handleTouchEnd, { passive: false });
                }
            }

            if (fireButton) {
                if (supportsPointerEvents) {
                    fireButton.addEventListener('pointerdown', (event) => {
                        focusGameCanvas();
                        event.preventDefault();
                        engageFireControl(event);
                    });

                    fireButton.addEventListener('pointerup', (event) => {
                        handleFirePointerEnd(event);
                    });

                    fireButton.addEventListener('pointercancel', (event) => {
                        handleFirePointerEnd(event);
                    });

                    fireButton.addEventListener('lostpointercapture', (event) => {
                        if (firePointerId === event.pointerId) {
                            resetFiring();
                        }
                    });
                } else {
                    const handleTouchEnd = (event) => {
                        const touch = getTouchById(event.changedTouches, fireTouchId);
                        if (!touch) {
                            return;
                        }
                        event.preventDefault();
                        handleFireTouchEnd(touch.identifier);
                    };

                    fireButton.addEventListener('touchstart', (event) => {
                        if (fireTouchId !== null) {
                            return;
                        }
                        const touch = event.changedTouches.item(0);
                        if (!touch) {
                            return;
                        }
                        focusGameCanvas();
                        event.preventDefault();
                        engageFireTouchControl(touch.identifier);
                    }, { passive: false });

                    fireButton.addEventListener('touchend', handleTouchEnd, { passive: false });
                    fireButton.addEventListener('touchcancel', handleTouchEnd, { passive: false });
                }
            }

            window.addEventListener('keydown', (event) => {
                const normalizedKey = normalizeKey(event);
                if (!normalizedKey) {
                    return;
                }
                if (preventDefaultKeys.has(normalizedKey)) {
                    event.preventDefault();
                }
                keys.add(normalizedKey);
                if (!event.repeat) {
                    const dashDirection = dashDirections[normalizedKey];
                    if (dashDirection) {
                        const now = performance.now();
                        const lastTap = dashTapTracker.get(normalizedKey);
                        if (lastTap && now - lastTap <= config.player.dash.doubleTapWindow) {
                            dashTapTracker.delete(normalizedKey);
                            triggerDash(dashDirection);
                        } else {
                            dashTapTracker.set(normalizedKey, now);
                        }
                    }
                }
                if (normalizedKey === 'Enter' && (state.gameState === 'ready' || state.gameState === 'gameover')) {
                    startGame();
                }
            });

            window.addEventListener('keyup', (event) => {
                const normalizedKey = normalizeKey(event);
                if (!normalizedKey) {
                    return;
                }
                keys.delete(normalizedKey);
            });

            window.addEventListener('blur', () => {
                keys.clear();
                dashTapTracker.clear();
                resetVirtualControls();
            });

            function triggerDash(direction) {
                const dashConfig = config.player.dash;
                state.dashTimer = dashConfig.duration;
                if (direction.x !== 0) {
                    player.vx = direction.x * dashConfig.boostSpeed;
                }
                if (direction.y !== 0) {
                    player.vy = direction.y * dashConfig.boostSpeed;
                }
            }

            function isPowerUpActive(type) {
                return state.powerUpTimers[type] > 0;
            }

            function isShieldActive() {
                return isPowerUpActive(SHIELD_POWER);
            }

            function getPlayerCenter() {
                return {
                    x: player.x + player.width * 0.5,
                    y: player.y + player.height * 0.5
                };
            }

            function triggerShieldImpact(x, y, normalX = 0, normalY = 0) {
                const shieldConfig = config.defensePower ?? {};
                const color = shieldConfig.particleColor ?? { r: 148, g: 210, b: 255 };
                const offsetX = x + normalX * 12;
                const offsetY = y + normalY * 12;
                createParticles({
                    x: offsetX,
                    y: offsetY,
                    color,
                    count: 16,
                    speedRange: [160, 420],
                    sizeRange: [1.2, 3.2],
                    lifeRange: [320, 640]
                });
                state.shieldHitPulse = Math.min(1.2, (state.shieldHitPulse ?? 0) + 0.5);
            }

            function repelObstacleFromPlayer(obstacle) {
                const shieldConfig = config.defensePower ?? {};
                const { x: playerCenterX, y: playerCenterY } = getPlayerCenter();
                const obstacleCenterX = obstacle.x + obstacle.width * 0.5;
                const obstacleCenterY = obstacle.y + obstacle.height * 0.5;
                const dx = obstacleCenterX - playerCenterX;
                const dy = obstacleCenterY - playerCenterY;
                const distance = Math.max(Math.hypot(dx, dy), 1);
                const normalX = dx / distance;
                const normalY = dy / distance;
                const clearance = shieldConfig.clearance ?? 12;
                const playerHalfWidth = player.width * 0.5;
                const playerHalfHeight = player.height * 0.5;
                const obstacleHalfWidth = obstacle.width * 0.5;
                const obstacleHalfHeight = obstacle.height * 0.5;
                const targetCenterX = playerCenterX + normalX * (playerHalfWidth + obstacleHalfWidth + clearance);
                const targetCenterY = playerCenterY + normalY * (playerHalfHeight + obstacleHalfHeight + clearance);

                obstacle.x = targetCenterX - obstacleHalfWidth;
                obstacle.y = clamp(targetCenterY - obstacleHalfHeight, 16, canvas.height - obstacle.height - 16);

                const knockback = shieldConfig.obstacleKnockback ?? 520;
                obstacle.vx = normalX * knockback;
                obstacle.vy = normalY * (knockback * 0.7);
                obstacle.bounceTimer = shieldConfig.obstacleBounceDuration ?? 520;
                const speedMultiplier = shieldConfig.obstacleSpeedMultiplier ?? 1.1;
                obstacle.speed = -Math.max(Math.abs(obstacle.speed), state.gameSpeed) * speedMultiplier;
                obstacle.shieldCooldown = shieldConfig.hitCooldown ?? 400;
                obstacle.hitFlash = 160;

                triggerShieldImpact(targetCenterX, targetCenterY, normalX, normalY);
            }

            function repelAsteroidFromPlayer(asteroid) {
                const shieldConfig = config.defensePower ?? {};
                const { x: playerCenterX, y: playerCenterY } = getPlayerCenter();
                const dx = asteroid.x - playerCenterX;
                const dy = asteroid.y - playerCenterY;
                const distance = Math.max(Math.hypot(dx, dy), 1);
                const normalX = dx / distance;
                const normalY = dy / distance;
                const clearance = shieldConfig.clearance ?? 12;
                const playerRadius = Math.max(player.width, player.height) * 0.5;
                const targetDistance = playerRadius + asteroid.radius + clearance;
                asteroid.x = playerCenterX + normalX * targetDistance;
                asteroid.y = clamp(playerCenterY + normalY * targetDistance, asteroid.radius, canvas.height - asteroid.radius);

                const knockback = shieldConfig.asteroidKnockback ?? 420;
                asteroid.vx = normalX * knockback;
                asteroid.vy = normalY * (knockback * 0.75);
                asteroid.shieldCooldown = shieldConfig.hitCooldown ?? 400;
                asteroid.hitFlash = 180;

                triggerShieldImpact(asteroid.x, asteroid.y, normalX, normalY);
            }


            function attemptShoot(delta) {
                state.timeSinceLastShot += delta;
                const cooldown = config.projectileCooldown;
                if ((keys.has('Space') || virtualInput.firing) && state.timeSinceLastShot >= cooldown) {
                    spawnProjectiles();
                    state.timeSinceLastShot = 0;
                }
            }

            function spawnProjectiles() {
                const originX = player.x + player.width - 12;
                const originY = player.y + player.height * 0.5 - 6;
                const firedTypes = new Set();
                const createProjectile = (angle, type = 'standard') => {
                    const speed = config.projectileSpeed * (type === 'missile' ? 0.85 : 1);
                    const vx = Math.cos(angle) * speed;
                    const vy = Math.sin(angle) * speed;
                    firedTypes.add(type);
                    projectiles.push({
                        x: originX,
                        y: originY,
                        width: 24,
                        height: 12,
                        vx,
                        vy,
                        life: type === 'missile' ? 2800 : 2000,
                        type
                    });
                };

                if (isPowerUpActive('missiles')) {
                    createProjectile(0, 'missile');
                    createProjectile(0.1, 'missile');
                } else if (isPowerUpActive('bulletSpread')) {
                    const spread = 0.22;
                    createProjectile(-spread, 'spread');
                    createProjectile(0, 'spread');
                    createProjectile(spread, 'spread');
                } else {
                    createProjectile(0, 'standard');
                }

                for (const type of firedTypes) {
                    audioManager.playProjectile(type);
                }
            }

            function updateTailLength(delta) {
                const deltaSeconds = delta / 1000;
                if (state.tailLength < state.tailTarget) {
                    state.tailLength = Math.min(
                        state.tailTarget,
                        state.tailLength + config.tailSmoothing.growth * deltaSeconds
                    );
                } else if (state.tailLength > state.tailTarget) {
                    state.tailLength = Math.max(
                        state.tailTarget,
                        state.tailLength - config.tailSmoothing.shrink * deltaSeconds
                    );
                }
            }

            function updatePlayer(delta) {
                const deltaSeconds = delta / 1000;
                const keyboardX = (keys.has('ArrowRight') || keys.has('KeyD') ? 1 : 0) - (keys.has('ArrowLeft') || keys.has('KeyA') ? 1 : 0);
                const keyboardY = (keys.has('ArrowDown') || keys.has('KeyS') ? 1 : 0) - (keys.has('ArrowUp') || keys.has('KeyW') ? 1 : 0);
                const inputX = clamp(keyboardX + virtualInput.moveX, -1, 1);
                const inputY = clamp(keyboardY + virtualInput.moveY, -1, 1);

                const accel = config.player.acceleration;
                const drag = config.player.drag;
                const dashConfig = config.player.dash;
                const isDashing = state.dashTimer > 0;
                const effectiveDrag = isDashing ? drag * dashConfig.dragMultiplier : drag;
                const maxSpeed = isDashing ? dashConfig.boostSpeed : config.player.maxSpeed;

                player.vx += (inputX * accel - player.vx * effectiveDrag) * deltaSeconds;
                player.vy += (inputY * accel - player.vy * effectiveDrag) * deltaSeconds;

                player.vx = clamp(player.vx, -maxSpeed, maxSpeed);
                player.vy = clamp(player.vy, -maxSpeed, maxSpeed);

                player.x += player.vx * deltaSeconds;
                player.y += player.vy * deltaSeconds;

                if (state.dashTimer > 0) {
                    state.dashTimer = Math.max(0, state.dashTimer - delta);
                }

                player.x = clamp(player.x, 0, canvas.width - player.width);
                const verticalBleed = canvas.height * config.player.verticalBleed;
                player.y = clamp(player.y, -verticalBleed, canvas.height - player.height + verticalBleed);

                attemptShoot(delta);

                updateTailLength(delta);
                updateTrail();
            }

            function updateTrail() {
                const centerX = player.x + player.width * 0.45;
                const centerY = player.y + player.height * 0.55;
                const lastPoint = trail[trail.length - 1];
                if (!lastPoint || Math.hypot(centerX - lastPoint.x, centerY - lastPoint.y) > config.trailSpacing) {
                    trail.push({
                        x: centerX,
                        y: centerY
                    });
                    if (trail.length > state.tailLength) {
                        trail.shift();
                    }
                }
            }

            function findNearestObstacle(projectile) {
                let closest = null;
                let closestDistSq = Infinity;
                const projCenterX = projectile.x + projectile.width * 0.5;
                const projCenterY = projectile.y + projectile.height * 0.5;
                for (const obstacle of obstacles) {
                    const centerX = obstacle.x + obstacle.width * 0.5;
                    const centerY = obstacle.y + obstacle.height * 0.5;
                    const dx = centerX - projCenterX;
                    const dy = centerY - projCenterY;
                    const distSq = dx * dx + dy * dy;
                    if (distSq < closestDistSq) {
                        closest = { obstacle, dx, dy, distSq };
                        closestDistSq = distSq;
                    }
                }
                return closest?.obstacle ?? null;
            }

            function updateProjectiles(delta) {
                const deltaSeconds = delta / 1000;
                for (let i = projectiles.length - 1; i >= 0; i--) {
                    const projectile = projectiles[i];

                    if (projectile.type === 'missile') {
                        const target = findNearestObstacle(projectile);
                        if (target) {
                            const centerX = projectile.x + projectile.width * 0.5;
                            const centerY = projectile.y + projectile.height * 0.5;
                            const targetX = target.x + target.width * 0.5;
                            const targetY = target.y + target.height * 0.5;
                            const angle = Math.atan2(targetY - centerY, targetX - centerX);
                            const desiredSpeed = config.projectileSpeed * 1.05;
                            const desiredVx = Math.cos(angle) * desiredSpeed;
                            const desiredVy = Math.sin(angle) * desiredSpeed;
                            const turnStrength = Math.min(1, deltaSeconds * 3.5);
                            projectile.vx += (desiredVx - projectile.vx) * turnStrength;
                            projectile.vy += (desiredVy - projectile.vy) * turnStrength;
                        }
                    }

                    projectile.x += projectile.vx * deltaSeconds;
                    projectile.y += projectile.vy * deltaSeconds;
                    projectile.life -= delta;

                    if (
                        projectile.x > canvas.width + 80 ||
                        projectile.x + projectile.width < -80 ||
                        projectile.y < -120 ||
                        projectile.y > canvas.height + 120 ||
                        projectile.life <= 0
                    ) {
                        projectiles.splice(i, 1);
                    }
                }
            }

            function getVillainHealth(size, villainType) {
                const range = villainType.size.max - villainType.size.min;
                const normalized = range > 0 ? (size - villainType.size.min) / range : 0;
                const base = villainType.baseHealth + normalized * villainType.healthGrowth;
                const scaled = base * getHealthRampMultiplier();
                return Math.max(1, Math.round(scaled));
            }

            function createVillainBehaviorState(villainType, size) {
                const behavior = villainType.behavior ?? { type: 'none' };
                const state = { type: behavior.type };

                switch (behavior.type) {
                    case 'sine': {
                        const amplitude = behavior.amplitude ?? 40;
                        const available = Math.max(0, canvas.height - size - amplitude * 2);
                        const baseY = available > 0 ? Math.random() * available + amplitude : Math.random() * (canvas.height - size);
                        const phase = Math.random() * Math.PI * 2;
                        const initialY = clamp(baseY + Math.sin(phase) * amplitude, 0, canvas.height - size);
                        Object.assign(state, {
                            amplitude,
                            speed: behavior.speed ?? 3,
                            phase,
                            baseY,
                            initialY
                        });
                        break;
                    }
                    case 'drift': {
                        const initialY = Math.random() * (canvas.height - size);
                        const maxVertical = behavior.verticalSpeed ?? 120;
                        Object.assign(state, {
                            vy: randomBetween(-maxVertical, maxVertical),
                            verticalSpeed: maxVertical,
                            initialY
                        });
                        break;
                    }
                    case 'tracker': {
                        const initialY = Math.random() * (canvas.height - size);
                        Object.assign(state, {
                            vy: 0,
                            acceleration: behavior.acceleration ?? 120,
                            maxSpeed: behavior.maxSpeed ?? 180,
                            initialY
                        });
                        break;
                    }
                    default: {
                        state.initialY = Math.random() * (canvas.height - size);
                        break;
                    }
                }

                return state;
            }

            function spawnObstacle() {
                const villainType = selectVillainType();
                const size = randomBetween(villainType.size.min, villainType.size.max);
                const health = getVillainHealth(size, villainType);
                const behaviorState = createVillainBehaviorState(villainType, size);
                const spawnY = behaviorState.initialY ?? Math.random() * (canvas.height - size);
                delete behaviorState.initialY;
                const rotationSpeed = randomBetween(villainType.rotation.min, villainType.rotation.max);
                obstacles.push({
                    x: canvas.width + size,
                    y: spawnY,
                    width: size,
                    height: size,
                    speed: state.gameSpeed + randomBetween(villainType.speedOffset.min, villainType.speedOffset.max),
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed,
                    health,
                    maxHealth: health,
                    hitFlash: 0,
                    vx: 0,
                    vy: 0,
                    bounceTimer: 0,
                    shieldCooldown: 0,
                    villainType,
                    behaviorState,
                    image: villainImages[villainType.key]
                });
                state.lastVillainKey = villainType.key;
                state.recentVillains.push(villainType.key);
                if (state.recentVillains.length > 6) {
                    state.recentVillains.shift();
                }
                if (behaviorState.baseY === undefined) {
                    behaviorState.baseY = spawnY;
                }
            }

            function spawnCollectible() {
                const tier = selectCollectibleTier();
                const baseSize = config.collectible.size ?? 32;
                const size = baseSize * (tier.sizeMultiplier ?? 1);
                const verticalPadding = config.collectible.verticalPadding ?? 48;
                const spawnRange = Math.max(canvas.height - size - verticalPadding * 2, 0);
                const spawnY = verticalPadding + Math.random() * spawnRange;
                collectibles.push({
                    x: canvas.width + size,
                    y: spawnY,
                    width: size,
                    height: size,
                    speed: state.gameSpeed + (Math.random() * (config.collectible.maxSpeed - config.collectible.minSpeed) + config.collectible.minSpeed),
                    wobbleTime: Math.random() * Math.PI * 2,
                    type: tier.key,
                    points: tier.points,
                    sprite: collectibleImages[tier.key],
                    glow: tier.glow,
                    particleColor: tier.particleColor,
                    label: tier.label
                });
            }

            function selectCollectibleTier() {
                if (collectibleTiers.length === 0) {
                    return {
                        key: 'point',
                        label: 'POINT',
                        src: 'assets/point.png',
                        points: baseCollectScore,
                        weight: 1,
                        sizeMultiplier: 1,
                        glow: null,
                        particleColor: { r: 255, g: 215, b: 0 }
                    };
                }

                const roll = Math.random() * (totalCollectibleWeight || 1);
                let cumulative = 0;
                for (const tier of collectibleTiers) {
                    cumulative += tier.weight;
                    if (roll <= cumulative) {
                        return tier;
                    }
                }
                return collectibleTiers[collectibleTiers.length - 1];
            }

            function spawnPowerUp() {
                const type = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
                const size = config.powerUp.size;
                powerUps.push({
                    x: canvas.width + size,
                    y: Math.random() * (canvas.height - size * 2) + size,
                    width: size,
                    height: size,
                    speed: state.gameSpeed + (Math.random() * (config.powerUp.maxSpeed - config.powerUp.minSpeed) + config.powerUp.minSpeed),
                    wobbleTime: Math.random() * Math.PI * 2,
                    type
                });
            }

            function applyVillainBehavior(obstacle, deltaSeconds) {
                const behaviorState = obstacle.behaviorState;
                const villainBehavior = obstacle.villainType?.behavior;
                if (!behaviorState || !villainBehavior) {
                    return;
                }

                switch (villainBehavior.type) {
                    case 'sine': {
                        behaviorState.phase += deltaSeconds * (behaviorState.speed ?? villainBehavior.speed ?? 3);
                        const amplitude = behaviorState.amplitude ?? villainBehavior.amplitude ?? 40;
                        const targetY = behaviorState.baseY + Math.sin(behaviorState.phase) * amplitude;
                        obstacle.y = clamp(targetY, 0, canvas.height - obstacle.height);
                        break;
                    }
                    case 'drift': {
                        obstacle.y += behaviorState.vy * deltaSeconds;
                        if (obstacle.y < 24) {
                            obstacle.y = 24;
                            behaviorState.vy = Math.abs(behaviorState.vy);
                        } else if (obstacle.y + obstacle.height > canvas.height - 24) {
                            obstacle.y = canvas.height - 24 - obstacle.height;
                            behaviorState.vy = -Math.abs(behaviorState.vy);
                        }
                        break;
                    }
                    case 'tracker': {
                        const targetY = player.y + player.height * 0.5 - obstacle.height * 0.5;
                        const direction = targetY - obstacle.y;
                        const accel = Math.sign(direction) * (behaviorState.acceleration ?? villainBehavior.acceleration ?? 120);
                        behaviorState.vy += accel * deltaSeconds;
                        const maxSpeed = behaviorState.maxSpeed ?? villainBehavior.maxSpeed ?? 180;
                        behaviorState.vy = clamp(behaviorState.vy, -maxSpeed, maxSpeed);
                        obstacle.y += behaviorState.vy * deltaSeconds;
                        obstacle.y = clamp(obstacle.y, 16, canvas.height - obstacle.height - 16);
                        break;
                    }
                    default:
                        break;
                }
            }

            function updateObstacles(delta) {
                const deltaSeconds = delta / 1000;
                for (let i = obstacles.length - 1; i >= 0; i--) {
                    const obstacle = obstacles[i];
                    obstacle.x -= obstacle.speed * deltaSeconds;
                    obstacle.rotation += obstacle.rotationSpeed * deltaSeconds;
                    if (obstacle.hitFlash > 0) {
                        obstacle.hitFlash = Math.max(0, obstacle.hitFlash - delta);
                    }

                    if (obstacle.shieldCooldown > 0) {
                        obstacle.shieldCooldown = Math.max(0, obstacle.shieldCooldown - delta);
                    }

                    if (obstacle.bounceTimer > 0) {
                        obstacle.bounceTimer = Math.max(0, obstacle.bounceTimer - delta);
                        const damping = Math.exp(-(config.defensePower?.bounceDrag ?? 3.4) * deltaSeconds);
                        obstacle.x += obstacle.vx * deltaSeconds;
                        obstacle.y += obstacle.vy * deltaSeconds;
                        obstacle.vx *= damping;
                        obstacle.vy *= damping;
                        if (obstacle.bounceTimer === 0) {
                            obstacle.speed = Math.abs(obstacle.speed);
                            obstacle.vx = 0;
                            obstacle.vy = 0;
                        }
                    }

                    applyVillainBehavior(obstacle, deltaSeconds);

                    if (obstacle.x + obstacle.width < 0) {
                        obstacles.splice(i, 1);
                        handleVillainEscape(obstacle);
                        continue;
                    }

                    obstacle.y = clamp(obstacle.y, 16, canvas.height - obstacle.height - 16);

                    if (rectOverlap(player, obstacle)) {
                        if (isShieldActive() && obstacle.shieldCooldown <= 0) {
                            repelObstacleFromPlayer(obstacle);
                            continue;
                        }
                        return triggerGameOver('Your rainbow ship took a direct hit!');
                    }

                    for (let j = trail.length - 1; j >= 0; j--) {
                        const t = trail[j];
                        if (circleRectOverlap({ x: t.x, y: t.y, radius: 10 }, obstacle)) {
                            if (isShieldActive()) {
                                if (obstacle.shieldCooldown <= 0) {
                                    repelObstacleFromPlayer(obstacle);
                                }
                                break;
                            }
                            return triggerGameOver('Your tail tangled with space junk!');
                        }
                    }
                }
            }

            function updateCollectibles(delta) {
                const deltaSeconds = delta / 1000;
                for (let i = collectibles.length - 1; i >= 0; i--) {
                    const collectible = collectibles[i];
                    collectible.x -= collectible.speed * deltaSeconds;
                    collectible.wobbleTime += deltaSeconds * 4;
                    collectible.y += Math.sin(collectible.wobbleTime) * 18 * deltaSeconds;
                    const verticalPadding = config.collectible.verticalPadding ?? 48;
                    collectible.y = clamp(collectible.y, verticalPadding, canvas.height - collectible.height - verticalPadding);

                    if (collectible.x + collectible.width < 0) {
                        collectibles.splice(i, 1);
                        resetStreak();
                        continue;
                    }

                    if (rectOverlap(player, collectible)) {
                        collectibles.splice(i, 1);
                        awardCollect(collectible);
                        createParticles({
                            x: collectible.x + collectible.width * 0.5,
                            y: collectible.y + collectible.height * 0.5,
                            color: collectible.particleColor ?? { r: 255, g: 215, b: 0 }
                        });
                    }
                }
            }

            function triggerPowerBombPulse() {
                const centerX = player.x + player.width * 0.5;
                const centerY = player.y + player.height * 0.5;
                const burst = {
                    x: centerX,
                    y: centerY,
                    radius: 0,
                    maxRadius: 360,
                    speed: 760,
                    life: 650,
                    hitSet: new WeakSet()
                };
                areaBursts.push(burst);
                audioManager.playExplosion('powerbomb');
                createParticles({
                    x: centerX,
                    y: centerY,
                    color: { r: 255, g: 196, b: 128 }
                });
            }

            function activatePowerUp(type) {
                const duration = config.powerUp.duration[type];
                if (duration) {
                    state.powerUpTimers[type] = duration;
                }
                if (type === 'powerBomb') {
                    triggerPowerBombPulse();
                    state.powerBombPulseTimer = 900;
                } else if (type === SHIELD_POWER) {
                    state.shieldHitPulse = Math.max(state.shieldHitPulse, 0.6);
                    const { x, y } = getPlayerCenter();
                    triggerShieldImpact(x, y);
                } else if (type === HYPER_BEAM_POWER) {
                    hyperBeamState.sparkTimer = 0;
                    hyperBeamState.intensity = Math.max(hyperBeamState.intensity, 0.25);
                    audioManager.playHyperBeam();
                }
            }

            function updatePowerUps(delta) {
                const deltaSeconds = delta / 1000;
                for (let i = powerUps.length - 1; i >= 0; i--) {
                    const powerUp = powerUps[i];
                    powerUp.x -= powerUp.speed * deltaSeconds;
                    powerUp.wobbleTime += deltaSeconds * config.powerUp.wobbleSpeed;
                    powerUp.y += Math.sin(powerUp.wobbleTime) * config.powerUp.wobbleAmplitude * deltaSeconds;
                    powerUp.y = clamp(powerUp.y, 32, canvas.height - 32 - powerUp.height);

                    if (powerUp.x + powerUp.width < 0) {
                        powerUps.splice(i, 1);
                        continue;
                    }

                    if (rectOverlap(player, powerUp)) {
                        powerUps.splice(i, 1);
                        activatePowerUp(powerUp.type);
                        const color = powerUpColors[powerUp.type] ?? { r: 200, g: 200, b: 255 };
                        createParticles({
                            x: powerUp.x + powerUp.width * 0.5,
                            y: powerUp.y + powerUp.height * 0.5,
                            color
                        });
                    }
                }
            }

            function updatePowerUpTimers(delta) {
                for (const type of powerUpTypes) {
                    if (state.powerUpTimers[type] > 0) {
                        state.powerUpTimers[type] = Math.max(0, state.powerUpTimers[type] - delta);
                        if (type === 'powerBomb' && state.powerUpTimers[type] === 0) {
                            state.powerBombPulseTimer = 0;
                        }
                        if (type === SHIELD_POWER && state.powerUpTimers[type] === 0) {
                            state.shieldHitPulse = 0;
                        }
                        if (type === HYPER_BEAM_POWER && state.powerUpTimers[type] === 0) {
                            hyperBeamState.sparkTimer = 0;
                            audioManager.stopHyperBeam();
                        }
                    }
                }
            }

            function updatePowerBomb(delta) {
                if (!isPowerUpActive('powerBomb')) return;
                state.powerBombPulseTimer -= delta;
                if (state.powerBombPulseTimer <= 0) {
                    triggerPowerBombPulse();
                    state.powerBombPulseTimer = 900;
                }
            }

            function computeHyperBeamBounds(hyperConfig) {
                const startX = player.x + player.width * 0.55;
                const width = Math.max(0, canvas.width - startX + (hyperConfig.extraLength ?? 40));
                if (width <= 0) {
                    return null;
                }
                const { y: centerY } = getPlayerCenter();
                const height = Math.min(hyperConfig.beamHeight ?? 180, canvas.height);
                let top = centerY - height / 2;
                if (top < 0) {
                    top = 0;
                } else if (top + height > canvas.height) {
                    top = Math.max(0, canvas.height - height);
                }
                return { x: startX, y: top, width, height };
            }

            function applyHyperBeamDamage(bounds, delta, hyperConfig) {
                if (!bounds) return;
                const intensity = hyperBeamState.intensity;
                if (intensity <= 0) return;

                const deltaSeconds = delta / 1000;
                const sparkColor = powerUpColors[HYPER_BEAM_POWER] ?? { r: 147, g: 197, b: 253 };
                const hitSparkRate = hyperConfig.hitSparkRate ?? 7;
                const damage = (hyperConfig.damagePerSecond ?? 20) * deltaSeconds * intensity;
                const asteroidDamage = (hyperConfig.asteroidDamagePerSecond ?? damage) * deltaSeconds * intensity;

                for (let i = obstacles.length - 1; i >= 0; i--) {
                    const obstacle = obstacles[i];
                    if (!rectOverlap(bounds, obstacle)) continue;

                    obstacle.health -= damage;
                    obstacle.hitFlash = Math.max(obstacle.hitFlash ?? 0, 180 * intensity);

                    if (obstacle.health <= 0) {
                        obstacles.splice(i, 1);
                        awardDestroy(obstacle);
                        createVillainExplosion(obstacle);
                        continue;
                    }

                    if (Math.random() < deltaSeconds * hitSparkRate * intensity) {
                        createHitSpark({
                            x: obstacle.x + obstacle.width * randomBetween(0.4, 0.9),
                            y: obstacle.y + obstacle.height * randomBetween(0.2, 0.8),
                            color: sparkColor
                        });
                    }
                }

                for (let i = asteroids.length - 1; i >= 0; i--) {
                    const asteroid = asteroids[i];
                    const radius = asteroid.radius * (config.asteroid?.collisionRadiusMultiplier ?? 1);
                    if (!circleRectOverlap({ x: asteroid.x, y: asteroid.y, radius }, bounds)) continue;
                    damageAsteroid(asteroid, asteroidDamage, i);
                }
            }

            function spawnHyperBeamParticles(bounds, delta, hyperConfig) {
                if (!bounds) return;
                const intensity = hyperBeamState.intensity;
                if (intensity <= 0) return;

                hyperBeamState.sparkTimer -= delta;
                if (hyperBeamState.sparkTimer > 0) {
                    return;
                }

                const baseInterval = hyperConfig.sparkInterval ?? 140;
                const scaledInterval = baseInterval / Math.max(0.45, intensity);
                hyperBeamState.sparkTimer = randomBetween(scaledInterval * 0.6, scaledInterval * 1.4);

                const color = powerUpColors[HYPER_BEAM_POWER] ?? { r: 147, g: 197, b: 253 };
                const count = Math.max(1, Math.round(1 + intensity * 2));
                for (let i = 0; i < count; i++) {
                    const spawnX = randomBetween(bounds.x + bounds.width * 0.2, bounds.x + bounds.width * 0.9);
                    const spawnY = randomBetween(bounds.y, bounds.y + bounds.height);
                    particles.push({
                        x: spawnX,
                        y: spawnY,
                        vx: randomBetween(120, 240),
                        vy: randomBetween(-140, 140),
                        life: randomBetween(240, 420),
                        color,
                        size: randomBetween(1.2, 2.6)
                    });
                }
            }

            function updateHyperBeam(delta) {
                const hyperConfig = config.hyperBeam ?? {};
                const isActive = isPowerUpActive(HYPER_BEAM_POWER);
                const rampUp = Math.max(1, hyperConfig.rampUp ?? 240);
                const fadeOut = Math.max(1, hyperConfig.fadeOut ?? 240);

                if (isActive) {
                    hyperBeamState.intensity = Math.min(1, hyperBeamState.intensity + (delta / rampUp));
                } else {
                    hyperBeamState.intensity = Math.max(0, hyperBeamState.intensity - (delta / fadeOut));
                }

                if (hyperBeamState.intensity <= 0) {
                    hyperBeamState.sparkTimer = 0;
                    hyperBeamState.bounds = null;
                    hyperBeamState.wave = 0;
                    audioManager.stopHyperBeam();
                    return;
                }

                const bounds = computeHyperBeamBounds(hyperConfig);
                hyperBeamState.bounds = bounds;
                hyperBeamState.wave = (hyperBeamState.wave + delta * (hyperConfig.waveSpeed ?? 0.006)) % (Math.PI * 2);

                if (!bounds) {
                    return;
                }

                if (state.gameState === 'running' && isActive) {
                    applyHyperBeamDamage(bounds, delta, hyperConfig);
                    spawnHyperBeamParticles(bounds, delta, hyperConfig);
                }
            }

            function updateShieldEffects(delta) {
                if (state.shieldHitPulse > 0) {
                    state.shieldHitPulse = Math.max(0, state.shieldHitPulse - delta / 900);
                }
            }

            function updateAreaBursts(delta) {
                const deltaSeconds = delta / 1000;
                for (let i = areaBursts.length - 1; i >= 0; i--) {
                    const burst = areaBursts[i];
                    burst.radius = Math.min(burst.maxRadius, burst.radius + burst.speed * deltaSeconds);
                    burst.life -= delta;

                    for (let j = obstacles.length - 1; j >= 0; j--) {
                        const obstacle = obstacles[j];
                        if (burst.hitSet.has(obstacle)) continue;
                        const centerX = obstacle.x + obstacle.width * 0.5;
                        const centerY = obstacle.y + obstacle.height * 0.5;
                        const distance = Math.hypot(centerX - burst.x, centerY - burst.y);
                        const hitRadius = burst.radius + obstacle.width * 0.5;
                        if (distance <= hitRadius) {
                            burst.hitSet.add(obstacle);
                            obstacles.splice(j, 1);
                            awardDestroy(obstacle);
                            createVillainExplosion(obstacle);
                        }
                    }

                    for (let j = asteroids.length - 1; j >= 0; j--) {
                        const asteroid = asteroids[j];
                        if (burst.hitSet.has(asteroid)) continue;
                        const distance = Math.hypot(asteroid.x - burst.x, asteroid.y - burst.y);
                        const hitRadius = burst.radius + asteroid.radius;
                        if (distance <= hitRadius) {
                            burst.hitSet.add(asteroid);
                            destroyAsteroid(j);
                        }
                    }

                    if (burst.life <= 0) {
                        areaBursts.splice(i, 1);
                    }
                }
            }

            function updateVillainExplosions(delta) {
                const deltaSeconds = delta / 1000;
                for (let i = villainExplosions.length - 1; i >= 0; i--) {
                    const explosion = villainExplosions[i];

                    if (typeof explosion.expansionSpeed === 'number' && typeof explosion.maxRadius === 'number') {
                        explosion.radius = Math.min(
                            explosion.maxRadius,
                            explosion.radius + explosion.expansionSpeed * deltaSeconds
                        );
                    }

                    if (typeof explosion.ringRadius === 'number' && typeof explosion.ringGrowth === 'number') {
                        const maxRing = explosion.maxRingRadius ?? Number.POSITIVE_INFINITY;
                        explosion.ringRadius = Math.min(maxRing, explosion.ringRadius + explosion.ringGrowth * deltaSeconds);
                    }

                    switch (explosion.type) {
                        case 'nova': {
                            explosion.pulse = (explosion.pulse ?? 0) + deltaSeconds * 5;
                            if (explosion.spokes) {
                                for (const spoke of explosion.spokes) {
                                    spoke.length = Math.min(spoke.maxLength, spoke.length + spoke.growth * deltaSeconds);
                                }
                            }
                            break;
                        }
                        case 'ionBurst': {
                            if (explosion.orbits) {
                                for (const orbit of explosion.orbits) {
                                    if (orbit.radius < orbit.targetRadius) {
                                        orbit.radius = Math.min(
                                            orbit.targetRadius,
                                            orbit.radius + orbit.growth * deltaSeconds
                                        );
                                    }
                                    orbit.angle += orbit.rotationSpeed * deltaSeconds;
                                    if (orbit.targetEccentricity !== undefined) {
                                        orbit.eccentricity +=
                                            (orbit.targetEccentricity - orbit.eccentricity) * deltaSeconds * 0.8;
                                    }
                                }
                            }
                            if (explosion.sparks) {
                                for (const spark of explosion.sparks) {
                                    spark.distance += spark.speed * deltaSeconds;
                                    spark.angle += spark.drift * deltaSeconds;
                                }
                            }
                            if (explosion.swirl) {
                                explosion.swirl.angle += explosion.swirl.speed * deltaSeconds;
                            }
                            break;
                        }
                        case 'gravityRift': {
                            if (explosion.core) {
                                explosion.core.radius = Math.max(
                                    explosion.core.minRadius,
                                    explosion.core.radius - explosion.core.collapseSpeed * deltaSeconds
                                );
                            }
                            if (explosion.shockwaves) {
                                for (const shock of explosion.shockwaves) {
                                    if (shock.delay > 0) {
                                        shock.delay = Math.max(0, shock.delay - delta);
                                        continue;
                                    }
                                    shock.radius = Math.min(shock.maxRadius, shock.radius + shock.speed * deltaSeconds);
                                }
                            }
                            if (explosion.fractures) {
                                for (const fracture of explosion.fractures) {
                                    fracture.length = Math.min(
                                        fracture.maxLength,
                                        fracture.length + fracture.growth * deltaSeconds
                                    );
                                }
                            }
                            if (explosion.embers) {
                                for (const ember of explosion.embers) {
                                    ember.radius += ember.growth * deltaSeconds;
                                    ember.angle += ember.rotationSpeed * deltaSeconds;
                                    ember.opacity = Math.max(0, ember.opacity - delta / explosion.maxLife);
                                }
                            }
                            break;
                        }
                        default:
                            break;
                    }

                    explosion.life -= delta;
                    if (explosion.life <= 0) {
                        villainExplosions.splice(i, 1);
                    }
                }
            }

            function updateStars(delta) {
                const deltaSeconds = delta / 1000;
                for (let i = stars.length - 1; i >= 0; i--) {
                    const star = stars[i];
                    star.x -= star.speed * deltaSeconds * (0.4 + state.gameSpeed / 600);
                    if (star.x < -star.size) {
                        star.x = canvas.width + star.size;
                        star.y = Math.random() * canvas.height;
                        star.speed = (Math.random() * 0.8 + 0.4) * config.star.baseSpeed;
                    }
                }
            }

            function updateParticles(delta) {
                const deltaSeconds = delta / 1000;
                for (let i = particles.length - 1; i >= 0; i--) {
                    const particle = particles[i];
                    particle.life -= delta;
                    if (particle.life <= 0) {
                        particles.splice(i, 1);
                        continue;
                    }
                    particle.x += particle.vx * deltaSeconds;
                    particle.y += particle.vy * deltaSeconds;
                    particle.vx *= 0.96;
                    particle.vy *= 0.96;
                }
            }

            function updateSpawns(delta) {
                spawnTimers.obstacle += delta;
                spawnTimers.collectible += delta;
                spawnTimers.powerUp += delta;

                const obstacleInterval = config.obstacleSpawnInterval / (1 + state.gameSpeed * 0.005 * getSpawnIntensity('obstacle'));
                const collectibleInterval = config.collectibleSpawnInterval / (1 + state.gameSpeed * 0.004 * getSpawnIntensity('collectible'));
                const powerUpInterval = config.powerUpSpawnInterval / (1 + state.gameSpeed * 0.003 * getSpawnIntensity('powerUp'));

                if (spawnTimers.obstacle >= obstacleInterval) {
                    spawnTimers.obstacle = 0;
                    spawnObstacle();
                }

                if (spawnTimers.collectible >= collectibleInterval) {
                    spawnTimers.collectible = 0;
                    spawnCollectible();
                }

                if (spawnTimers.powerUp >= powerUpInterval) {
                    spawnTimers.powerUp = -Math.random() * 2000;
                    spawnPowerUp();
                }
            }

            function getProjectileDamage(projectile) {
                switch (projectile.type) {
                    case 'missile':
                        return 2;
                    case 'spread':
                        return 1;
                    default:
                        return 1;
                }
            }

            function updateProjectilesCollisions() {
                for (let i = projectiles.length - 1; i >= 0; i--) {
                    const projectile = projectiles[i];
                    let projectileRemoved = false;
                    for (let j = obstacles.length - 1; j >= 0; j--) {
                        const obstacle = obstacles[j];
                        if (!rectOverlap(projectile, obstacle)) continue;

                        const damage = getProjectileDamage(projectile);
                        obstacle.health -= damage;
                        obstacle.hitFlash = 160;

                        projectiles.splice(i, 1);
                        projectileRemoved = true;

                        if (obstacle.health <= 0) {
                            obstacles.splice(j, 1);
                            awardDestroy(obstacle);
                            createVillainExplosion(obstacle);
                        } else {
                            createHitSpark({
                                x: obstacle.x + obstacle.width * 0.5,
                                y: obstacle.y + obstacle.height * 0.5,
                                color: { r: 159, g: 168, b: 218 }
                            });
                        }
                        break;
                    }

                    if (projectileRemoved) {
                        continue;
                    }

                    for (let j = asteroids.length - 1; j >= 0; j--) {
                        const asteroid = asteroids[j];
                        const radius = asteroid.radius * (config.asteroid?.collisionRadiusMultiplier ?? 1);
                        if (!circleRectOverlap({ x: asteroid.x, y: asteroid.y, radius }, projectile)) continue;

                        const damage = getProjectileDamage(projectile);
                        projectiles.splice(i, 1);
                        damageAsteroid(asteroid, damage, j);
                        projectileRemoved = true;
                        break;
                    }
                }
            }

            function rectOverlap(a, b) {
                return a.x < b.x + b.width &&
                    a.x + a.width > b.x &&
                    a.y < b.y + b.height &&
                    a.y + a.height > b.y;
            }

            function circleRectOverlap(circle, rect) {
                const closestX = clamp(circle.x, rect.x, rect.x + rect.width);
                const closestY = clamp(circle.y, rect.y, rect.y + rect.height);
                const distanceX = circle.x - closestX;
                const distanceY = circle.y - closestY;
                return (distanceX * distanceX + distanceY * distanceY) < (circle.radius * circle.radius);
            }

            function createHitSpark({ x, y, color }) {
                for (let i = 0; i < 8; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 180 + 80;
                    particles.push({
                        x,
                        y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 300 + Math.random() * 200,
                        color,
                        size: Math.random() * 2 + 0.8
                    });
                }
            }

            function createParticles({ x, y, color, count = 18, speedRange = [60, 340], sizeRange = [1.4, 4.4], lifeRange = [500, 900] }) {
                for (let i = 0; i < count; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = randomBetween(speedRange[0], speedRange[1]);
                    particles.push({
                        x,
                        y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: randomBetween(lifeRange[0], lifeRange[1]),
                        color,
                        size: randomBetween(sizeRange[0], sizeRange[1])
                    });
                }
            }

            function spawnFloatingText({
                text,
                x,
                y,
                color = '#facc15',
                life = 1200,
                variant = 'score',
                multiplier = 1
            }) {
                if (!text) return;
                const scale = 1 + Math.max(0, multiplier - 1) * 0.4;
                floatingTexts.push({
                    text,
                    x,
                    y,
                    color,
                    life,
                    maxLife: life,
                    vx: (Math.random() * 24 - 12) * 0.4,
                    vy: -60 - Math.random() * 30,
                    gravity: 38,
                    scale,
                    variant
                });
            }

            function updateFloatingTexts(delta) {
                const deltaSeconds = delta / 1000;
                for (let i = floatingTexts.length - 1; i >= 0; i--) {
                    const entry = floatingTexts[i];
                    entry.life -= delta;
                    if (entry.life <= 0) {
                        floatingTexts.splice(i, 1);
                        continue;
                    }
                    entry.x += entry.vx * deltaSeconds;
                    entry.y += entry.vy * deltaSeconds;
                    entry.vy += entry.gravity * deltaSeconds;
                }
            }

            function drawFloatingTexts() {
                if (!floatingTexts.length) return;
                ctx.save();
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                for (const entry of floatingTexts) {
                    const alpha = clamp(entry.life / entry.maxLife, 0, 1);
                    const fontSize = 16 + entry.scale * 6;
                    ctx.globalAlpha = alpha;
                    ctx.font = `700 ${fontSize}px ${primaryFontStack}`;
                    ctx.fillStyle = entry.color;
                    let shadowColor = 'rgba(244, 114, 182, 0.65)';
                    if (entry.variant === 'collect') {
                        shadowColor = 'rgba(56, 189, 248, 0.75)';
                    } else if (entry.variant === 'penalty') {
                        shadowColor = 'rgba(248, 113, 113, 0.75)';
                    } else if (entry.variant === 'dodge') {
                        shadowColor = 'rgba(250, 204, 21, 0.65)';
                    }
                    ctx.shadowColor = shadowColor;
                    ctx.shadowBlur = 18 * alpha;
                    ctx.fillText(entry.text, entry.x, entry.y);
                }
                ctx.restore();
            }

            function triggerScreenShake(strength = 6, duration = 220) {
                cameraShake.intensity = Math.max(cameraShake.intensity, strength);
                cameraShake.duration = Math.max(cameraShake.duration, duration);
                cameraShake.elapsed = 0;
            }

            function updateCameraShake(delta) {
                if (cameraShake.duration <= 0) {
                    cameraShake.offsetX = 0;
                    cameraShake.offsetY = 0;
                    return;
                }
                cameraShake.elapsed += delta;
                if (cameraShake.elapsed >= cameraShake.duration) {
                    cameraShake.intensity = 0;
                    cameraShake.duration = 0;
                    cameraShake.offsetX = 0;
                    cameraShake.offsetY = 0;
                    return;
                }
                const progress = cameraShake.elapsed / cameraShake.duration;
                const falloff = Math.pow(1 - progress, 2);
                const magnitude = cameraShake.intensity * falloff;
                cameraShake.offsetX = (Math.random() * 2 - 1) * magnitude;
                cameraShake.offsetY = (Math.random() * 2 - 1) * magnitude;
            }

            function createVillainExplosion(obstacle) {
                const centerX = obstacle.x + obstacle.width * 0.5;
                const centerY = obstacle.y + obstacle.height * 0.5;
                const palette = villainExplosionPalettes[obstacle.villainType?.key] ?? villainExplosionPalettes.villain1;
                const sizeFactor = obstacle.width;
                const villainKey = obstacle.villainType?.key;
                let explosion;

                switch (villainKey) {
                    case 'villain2': {
                        const orbitCount = 3 + Math.floor(sizeFactor / 36);
                        const orbits = Array.from({ length: orbitCount }, (_, index) => {
                            const depth = index / Math.max(1, orbitCount - 1);
                            const targetRadius = sizeFactor * (0.5 + depth * 0.65);
                            return {
                                radius: targetRadius * 0.45,
                                targetRadius,
                                growth: (260 + sizeFactor * 1.8) * (0.4 + depth * 0.8),
                                thickness: Math.max(3, sizeFactor * (0.035 + depth * 0.018)),
                                angle: Math.random() * Math.PI * 2,
                                rotationSpeed: randomBetween(-1.8, 1.8),
                                eccentricity: randomBetween(0.45, 0.7),
                                targetEccentricity: randomBetween(0.75, 1.05)
                            };
                        });
                        const sparks = Array.from({ length: 14 + Math.floor(sizeFactor / 12) }, () => ({
                            angle: Math.random() * Math.PI * 2,
                            distance: sizeFactor * randomBetween(0.28, 0.6),
                            speed: randomBetween(160, 260),
                            size: randomBetween(2, 5),
                            drift: randomBetween(-1.2, 1.2)
                        }));
                        explosion = {
                            type: 'ionBurst',
                            x: centerX,
                            y: centerY,
                            palette,
                            radius: sizeFactor * 0.34,
                            maxRadius: sizeFactor * 1.72,
                            expansionSpeed: 240 + sizeFactor * 1.6,
                            ringRadius: sizeFactor * 0.58,
                            maxRingRadius: sizeFactor * 2.8,
                            ringGrowth: 260 + sizeFactor * 1.8,
                            ringThickness: Math.max(4, sizeFactor * 0.08),
                            life: 640,
                            maxLife: 640,
                            orbits,
                            sparks,
                            swirl: { angle: Math.random() * Math.PI * 2, speed: randomBetween(1.1, 1.8) }
                        };
                        break;
                    }
                    case 'villain3': {
                        const shockwaves = [
                            {
                                radius: sizeFactor * 0.62,
                                maxRadius: sizeFactor * 3.3,
                                speed: 520 + sizeFactor * 2.4,
                                lineWidth: Math.max(9, sizeFactor * 0.14),
                                opacity: 0.55,
                                delay: 0
                            },
                            {
                                radius: sizeFactor * 0.34,
                                maxRadius: sizeFactor * 2.6,
                                speed: 420 + sizeFactor * 2.0,
                                lineWidth: Math.max(6, sizeFactor * 0.1),
                                opacity: 0.38,
                                delay: 140
                            }
                        ];
                        const fractures = Array.from({ length: 10 + Math.floor(sizeFactor / 12) }, () => ({
                            angle: Math.random() * Math.PI * 2,
                            length: sizeFactor * randomBetween(0.35, 0.8),
                            maxLength: sizeFactor * randomBetween(1.1, 1.8),
                            growth: randomBetween(160, 320),
                            width: Math.max(1.2, sizeFactor * 0.015)
                        }));
                        const embers = Array.from({ length: 18 + Math.floor(sizeFactor / 10) }, () => ({
                            radius: sizeFactor * randomBetween(0.6, 1.6),
                            growth: randomBetween(40, 120),
                            angle: Math.random() * Math.PI * 2,
                            rotationSpeed: randomBetween(-0.8, 0.8),
                            size: randomBetween(2.2, 5),
                            opacity: 0.65
                        }));
                        explosion = {
                            type: 'gravityRift',
                            x: centerX,
                            y: centerY,
                            palette,
                            radius: sizeFactor * 0.46,
                            maxRadius: sizeFactor * 1.52,
                            expansionSpeed: 300 + sizeFactor * 1.4,
                            life: 720,
                            maxLife: 720,
                            shockwaves,
                            fractures,
                            embers,
                            core: { radius: sizeFactor * 0.26, minRadius: sizeFactor * 0.08, collapseSpeed: 220 + sizeFactor * 0.9 }
                        };
                        break;
                    }
                    default: {
                        const spokes = Array.from({ length: 6 + Math.floor(sizeFactor / 16) }, () => ({
                            angle: Math.random() * Math.PI * 2,
                            length: sizeFactor * randomBetween(0.4, 0.7),
                            maxLength: sizeFactor * randomBetween(1, 1.6),
                            growth: randomBetween(180, 320),
                            width: Math.max(2, sizeFactor * 0.04)
                        }));
                        explosion = {
                            type: 'nova',
                            x: centerX,
                            y: centerY,
                            palette,
                            radius: sizeFactor * 0.45,
                            maxRadius: sizeFactor * 1.85,
                            expansionSpeed: 320 + sizeFactor * 2.1,
                            ringRadius: sizeFactor * 0.7,
                            maxRingRadius: sizeFactor * 2.4,
                            ringGrowth: 480 + sizeFactor * 2.6,
                            ringThickness: Math.max(4, sizeFactor * 0.12),
                            life: 520,
                            maxLife: 520,
                            spokes,
                            pulse: Math.random() * Math.PI * 2
                        };
                        break;
                    }
                }

                villainExplosions.push(explosion);
                audioManager.playExplosion(villainKey ?? 'generic');
                triggerScreenShake(Math.min(18, 8 + (sizeFactor ?? 0) * 0.05), 340);

                switch (explosion.type) {
                    case 'ionBurst': {
                        createParticles({
                            x: centerX,
                            y: centerY,
                            color: palette.core,
                            count: 34,
                            speedRange: [140, 360],
                            sizeRange: [1.2, 3.2],
                            lifeRange: [420, 700]
                        });
                        createParticles({
                            x: centerX,
                            y: centerY,
                            color: palette.spark,
                            count: 22,
                            speedRange: [200, 480],
                            sizeRange: [0.8, 2.2],
                            lifeRange: [320, 560]
                        });
                        break;
                    }
                    case 'gravityRift': {
                        createParticles({
                            x: centerX,
                            y: centerY,
                            color: palette.core,
                            count: 42,
                            speedRange: [180, 520],
                            sizeRange: [1.6, 4.8],
                            lifeRange: [520, 880]
                        });
                        createParticles({
                            x: centerX,
                            y: centerY,
                            color: palette.spark,
                            count: 28,
                            speedRange: [220, 620],
                            sizeRange: [1, 2.6],
                            lifeRange: [360, 640]
                        });
                        createHitSpark({ x: centerX, y: centerY, color: palette.halo });
                        break;
                    }
                    default: {
                        createParticles({
                            x: centerX,
                            y: centerY,
                            color: palette.core,
                            count: 28,
                            speedRange: [160, 420],
                            sizeRange: [1.1, 3.4],
                            lifeRange: [360, 620]
                        });

                        createParticles({
                            x: centerX,
                            y: centerY,
                            color: palette.spark,
                            count: 18,
                            speedRange: [220, 520],
                            sizeRange: [0.6, 1.6],
                            lifeRange: [260, 480]
                        });
                        break;
                    }
                }
            }

            function awardCollect(collectible) {
                const points = collectible?.points ?? config.score.collect;
                state.nyan += points;
                awardScore(points, {
                    x: collectible.x + collectible.width * 0.5,
                    y: collectible.y + collectible.height * 0.5,
                    type: 'collect',
                    color: '#7dd3fc'
                });
                triggerScreenShake(3, 160);
                audioManager.playCollect(collectible?.key ?? 'point');
            }

            function awardDestroy(obstacle) {
                const sizeBonus = Math.floor(obstacle.width * 0.6);
                const durabilityBonus = (obstacle.maxHealth ? obstacle.maxHealth - 1 : 0) * 90;
                awardScore(config.score.destroy + sizeBonus + durabilityBonus, {
                    x: obstacle.x + obstacle.width * 0.5,
                    y: obstacle.y + obstacle.height * 0.5,
                    type: 'villain',
                    color: '#f9a8d4'
                });
                triggerScreenShake(12, 300);
            }

            function awardDodge() {
                state.score += config.score.dodge;
                state.comboTimer = Math.max(0, state.comboTimer - 400);
                spawnFloatingText({
                    text: `+${config.score.dodge} Dodge`,
                    x: player.x + player.width,
                    y: player.y + player.height * 0.5,
                    color: '#fde68a',
                    life: 900,
                    variant: 'dodge'
                });
            }

            function getVillainEscapePenalty(obstacle) {
                const basePenalty = config.score?.villainEscape ?? 0;
                const durabilityPenalty = Math.max(0, (obstacle.maxHealth ?? 0) - 1) * 45;
                const sizePenalty = Math.round((obstacle.width ?? 0) * 0.35);
                return Math.max(0, basePenalty + durabilityPenalty + sizePenalty);
            }

            function handleVillainEscape(obstacle) {
                const penalty = getVillainEscapePenalty(obstacle);
                if (penalty > 0) {
                    state.score = Math.max(0, state.score - penalty);
                    spawnFloatingText({
                        text: `-${penalty} pts`,
                        x: player.x + player.width * 0.5,
                        y: player.y + player.height * 0.5,
                        color: '#f87171',
                        life: 1100,
                        variant: 'penalty'
                    });
                    triggerScreenShake(8, 240);
                }
                state.comboTimer = config.comboDecayWindow;
                resetStreak();
                createHitSpark({
                    x: player.x + player.width * 0.5,
                    y: player.y + player.height * 0.5,
                    color: { r: 255, g: 120, b: 120 }
                });
            }

            function awardScore(basePoints, source = {}) {
                state.comboTimer = 0;
                const previousBest = state.bestStreak;
                state.streak += 1;
                if (state.streak > state.bestStreak) {
                    state.bestStreak = state.streak;
                    if (state.bestStreak >= 4 && state.bestStreak > previousBest) {
                        addSocialMoment(`${playerName} pushed a x${state.bestStreak} streak!`, {
                            type: 'combo'
                        });
                    }
                }
                state.tailTarget = config.baseTrailLength + state.streak * config.trailGrowthPerStreak;
                const multiplier = 1 + state.streak * config.comboMultiplierStep;
                const finalPoints = Math.floor(basePoints * multiplier);
                state.score += finalPoints;
                const originX = source.x ?? player.x + player.width * 0.5;
                const originY = source.y ?? player.y;
                const text = `+${finalPoints.toLocaleString()}${multiplier > 1.01 ? ` x${multiplier.toFixed(2)}` : ''}`;
                spawnFloatingText({
                    text,
                    x: originX,
                    y: originY,
                    color: source.color ?? '#fbbf24',
                    variant: source.type ?? 'score',
                    multiplier
                });
                if (finalPoints >= 600) {
                    triggerScreenShake(Math.min(16, 6 + finalPoints / 400), 280);
                }
            }

            function resetStreak() {
                state.streak = 0;
                state.tailTarget = config.baseTrailLength;
            }

            function triggerGameOver(message) {
                if (state.gameState !== 'running') return;
                state.gameState = 'gameover';
                audioManager.stopGameplayMusic();
                audioManager.stopHyperBeam();
                const finalTimeMs = state.elapsedTime;
                const runTimestamp = Date.now();
                const placement = recordHighScore(finalTimeMs, state.score, {
                    bestStreak: state.bestStreak,
                    nyan: state.nyan,
                    recordedAt: runTimestamp
                });
                updateHighScorePanel();
                updateTimerDisplay();
                const formattedTime = formatTime(finalTimeMs);
                lastRunSummary = {
                    player: playerName,
                    timeMs: finalTimeMs,
                    score: state.score,
                    nyan: state.nyan,
                    bestStreak: state.bestStreak,
                    placement,
                    recordedAt: runTimestamp
                };
                updateSharePanel();
                const placementLine = placement ? `\nGalaxy Standings: #${placement}` : '';
                if (placement && placement <= 7) {
                    addSocialMoment(`${playerName} entered the galaxy standings at #${placement}!`, {
                        type: 'leaderboard',
                        timestamp: runTimestamp
                    });
                } else {
                    addSocialMoment(`${playerName} survived ${formattedTime} for ${state.score.toLocaleString()} pts.`, {
                        type: 'run',
                        timestamp: runTimestamp
                    });
                }
                showOverlay(
                    `${message}\nFlight Time: ${formattedTime}\nFinal Score: ${state.score} — Points collected: ${state.nyan.toLocaleString()}${placementLine}`,
                    'Run It Back',
                    { title: '' }
                );
            }

            function updateCombo(delta) {
                state.comboTimer += delta;
                if (state.comboTimer >= config.comboDecayWindow && state.streak > 0) {
                    resetStreak();
                }
                const ratio = clamp(1 - state.comboTimer / config.comboDecayWindow, 0, 1);
                const percentage = Math.round(ratio * 100);
                if (percentage !== lastComboPercent) {
                    comboFillEl.style.width = `${percentage}%`;
                    if (comboMeterEl) {
                        comboMeterEl.setAttribute('aria-valuenow', String(percentage));
                    }
                    lastComboPercent = percentage;
                }
                if (comboMeterEl) {
                    const charged = state.streak >= 5 && ratio > 0.4;
                    comboMeterEl.classList.toggle('charged', charged);
                }
            }

            function updateHUD() {
                const formattedScore = state.score.toLocaleString();
                if (formattedScore !== hudCache.score) {
                    hudCache.score = formattedScore;
                    scoreEl.textContent = formattedScore;
                }

                const formattedNyan = state.nyan.toLocaleString();
                if (formattedNyan !== hudCache.nyan) {
                    hudCache.nyan = formattedNyan;
                    nyanEl.textContent = formattedNyan;
                }

                const comboMultiplierText = `x${(1 + state.streak * config.comboMultiplierStep).toFixed(2)}`;
                if (comboMultiplierText !== hudCache.comboMultiplier) {
                    hudCache.comboMultiplier = comboMultiplierText;
                    streakEl.textContent = comboMultiplierText;
                }

                const bestTailLengthText = `${Math.round(
                    config.baseTrailLength + state.bestStreak * config.trailGrowthPerStreak
                )}`;
                if (bestTailLengthText !== hudCache.bestTailLength) {
                    hudCache.bestTailLength = bestTailLengthText;
                    bestStreakEl.textContent = bestTailLengthText;
                }

                const marketCapText = `${(6.6 + state.score / 1400).toFixed(1)}K`;
                if (marketCapText !== hudCache.marketCap) {
                    hudCache.marketCap = marketCapText;
                    mcapEl.textContent = marketCapText;
                }

                const normalizedCollects = state.nyan / baseCollectScore;
                const volumeText = `${(2.8 + normalizedCollects * 0.6 + state.streak * 0.3).toFixed(1)}K`;
                if (volumeText !== hudCache.volume) {
                    hudCache.volume = volumeText;
                    volEl.textContent = volumeText;
                }

                const activeBoosts = powerUpTypes
                    .filter((type) => isPowerUpActive(type))
                    .map((type) => `${powerUpLabels[type]} ${(state.powerUpTimers[type] / 1000).toFixed(1)}s`);
                const powerUpText = activeBoosts.length ? activeBoosts.join(' | ') : 'None';
                if (powerUpText !== hudCache.powerUps) {
                    hudCache.powerUps = powerUpText;
                    powerUpsEl.textContent = powerUpText;
                }
            }

            function drawBackground() {
                ctx.fillStyle = '#05091f';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, 'rgba(26, 35, 126, 0.85)');
                gradient.addColorStop(0.5, 'rgba(21, 11, 45, 0.85)');
                gradient.addColorStop(1, 'rgba(0, 2, 12, 0.95)');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            function drawStars(time) {
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                for (const star of stars) {
                    const twinkle = (Math.sin(time * 0.002 + star.twinkleOffset) + 1) * 0.5;
                    ctx.fillStyle = `rgba(255, 255, 255, ${0.3 + twinkle * 0.7})`;
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
            }

            function drawTrail() {
                if (trail.length < 2) return;
                for (let i = 0; i < trail.length; i++) {
                    const t = trail[i];
                    const alpha = i / trail.length;
                    const hue = (alpha * 300 + performance.now() * 0.05) % 360;
                    ctx.fillStyle = `hsla(${hue}, 100%, 60%, ${alpha})`;
                    ctx.fillRect(t.x - 36, t.y - 6, 72, 12);
                }
            }

            function drawShieldAura(drawX, drawY, time = performance.now()) {
                if (!isShieldActive()) return;
                const shieldConfig = config.defensePower ?? {};
                const auraColor = shieldConfig.auraColor ?? { r: 150, g: 214, b: 255 };
                const duration = config.powerUp.duration[SHIELD_POWER] ?? 1;
                const remaining = clamp(state.powerUpTimers[SHIELD_POWER] / duration, 0, 1);
                const pulseStrength = Math.sin(time * 0.007) * (shieldConfig.auraPulse ?? 0.18);
                const hitPulse = state.shieldHitPulse ?? 0;
                const baseRadius = Math.max(player.width, player.height) * (0.65 + pulseStrength + hitPulse * 0.18);
                const centerX = drawX + player.width * 0.5;
                const centerY = drawY + player.height * 0.5;

                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.globalCompositeOperation = 'lighter';

                const gradient = ctx.createRadialGradient(0, 0, baseRadius * 0.35, 0, 0, baseRadius);
                gradient.addColorStop(0, `rgba(${auraColor.r}, ${auraColor.g}, ${auraColor.b}, ${0.55 + hitPulse * 0.25})`);
                gradient.addColorStop(0.58, `rgba(${auraColor.r}, ${auraColor.g}, ${auraColor.b}, ${0.28 + remaining * 0.35})`);
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(0, 0, baseRadius, 0, Math.PI * 2);
                ctx.fill();

                const ringRadius = baseRadius * (0.88 + 0.06 * Math.sin(time * 0.012 + hitPulse));
                ctx.strokeStyle = `rgba(${auraColor.r}, ${auraColor.g}, ${auraColor.b}, ${0.35 + remaining * 0.4})`;
                ctx.lineWidth = 4.2 + hitPulse * 2.6;
                ctx.beginPath();
                ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
                ctx.stroke();

                const sparkCount = 7;
                for (let i = 0; i < sparkCount; i++) {
                    const angle = time * 0.0035 + i * (Math.PI * 2 / sparkCount);
                    const sparkRadius = ringRadius * (0.92 + 0.08 * Math.sin(time * 0.01 + i));
                    const px = Math.cos(angle) * sparkRadius;
                    const py = Math.sin(angle) * sparkRadius;
                    const sparkAlpha = 0.55 + 0.35 * Math.sin(time * 0.02 + i * 1.3 + hitPulse * 0.6);
                    ctx.save();
                    ctx.translate(px, py);
                    ctx.rotate(angle);
                    ctx.fillStyle = `rgba(${auraColor.r}, ${auraColor.g}, ${auraColor.b}, ${sparkAlpha})`;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, 7 + hitPulse * 3, 2.4 + hitPulse * 1.2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }

                ctx.restore();
            }

            function drawPlayer() {
                const now = performance.now();
                const bob = Math.sin(now * 0.005) * 4;
                const drawX = player.x;
                const drawY = player.y + bob;
                drawShieldAura(drawX, drawY, now);
                if (playerImage.complete && playerImage.naturalWidth !== 0) {
                    ctx.drawImage(playerImage, drawX, drawY, player.width, player.height);
                } else {
                    const gradient = ctx.createLinearGradient(drawX, drawY, drawX + player.width, drawY + player.height);
                    gradient.addColorStop(0, '#ff9a9e');
                    gradient.addColorStop(0.5, '#fad0c4');
                    gradient.addColorStop(1, '#fad0c4');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(drawX, drawY, player.width, player.height);
                }

                if (isShieldActive()) {
                    drawShieldAura(drawX, drawY, now + 40);
                }
            }

            function drawObstacles() {
                for (const obstacle of obstacles) {
                    ctx.save();
                    ctx.translate(obstacle.x + obstacle.width / 2, obstacle.y + obstacle.height / 2);
                    ctx.rotate(obstacle.rotation);

                    if (obstacle.image && obstacle.image.complete && obstacle.image.naturalWidth > 0) {
                        ctx.drawImage(
                            obstacle.image,
                            -obstacle.width / 2,
                            -obstacle.height / 2,
                            obstacle.width,
                            obstacle.height
                        );
                    } else {
                        const radius = obstacle.width / 2;
                        ctx.beginPath();
                        ctx.moveTo(radius, 0);
                        for (let i = 1; i < 6; i++) {
                            const angle = i * (Math.PI * 2 / 6);
                            ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
                        }
                        ctx.closePath();
                        ctx.fillStyle = '#4f46e5';
                        ctx.fill();
                        ctx.strokeStyle = 'rgba(255,255,255,0.25)';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }

                    if (obstacle.hitFlash > 0) {
                        const flashAlpha = clamp(obstacle.hitFlash / 160, 0, 1);
                        ctx.fillStyle = `rgba(255, 255, 255, ${0.35 * flashAlpha})`;
                        ctx.fillRect(-obstacle.width / 2, -obstacle.height / 2, obstacle.width, obstacle.height);
                    }

                    ctx.restore();

                    if (obstacle.maxHealth > 1) {
                        const ratio = clamp(obstacle.health / obstacle.maxHealth, 0, 1);
                        const barWidth = obstacle.width;
                        const barHeight = 6;
                        const barX = obstacle.x;
                        const barY = obstacle.y - 10;
                        ctx.fillStyle = 'rgba(79,70,229,0.35)';
                        ctx.fillRect(barX, barY, barWidth, barHeight);
                        ctx.fillStyle = '#a5b4fc';
                        ctx.fillRect(barX, barY, barWidth * ratio, barHeight);
                    }
                }
            }

            function drawCollectibles(time) {
                for (const collectible of collectibles) {
                    ctx.save();
                    ctx.translate(collectible.x + collectible.width / 2, collectible.y + collectible.height / 2);
                    ctx.rotate(Math.sin(time * 0.004 + collectible.wobbleTime) * 0.2);
                    const pulse = Math.sin(time * 0.004 + collectible.wobbleTime);
                    const sprite = collectible.sprite;
                    const spriteReady = sprite?.complete && sprite.naturalWidth > 0;
                    const glowColors = collectible.glow ?? {};
                    const innerGlow = glowColors.inner ?? 'rgba(255, 255, 255, 0.9)';
                    const outerGlow = glowColors.outer ?? 'rgba(255, 215, 0, 0.2)';

                    const glowRadius = collectible.width * (0.62 + 0.08 * pulse);
                    const gradient = ctx.createRadialGradient(0, 0, glowRadius * 0.35, 0, 0, glowRadius);
                    gradient.addColorStop(0, innerGlow);
                    gradient.addColorStop(1, outerGlow);
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, glowRadius, 0, Math.PI * 2);
                    ctx.fill();

                    if (spriteReady) {
                        const drawSize = collectible.width * (0.9 + 0.1 * pulse);
                        ctx.drawImage(sprite, -drawSize / 2, -drawSize / 2, drawSize, drawSize);
                    } else {
                        const fallbackRadius = collectible.width * 0.48;
                        const fallbackGradient = ctx.createRadialGradient(0, 0, 4, 0, 0, fallbackRadius);
                        fallbackGradient.addColorStop(0, innerGlow);
                        fallbackGradient.addColorStop(1, outerGlow);
                        ctx.fillStyle = fallbackGradient;
                        ctx.beginPath();
                        ctx.arc(0, 0, fallbackRadius, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#0f172a';
                        ctx.font = `700 10px ${primaryFontStack}`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(collectible.label ?? 'POINTS', 0, 0);
                    }
                    ctx.restore();
                }
            }

            function drawPowerUps(time) {
                for (const powerUp of powerUps) {
                    ctx.save();
                    ctx.translate(powerUp.x + powerUp.width / 2, powerUp.y + powerUp.height / 2);
                    const pulse = 0.15 * Math.sin(time * 0.006 + powerUp.wobbleTime);
                    const radius = powerUp.width * (0.36 + pulse);
                    const color = powerUpColors[powerUp.type] ?? { r: 220, g: 220, b: 255 };
                    const gradient = ctx.createRadialGradient(0, 0, radius * 0.25, 0, 0, radius);
                    gradient.addColorStop(0, `rgba(${color.r}, ${color.g}, ${color.b}, 0.95)`);
                    gradient.addColorStop(0.65, `rgba(${color.r}, ${color.g}, ${color.b}, 0.6)`);
                    gradient.addColorStop(1, 'rgba(255,255,255,0.1)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, radius, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = 'rgba(255,255,255,0.4)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, radius * 0.7, 0, Math.PI * 2);
                    ctx.stroke();

                    const sprite = powerUpImages[powerUp.type];
                    const isSpriteReady = sprite?.complete && sprite.naturalWidth !== 0;
                    if (isSpriteReady) {
                        const drawSize = powerUp.width;
                        ctx.drawImage(sprite, -drawSize / 2, -drawSize / 2, drawSize, drawSize);
                    } else {
                        ctx.fillStyle = '#060b28';
                        ctx.font = `700 12px ${primaryFontStack}`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        const label = powerUpLabels[powerUp.type] ?? 'BOOST';
                        ctx.fillText(label.split(' ')[0], 0, -6);
                        if (label.includes(' ')) {
                            ctx.fillText(label.split(' ')[1], 0, 8);
                        }
                    }
                    ctx.restore();
                }
            }

            function drawAreaBursts() {
                if (!areaBursts.length) return;
                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                for (const burst of areaBursts) {
                    const opacity = clamp(burst.life / 650, 0, 1);
                    const gradient = ctx.createRadialGradient(burst.x, burst.y, burst.radius * 0.4, burst.x, burst.y, burst.radius);
                    gradient.addColorStop(0, `rgba(255, 185, 130, ${0.35 * opacity})`);
                    gradient.addColorStop(1, 'rgba(255, 120, 80, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(burst.x, burst.y, burst.radius, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = `rgba(255, 200, 150, ${0.5 * opacity})`;
                    ctx.lineWidth = 6;
                    ctx.beginPath();
                    ctx.arc(burst.x, burst.y, burst.radius * 0.85, 0, Math.PI * 2);
                    ctx.stroke();
                }
                ctx.restore();
            }

            function drawVillainExplosions() {
                if (!villainExplosions.length) return;
                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                for (const explosion of villainExplosions) {
                    const palette = explosion.palette ?? villainExplosionPalettes.villain1;
                    const alpha = clamp(explosion.life / explosion.maxLife, 0, 1);

                    switch (explosion.type) {
                        case 'ionBurst': {
                            const gradient = ctx.createRadialGradient(
                                explosion.x,
                                explosion.y,
                                Math.max(6, explosion.radius * 0.2),
                                explosion.x,
                                explosion.y,
                                Math.max(explosion.radius, 1)
                            );
                            gradient.addColorStop(
                                0,
                                `rgba(${palette.core.r}, ${palette.core.g}, ${palette.core.b}, ${0.65 * alpha})`
                            );
                            gradient.addColorStop(
                                0.6,
                                `rgba(${palette.halo.r}, ${palette.halo.g}, ${palette.halo.b}, ${0.4 * alpha})`
                            );
                            gradient.addColorStop(1, `rgba(${palette.halo.r}, ${palette.halo.g}, ${palette.halo.b}, 0)`);
                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(explosion.x, explosion.y, explosion.radius, 0, Math.PI * 2);
                            ctx.fill();

                            if (explosion.orbits) {
                                for (const orbit of explosion.orbits) {
                                    const orbitAlpha = alpha * 0.35;
                                    ctx.save();
                                    ctx.translate(explosion.x, explosion.y);
                                    ctx.rotate(orbit.angle);
                                    ctx.strokeStyle = `rgba(${palette.halo.r}, ${palette.halo.g}, ${palette.halo.b}, ${orbitAlpha})`;
                                    ctx.lineWidth = orbit.thickness;
                                    ctx.beginPath();
                                    ctx.ellipse(0, 0, orbit.radius, orbit.radius * orbit.eccentricity, 0, 0, Math.PI * 2);
                                    ctx.stroke();
                                    ctx.restore();
                                }
                            }

                            if (typeof explosion.ringRadius === 'number') {
                                ctx.strokeStyle = `rgba(${palette.core.r}, ${palette.core.g}, ${palette.core.b}, ${0.25 * alpha})`;
                                ctx.lineWidth = explosion.ringThickness ?? 6;
                                ctx.beginPath();
                                ctx.arc(explosion.x, explosion.y, explosion.ringRadius, 0, Math.PI * 2);
                                ctx.stroke();
                            }

                            if (explosion.swirl) {
                                const swirlSegments = 18;
                                ctx.strokeStyle = `rgba(${palette.core.r}, ${palette.core.g}, ${palette.core.b}, ${0.4 * alpha})`;
                                ctx.lineWidth = Math.max(2, (explosion.ringThickness ?? 6) * 0.4);
                                ctx.beginPath();
                                for (let i = 0; i < swirlSegments; i++) {
                                    const t = i / (swirlSegments - 1);
                                    const angle = explosion.swirl.angle + t * Math.PI * 2;
                                    const radius = explosion.radius * (0.2 + t * 0.8);
                                    const px = explosion.x + Math.cos(angle) * radius;
                                    const py = explosion.y + Math.sin(angle) * radius * 0.6;
                                    if (i === 0) {
                                        ctx.moveTo(px, py);
                                    } else {
                                        ctx.lineTo(px, py);
                                    }
                                }
                                ctx.stroke();
                            }

                            if (explosion.sparks) {
                                for (const spark of explosion.sparks) {
                                    const px = explosion.x + Math.cos(spark.angle) * spark.distance;
                                    const py = explosion.y + Math.sin(spark.angle) * spark.distance * 0.9;
                                    const sparkAlpha = alpha * 0.65;
                                    ctx.fillStyle = `rgba(${palette.spark.r}, ${palette.spark.g}, ${palette.spark.b}, ${sparkAlpha})`;
                                    ctx.beginPath();
                                    ctx.arc(px, py, spark.size, 0, Math.PI * 2);
                                    ctx.fill();
                                }
                            }
                            break;
                        }
                        case 'gravityRift': {
                            const gradient = ctx.createRadialGradient(
                                explosion.x,
                                explosion.y,
                                Math.max(4, explosion.radius * 0.12),
                                explosion.x,
                                explosion.y,
                                Math.max(explosion.radius, 1)
                            );
                            gradient.addColorStop(
                                0,
                                `rgba(${palette.core.r}, ${palette.core.g}, ${palette.core.b}, ${0.7 * alpha})`
                            );
                            gradient.addColorStop(
                                0.5,
                                `rgba(${palette.halo.r}, ${palette.halo.g}, ${palette.halo.b}, ${0.45 * alpha})`
                            );
                            gradient.addColorStop(1, `rgba(${palette.halo.r}, ${palette.halo.g}, ${palette.halo.b}, 0)`);
                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(explosion.x, explosion.y, explosion.radius, 0, Math.PI * 2);
                            ctx.fill();

                            if (explosion.shockwaves) {
                                for (const shock of explosion.shockwaves) {
                                    if (shock.delay > 0) continue;
                                    const shockAlpha = alpha * shock.opacity;
                                    ctx.strokeStyle = `rgba(${palette.halo.r}, ${palette.halo.g}, ${palette.halo.b}, ${shockAlpha})`;
                                    ctx.lineWidth = shock.lineWidth;
                                    ctx.beginPath();
                                    ctx.arc(explosion.x, explosion.y, shock.radius, 0, Math.PI * 2);
                                    ctx.stroke();
                                }
                            }

                            if (explosion.fractures) {
                                ctx.lineCap = 'round';
                                for (const fracture of explosion.fractures) {
                                    const fx = explosion.x + Math.cos(fracture.angle) * fracture.length;
                                    const fy = explosion.y + Math.sin(fracture.angle) * fracture.length;
                                    ctx.strokeStyle = `rgba(${palette.spark.r}, ${palette.spark.g}, ${palette.spark.b}, ${0.35 * alpha})`;
                                    ctx.lineWidth = fracture.width;
                                    ctx.beginPath();
                                    ctx.moveTo(explosion.x, explosion.y);
                                    ctx.lineTo(fx, fy);
                                    ctx.stroke();
                                }
                            }

                            if (explosion.embers) {
                                for (const ember of explosion.embers) {
                                    if (ember.opacity <= 0) continue;
                                    const ex = explosion.x + Math.cos(ember.angle) * ember.radius;
                                    const ey = explosion.y + Math.sin(ember.angle) * ember.radius * 0.85;
                                    const emberAlpha = alpha * ember.opacity;
                                    ctx.fillStyle = `rgba(${palette.spark.r}, ${palette.spark.g}, ${palette.spark.b}, ${emberAlpha})`;
                                    ctx.beginPath();
                                    ctx.arc(ex, ey, ember.size, 0, Math.PI * 2);
                                    ctx.fill();
                                }
                            }

                            if (explosion.core) {
                                ctx.save();
                                ctx.globalCompositeOperation = 'source-over';
                                ctx.fillStyle = 'rgba(6, 8, 20, 0.85)';
                                ctx.beginPath();
                                ctx.arc(explosion.x, explosion.y, explosion.core.radius, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.restore();
                            }
                            break;
                        }
                        default: {
                            const gradient = ctx.createRadialGradient(
                                explosion.x,
                                explosion.y,
                                Math.max(6, explosion.radius * 0.2),
                                explosion.x,
                                explosion.y,
                                Math.max(explosion.radius, 1)
                            );
                            gradient.addColorStop(
                                0,
                                `rgba(${palette.core.r}, ${palette.core.g}, ${palette.core.b}, ${0.55 * alpha})`
                            );
                            gradient.addColorStop(1, `rgba(${palette.halo.r}, ${palette.halo.g}, ${palette.halo.b}, 0)`);
                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(explosion.x, explosion.y, explosion.radius, 0, Math.PI * 2);
                            ctx.fill();

                            if (typeof explosion.ringRadius === 'number') {
                                const pulse = Math.sin(explosion.pulse ?? 0) * 0.5 + 0.5;
                                ctx.strokeStyle = `rgba(${palette.core.r}, ${palette.core.g}, ${palette.core.b}, ${0.35 * alpha * pulse})`;
                                ctx.lineWidth = explosion.ringThickness;
                                ctx.beginPath();
                                ctx.arc(explosion.x, explosion.y, explosion.ringRadius, 0, Math.PI * 2);
                                ctx.stroke();
                            }

                            if (explosion.spokes) {
                                ctx.lineCap = 'round';
                                for (const spoke of explosion.spokes) {
                                    const sx = explosion.x + Math.cos(spoke.angle) * spoke.length;
                                    const sy = explosion.y + Math.sin(spoke.angle) * spoke.length;
                                    ctx.strokeStyle = `rgba(${palette.spark.r}, ${palette.spark.g}, ${palette.spark.b}, ${0.6 * alpha})`;
                                    ctx.lineWidth = spoke.width;
                                    ctx.beginPath();
                                    ctx.moveTo(explosion.x, explosion.y);
                                    ctx.lineTo(sx, sy);
                                    ctx.stroke();
                                }
                            }
                            break;
                        }
                    }
                }
                ctx.restore();
            }

            function drawHyperBeam(time) {
                const bounds = hyperBeamState.bounds;
                const intensity = hyperBeamState.intensity;
                if (!bounds || intensity <= 0) {
                    return;
                }

                const hyperConfig = config.hyperBeam ?? {};
                const color = powerUpColors[HYPER_BEAM_POWER] ?? { r: 147, g: 197, b: 253 };
                const verticalJitter = Math.sin(time * 0.008 + hyperBeamState.wave) * (hyperConfig.jitterAmplitude ?? 18) * intensity;
                const top = clamp(bounds.y + verticalJitter * -0.5, 0, Math.max(0, canvas.height - bounds.height));
                const height = Math.min(bounds.height, canvas.height - top);
                if (height <= 0) {
                    return;
                }
                const midY = clamp(top + height / 2 + verticalJitter * 0.3, top, top + height);

                ctx.save();
                ctx.globalCompositeOperation = 'lighter';

                const outerGradient = ctx.createLinearGradient(bounds.x, top, bounds.x + bounds.width, top);
                const outerAlpha = Math.min(1, 0.32 + intensity * 0.28);
                const midAlpha = Math.min(1, 0.5 + intensity * 0.3);
                outerGradient.addColorStop(0, `rgba(${color.r}, ${color.g}, ${color.b}, ${outerAlpha})`);
                outerGradient.addColorStop(0.45, `rgba(${color.r}, ${color.g}, ${color.b}, ${midAlpha})`);
                outerGradient.addColorStop(1, 'rgba(17, 24, 39, 0)');
                ctx.fillStyle = outerGradient;
                ctx.fillRect(bounds.x, top, bounds.width, height);

                const coreHeight = Math.max(18, height * 0.36);
                const coreTop = clamp(midY - coreHeight / 2, top, top + height - coreHeight);
                const coreGradient = ctx.createLinearGradient(bounds.x, coreTop, bounds.x + bounds.width * 0.9, coreTop);
                coreGradient.addColorStop(0, `rgba(236, 254, 255, ${Math.min(1, 0.85 * intensity)})`);
                coreGradient.addColorStop(1, 'rgba(148, 210, 255, 0)');
                ctx.fillStyle = coreGradient;
                ctx.fillRect(bounds.x, coreTop, bounds.width * 0.9, coreHeight);

                ctx.strokeStyle = `rgba(236, 254, 255, ${Math.min(1, 0.55 * intensity)})`;
                ctx.lineWidth = Math.max(2, height * 0.12 * intensity);
                ctx.beginPath();
                ctx.moveTo(bounds.x, midY + Math.sin(time * 0.014 + hyperBeamState.wave) * height * 0.08);
                ctx.lineTo(bounds.x + bounds.width, midY + Math.sin(time * 0.017 + hyperBeamState.wave) * height * 0.05);
                ctx.stroke();

                ctx.restore();
            }

            function drawProjectiles() {
                for (const projectile of projectiles) {
                    if (projectile.type === 'missile') {
                        ctx.save();
                        ctx.translate(projectile.x + projectile.width * 0.5, projectile.y + projectile.height * 0.5);
                        const angle = Math.atan2(projectile.vy, projectile.vx);
                        ctx.rotate(angle);
                        ctx.fillStyle = '#ffb74d';
                        ctx.fillRect(-projectile.width * 0.5, -projectile.height * 0.35, projectile.width, projectile.height * 0.7);
                        ctx.fillStyle = '#ff7043';
                        ctx.beginPath();
                        ctx.moveTo(-projectile.width * 0.6, -projectile.height * 0.5);
                        ctx.lineTo(-projectile.width * 0.2, 0);
                        ctx.lineTo(-projectile.width * 0.6, projectile.height * 0.5);
                        ctx.closePath();
                        ctx.fill();
                        ctx.fillStyle = '#263238';
                        ctx.fillRect(projectile.width * 0.1, -projectile.height * 0.2, projectile.width * 0.5, projectile.height * 0.4);
                        ctx.restore();
                    } else {
                        const gradient = ctx.createLinearGradient(projectile.x, projectile.y, projectile.x + projectile.width, projectile.y + projectile.height);
                        if (projectile.type === 'spread') {
                            gradient.addColorStop(0, '#b39ddb');
                            gradient.addColorStop(1, '#7e57c2');
                        } else {
                            gradient.addColorStop(0, '#00e5ff');
                            gradient.addColorStop(1, '#6a5acd');
                        }
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.moveTo(projectile.x, projectile.y);
                        ctx.lineTo(projectile.x + projectile.width, projectile.y + projectile.height * 0.5);
                        ctx.lineTo(projectile.x, projectile.y + projectile.height);
                        ctx.closePath();
                        ctx.fill();
                    }
                }
            }

            function drawParticles() {
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                for (const particle of particles) {
                    const alpha = clamp(particle.life / 500, 0, 1);
                    ctx.fillStyle = `rgba(${particle.color.r}, ${particle.color.g}, ${particle.color.b}, ${alpha.toFixed(2)})`;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
            }

            function stepNonRunning(delta) {
                updateCameraShake(delta);
                updateStars(delta);
                updateAsteroids(delta);
                updateParticles(delta);
                updateFloatingTexts(delta);
                updateAreaBursts(delta);
                updateVillainExplosions(delta);
                updateShieldEffects(delta);
                updateHyperBeam(delta);
            }

            function stepRunning(delta) {
                state.elapsedTime += delta;
                state.gameSpeed += config.speedGrowth * getSpeedRampMultiplier() * (delta / 1000);

                updateCameraShake(delta);
                updatePlayer(delta);
                updateProjectiles(delta);
                updateObstacles(delta);
                updateCollectibles(delta);
                updatePowerUps(delta);
                updateHyperBeam(delta);
                updateProjectilesCollisions();
                updateStars(delta);
                updateAsteroids(delta);
                updateParticles(delta);
                updateFloatingTexts(delta);
                updateSpawns(delta);
                updatePowerUpTimers(delta);
                updatePowerBomb(delta);
                updateShieldEffects(delta);
                updateAreaBursts(delta);
                updateVillainExplosions(delta);
                updateCombo(delta);
            }

            function renderFrame(timestamp) {
                drawBackground();
                ctx.save();
                ctx.translate(cameraShake.offsetX ?? 0, cameraShake.offsetY ?? 0);
                drawStars(timestamp);
                drawAsteroids(timestamp);
                drawTrail();
                drawCollectibles(timestamp);
                drawPowerUps(timestamp);
                drawAreaBursts();
                drawVillainExplosions();
                drawObstacles();
                drawHyperBeam(timestamp);
                drawProjectiles();
                drawParticles();
                drawPlayer();
                drawFloatingTexts();
                ctx.restore();
            }

            let lastTime = null;
            let accumulatedDelta = 0;
            const FIXED_TIMESTEP = 16;
            const MAX_ACCUMULATED_TIME = FIXED_TIMESTEP * 6;

            function gameLoop(timestamp = performance.now()) {
                requestAnimationFrame(gameLoop);

                if (state.gameState === 'ready') {
                    stepNonRunning(FIXED_TIMESTEP);
                    renderFrame(timestamp);
                    updateHUD();
                    updateTimerDisplay();
                    lastTime = timestamp;
                    accumulatedDelta = 0;
                    return;
                }

                if (lastTime === null) {
                    lastTime = timestamp;
                }

                let delta = timestamp - lastTime;
                lastTime = timestamp;

                if (delta > 200) {
                    delta = 200;
                } else if (delta < 0) {
                    delta = 0;
                }

                accumulatedDelta = Math.min(accumulatedDelta + delta, MAX_ACCUMULATED_TIME);

                while (accumulatedDelta >= FIXED_TIMESTEP) {
                    if (state.gameState === 'running') {
                        stepRunning(FIXED_TIMESTEP);
                    } else {
                        stepNonRunning(FIXED_TIMESTEP);
                    }
                    accumulatedDelta -= FIXED_TIMESTEP;
                }

                renderFrame(timestamp);
                updateHUD();
                updateTimerDisplay();
            }

            runCyborgLoadingSequence();
            createInitialStars();
            scheduleNextMeteorShower();
            requestAnimationFrame(gameLoop);
        });
    </script>
</body>
</html>
