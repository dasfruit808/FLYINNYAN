<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nyan Escape</title>
    <style>
        :root {
            color-scheme: dark;
            --primary-font-stack: "Flight Time", "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        }

        @font-face {
            font-family: "Flight Time";
            src: url("assets/FlightTime.ttf") format("truetype");
            font-display: swap;
        }

        * {
            box-sizing: border-box;
        }

        img,
        canvas {
            user-select: none;
            -webkit-user-drag: none;
        }

        body {
            margin: 0;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            min-height: 100vh;
            padding: clamp(24px, 5vw, 48px);
            font-family: var(--primary-font-stack);
            color: #fff;
            overflow: auto;
            position: relative;
        }

        body.settings-open {
            overflow: hidden;
        }

        .touch-only {
            display: none;
        }

        body.touch-enabled .desktop-only {
            display: none;
        }

        body.touch-enabled .touch-only {
            display: inline;
        }

        button:focus-visible,
        input[type='range']:focus-visible,
        input[type='checkbox']:focus-visible {
            outline: 2px solid rgba(148, 210, 255, 0.85);
            outline-offset: 3px;
        }

        #settingsButton {
            position: fixed;
            top: clamp(18px, 4vw, 28px);
            right: clamp(18px, 4vw, 28px);
            z-index: 30;
            border: none;
            border-radius: 999px;
            background: linear-gradient(135deg, rgba(56, 189, 248, 0.86), rgba(99, 102, 241, 0.86));
            color: #e0f2fe;
            padding: 10px 16px;
            font-size: 0.78rem;
            font-weight: 600;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            cursor: pointer;
            box-shadow: 0 18px 32px rgba(15, 118, 110, 0.35);
            display: inline-flex;
            align-items: center;
            gap: 8px;
            transition: transform 140ms ease, box-shadow 140ms ease, background 160ms ease;
        }

        #settingsButton:hover {
            transform: translateY(-1px);
            box-shadow: 0 22px 36px rgba(15, 118, 110, 0.4);
        }

        #settingsButton .icon {
            font-size: 1rem;
        }

        body.touch-enabled #settingsButton {
            padding: 12px 18px;
            font-size: 0.82rem;
        }

        #settingsDrawer[hidden] {
            display: none;
        }

        #settingsDrawer {
            position: fixed;
            inset: 0;
            z-index: 60;
            display: grid;
            place-items: center;
        }

        #settingsDrawer .settings-backdrop {
            position: absolute;
            inset: 0;
            background: rgba(15, 23, 42, 0.78);
            backdrop-filter: blur(6px);
            -webkit-backdrop-filter: blur(6px);
        }

        #settingsDrawer .settings-content {
            position: relative;
            width: min(480px, 92vw);
            background: linear-gradient(165deg, rgba(15, 23, 42, 0.96), rgba(8, 16, 32, 0.92));
            border-radius: 20px;
            padding: clamp(22px, 5vw, 32px);
            box-shadow: 0 28px 60px rgba(2, 6, 23, 0.65), inset 0 0 0 1px rgba(94, 234, 212, 0.08);
            border: 1px solid rgba(148, 210, 255, 0.18);
            color: #e2e8f0;
            display: flex;
            flex-direction: column;
            gap: 18px;
        }

        #settingsDrawer h2 {
            margin: 0;
            font-size: 1.1rem;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            color: rgba(148, 210, 255, 0.92);
        }

        .settings-group {
            display: flex;
            flex-direction: column;
            gap: 14px;
        }

        .settings-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
        }

        .settings-row .setting-label {
            display: flex;
            flex-direction: column;
            gap: 4px;
            font-size: 0.88rem;
            color: rgba(226, 232, 240, 0.9);
        }

        .settings-row .setting-label span {
            font-size: 0.7rem;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: rgba(148, 163, 184, 0.75);
        }

        .settings-row output {
            font-size: 0.82rem;
            color: rgba(148, 210, 255, 0.92);
            min-width: 3ch;
            text-align: right;
        }

        .settings-row input[type='range'] {
            flex: 1;
            appearance: none;
            height: 4px;
            border-radius: 999px;
            background: rgba(148, 163, 184, 0.35);
        }

        .settings-row input[type='range']::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(135deg, #38bdf8, #6366f1);
            box-shadow: 0 0 0 3px rgba(15, 23, 42, 0.9);
            cursor: pointer;
        }

        .settings-row input[type='range']::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border: none;
            border-radius: 50%;
            background: linear-gradient(135deg, #38bdf8, #6366f1);
            box-shadow: 0 0 0 3px rgba(15, 23, 42, 0.9);
            cursor: pointer;
        }

        .settings-toggle {
            display: inline-flex;
            align-items: center;
            gap: 10px;
        }

        .settings-toggle input[type='checkbox'] {
            appearance: none;
            width: 40px;
            height: 22px;
            border-radius: 999px;
            background: rgba(148, 163, 184, 0.35);
            position: relative;
            cursor: pointer;
            transition: background 160ms ease;
        }

        .settings-toggle .toggle-status {
            font-size: 0.72rem;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            color: rgba(224, 231, 255, 0.82);
        }

        .settings-toggle input[type='checkbox']::after {
            content: '';
            position: absolute;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #e0f2fe;
            top: 2px;
            left: 2px;
            transition: transform 160ms ease, background 160ms ease;
            box-shadow: 0 4px 10px rgba(14, 116, 144, 0.35);
        }

        .settings-toggle input[type='checkbox']:checked {
            background: linear-gradient(135deg, rgba(56, 189, 248, 0.8), rgba(99, 102, 241, 0.8));
        }

        .settings-toggle input[type='checkbox']:checked::after {
            transform: translateX(18px);
            background: #f8fafc;
        }

        #settingsCloseButton {
            align-self: flex-end;
            border: none;
            border-radius: 999px;
            background: rgba(15, 23, 42, 0.6);
            color: rgba(148, 210, 255, 0.92);
            padding: 6px 12px;
            font-size: 0.72rem;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            cursor: pointer;
            transition: background 140ms ease, color 140ms ease;
        }

        #settingsCloseButton:hover {
            background: rgba(30, 58, 138, 0.66);
            color: rgba(224, 242, 254, 0.92);
        }

        #preflightBar {
            width: min(520px, 100%);
            padding: 0 clamp(16px, 4vw, 24px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: stretch;
            gap: clamp(12px, 3vw, 16px);
            position: relative;
            z-index: 2;
            margin: 0 auto;
        }

        #gameShell {
            --layout-gap: clamp(20px, 4vw, 32px);
            position: relative;
            display: grid;
            grid-template-columns: minmax(0, 1fr) minmax(260px, 320px);
            gap: var(--layout-gap);
            align-items: start;
            width: min(1400px, 100%);
            padding-inline: var(--layout-gap);
            z-index: 0;
            margin-inline: auto;
        }

        #playfield {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: clamp(12px, 2vw, 20px);
            width: min(900px, 100%);
            margin-inline: auto;
        }

        #loadingScreen {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: clamp(24px, 4vw, 48px);
            padding: clamp(28px, 6vw, 80px);
            background:
                linear-gradient(rgba(15, 23, 42, 0.88), rgba(15, 23, 42, 0.9)),
                url('assets/background.png') center / cover no-repeat;
            z-index: 999;
            transition: opacity 400ms ease;
            text-align: center;
        }

        #loadingScreen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        #loadingImage {
            width: clamp(180px, 40vw, 420px);
            max-width: 520px;
            justify-self: center;
            display: block;
            margin: 0 auto;
            align-self: center;
        }

        #loadingStatus {
            text-align: center;
            font-family: "Consolas", "Lucida Console", "Courier New", monospace;
            letter-spacing: 0.2em;
            color: #0f172a;
            text-transform: uppercase;
            line-height: 1.6;
            background: rgba(226, 232, 240, 0.92);
            border-radius: 18px;
            padding: clamp(18px, 3vw, 26px);
            box-shadow:
                0 16px 42px rgba(15, 23, 42, 0.4),
                inset 0 0 0 1px rgba(15, 23, 42, 0.18);
            min-width: min(360px, 100%);
            margin: 0 auto;
        }

        #loadingStatus .loading-prefix {
            display: block;
            font-size: 0.72rem;
            letter-spacing: 0.35em;
            color: #1e293b;
            margin-bottom: 8px;
        }

        #loadingStatus .loading-line {
            display: block;
            font-size: 1.05rem;
            font-weight: 600;
            color: #0f172a;
        }

        #loadingStatus .loading-percent {
            color: #0284c7;
        }

        #backgroundContainer {
            position: fixed;
            inset: 0;
            z-index: -2;
            overflow: hidden;
            background: radial-gradient(circle at top, #1a237e 0%, #0d0221 40%, #000 100%);
        }

        .backgroundLayer {
            position: absolute;
            inset: 0;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            opacity: 0;
            transition: opacity 4s ease-in-out;
            will-change: opacity;
        }

        .backgroundLayer.visible {
            opacity: 1;
        }

        canvas {
            position: relative;
            z-index: 0;
            border: 1px solid rgba(255, 255, 255, 0.4);
            background: linear-gradient(180deg, rgba(5, 18, 55, 0.95) 0%, rgba(8, 27, 70, 0.95) 45%, rgba(0, 4, 20, 0.98) 100%);
            border-radius: 10px;
            box-shadow: 0 20px 45px rgba(0, 0, 0, 0.55);
        }

        #debugOverlay {
            position: absolute;
            top: 12px;
            left: 12px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            padding: 10px 14px;
            border-radius: 12px;
            background: rgba(15, 23, 42, 0.82);
            box-shadow:
                0 12px 28px rgba(2, 6, 23, 0.45),
                inset 0 0 0 1px rgba(94, 234, 212, 0.12);
            font-family: "Consolas", "Lucida Console", "Courier New", monospace;
            font-size: 12px;
            letter-spacing: 0.04em;
            color: rgba(226, 232, 240, 0.92);
            pointer-events: none;
            z-index: 2;
        }

        #debugOverlay.hidden {
            display: none;
        }

        #stats {
            position: sticky;
            top: 0;
            font-size: 15px;
            line-height: 1.4;
            text-align: left;
            text-shadow: 0 0 6px rgba(0, 0, 0, 0.35);
            padding: 18px 20px 16px;
            border-radius: 18px;
            background: linear-gradient(165deg, rgba(15, 23, 42, 0.88), rgba(8, 16, 32, 0.82));
            box-shadow:
                0 18px 38px rgba(2, 6, 23, 0.45),
                inset 0 0 0 1px rgba(94, 234, 212, 0.08);
            border: 1px solid rgba(148, 163, 184, 0.22);
            backdrop-filter: blur(12px);
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 14px;
        }

        #stats .stat-row {
            width: 100%;
        }

        #stats .value {
            font-variant-numeric: tabular-nums;
            font-feature-settings: 'tnum' 1;
        }

        #stats .stat-list {
            display: grid;
            gap: 10px;
            margin: 0;
            padding: 0;
            list-style: none;
        }

        #stats .stat-row {
            display: flex;
            align-items: baseline;
            justify-content: space-between;
            gap: 16px;
            color: rgba(226, 232, 240, 0.9);
        }

        #stats .stat-label {
            font-size: 0.68rem;
            text-transform: uppercase;
            letter-spacing: 0.16em;
            color: rgba(148, 163, 184, 0.85);
        }

        #survivalTimer {
            position: absolute;
            top: clamp(14px, 3vw, 28px);
            left: 50%;
            transform: translateX(-50%);
            font-size: 16px;
            font-weight: 600;
            letter-spacing: 0.04em;
            padding: 6px 18px;
            border-radius: 999px;
            background: rgba(15, 23, 42, 0.78);
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.35);
            text-shadow: 0 0 6px rgba(0, 0, 0, 0.35);
            z-index: 2;
            pointer-events: none;
        }

        #survivalTimer .value {
            color: #7dd3fc;
        }

        #preflightPrompt {
            position: relative;
            width: 100%;
            margin: 0;
            padding: clamp(16px, 4vw, 22px);
            border-radius: 12px;
            border: 4px solid #f4f4f4;
            background: linear-gradient(180deg, #161616 0%, #111 100%);
            box-shadow:
                0 0 0 8px #202020,
                0 18px 0 rgba(0, 0, 0, 0.35);
            color: #fefefe;
            font-family: "Flight Time", "Press Start 2P", "Consolas", monospace;
            font-size: clamp(13px, 2.4vw, 16px);
            font-weight: 600;
            letter-spacing: 0.14em;
            text-transform: uppercase;
            text-align: center;
            display: grid;
            gap: clamp(10px, 2vw, 16px);
            justify-items: center;
            pointer-events: auto;
        }

        #preflightPrompt::after {
            content: "";
            position: absolute;
            inset: clamp(6px, 1.8vw, 8px);
            border: 2px solid rgba(255, 255, 255, 0.12);
            z-index: 0;
            pointer-events: none;
        }

        #preflightPrompt > * {
            position: relative;
            z-index: 1;
        }

        #preflightPrompt .hud-title {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 6px 18px;
            border: 3px solid #ffffff;
            background: linear-gradient(180deg, #e53e3e 0%, #b91c1c 100%);
            color: #ffffff;
            font-size: clamp(12px, 2vw, 14px);
            letter-spacing: 0.16em;
            box-shadow: 0 4px 0 #450a0a;
        }

        #preflightPrompt .prompt-text {
            text-shadow: 0 2px 0 rgba(0, 0, 0, 0.7);
        }

        #preflightPrompt[hidden] {
            display: none;
        }

        #mobilePreflightButton {
            display: none;
            align-items: center;
            justify-content: center;
            padding: 10px 22px;
            border-radius: 8px;
            border: 3px solid #f4f4f4;
            background: linear-gradient(180deg, #3b82f6 0%, #1d4ed8 100%);
            color: #f8fafc;
            font-size: clamp(12px, 2.6vw, 15px);
            font-weight: 700;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            cursor: pointer;
            box-shadow: 0 6px 0 #0f172a;
            transition: transform 120ms ease, box-shadow 120ms ease;
            touch-action: manipulation;
        }

        #mobilePreflightButton:active {
            transform: translateY(2px);
            box-shadow: 0 3px 0 #0f172a;
        }

        body.touch-enabled #mobilePreflightButton {
            display: inline-flex;
        }

        body.touch-enabled #preflightPrompt .desktop-only {
            display: none;
        }

        #settingsHint {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 8px 12px;
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.18);
            background: rgba(15, 23, 42, 0.5);
            font-size: clamp(10px, 2vw, 12px);
            letter-spacing: 0.16em;
            text-transform: uppercase;
            color: rgba(226, 232, 240, 0.92);
            text-align: center;
        }

        #stats span.value {
            font-weight: 700;
            color: #ffd54f;
        }

        #stats #comboMeter {
            width: 100%;
            margin: 4px 0 0;
        }

        #instructions {
            position: relative;
            display: flex;
            flex-direction: column;
            gap: 18px;
            width: min(320px, 28vw);
            font-size: 14px;
            text-align: left;
            opacity: 0.95;
            line-height: 1.6;
            z-index: 1;
            max-height: calc(100vh - 160px);
            overflow-y: auto;
            padding-right: 4px;
            margin-inline: 0;
        }

        #instructionPanels {
            display: flex;
            flex-direction: column;
            gap: 18px;
        }

        #instructions .hud-card {
            background: linear-gradient(165deg, rgba(15, 23, 42, 0.85), rgba(8, 16, 32, 0.78));
            border-radius: 16px;
            padding: 18px 20px;
            box-shadow: 0 18px 38px rgba(2, 6, 23, 0.45), inset 0 0 0 1px rgba(94, 234, 212, 0.08);
            border: 1px solid rgba(148, 163, 184, 0.18);
            backdrop-filter: blur(12px);
            display: flex;
            flex-direction: column;
            gap: 14px;
        }

        #instructions .card-title {
            font-size: 0.78rem;
            text-transform: uppercase;
            letter-spacing: 0.18em;
            color: rgba(148, 210, 255, 0.9);
            margin: 0 0 12px;
        }

        #instructionNav {
            position: sticky;
            top: 0;
            z-index: 2;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            padding: 12px 2px 4px;
            margin: 0 0 12px;
            background: linear-gradient(165deg, rgba(15, 23, 42, 0.78), rgba(8, 16, 32, 0.74));
            border-radius: 14px;
            border: 1px solid rgba(148, 210, 255, 0.18);
            box-shadow: inset 0 0 0 1px rgba(94, 234, 212, 0.05);
            backdrop-filter: blur(12px);
        }

        #instructions section {
            scroll-margin-top: clamp(72px, 12vh, 120px);
        }

        #instructionNav a {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 6px 14px;
            border-radius: 999px;
            font-size: 0.68rem;
            letter-spacing: 0.16em;
            text-transform: uppercase;
            color: rgba(191, 219, 254, 0.9);
            text-decoration: none;
            border: 1px solid rgba(148, 210, 255, 0.28);
            box-shadow: 0 6px 14px rgba(2, 6, 23, 0.35);
            transition: transform 140ms ease, box-shadow 140ms ease, background 140ms ease, color 140ms ease;
        }

        #instructionNav a:hover,
        #instructionNav a:focus-visible {
            background: rgba(56, 189, 248, 0.22);
            color: rgba(224, 242, 254, 0.95);
            box-shadow: 0 10px 22px rgba(14, 116, 144, 0.35);
            transform: translateY(-1px);
            outline: none;
        }

        #instructionNav a:focus-visible {
            outline: 2px solid rgba(148, 210, 255, 0.75);
            outline-offset: 3px;
        }

        #instructionNav a:active {
            transform: translateY(1px);
            box-shadow: 0 6px 12px rgba(2, 6, 23, 0.5);
        }

        #instructions .control-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin: 0;
            padding: 0;
        }

        #instructions .control-row {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        #instructions .control-keys {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            min-width: 96px;
        }

        #instructions .keycap {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 28px;
            height: 28px;
            padding: 0 8px;
            border-radius: 8px;
            border: 1px solid rgba(148, 163, 184, 0.35);
            background: linear-gradient(135deg, rgba(30, 41, 59, 0.95), rgba(15, 23, 42, 0.85));
            color: rgba(226, 232, 240, 0.95);
            font-size: 0.78rem;
            letter-spacing: 0.04em;
            box-shadow: inset 0 -2px 6px rgba(13, 148, 136, 0.25);
        }

        #instructions .keycap.wide {
            min-width: 58px;
        }

        #instructions .control-action {
            flex: 1;
            color: rgba(226, 232, 240, 0.86);
            font-size: 0.88rem;
        }

        #instructions .mission-list {
            list-style: none;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        #instructions .mission-list li {
            position: relative;
            padding-left: 18px;
            color: rgba(226, 232, 240, 0.92);
        }

        #instructions .mission-list li::before {
            content: '';
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: linear-gradient(135deg, #38bdf8, #6366f1);
            box-shadow: 0 0 10px rgba(99, 102, 241, 0.6);
        }

        #instructions .card-body {
            margin: 0;
            color: rgba(224, 231, 255, 0.9);
            font-size: 0.88rem;
            line-height: 1.65;
        }

        #socialFeed {
            list-style: none;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        #socialFeed li {
            display: flex;
            flex-direction: column;
            gap: 4px;
            color: rgba(226, 232, 240, 0.92);
            padding-left: 12px;
            border-left: 2px solid rgba(96, 165, 250, 0.35);
        }

        #socialFeed li.type-score {
            border-left-color: rgba(129, 230, 217, 0.55);
        }

        #socialFeed li.type-leaderboard {
            border-left-color: rgba(249, 168, 212, 0.6);
        }

        #socialFeed li.type-limit {
            border-left-color: rgba(248, 113, 113, 0.6);
        }

        #socialFeed li.type-combo {
            border-left-color: rgba(165, 180, 252, 0.6);
        }

        #socialFeed li.type-challenge {
            border-left-color: rgba(56, 189, 248, 0.65);
        }

        #socialFeed li .timestamp {
            font-size: 0.7rem;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            color: rgba(148, 163, 184, 0.7);
        }

        #socialFeed li.empty {
            border: none;
            padding-left: 0;
            font-style: italic;
            color: rgba(148, 163, 184, 0.8);
        }

        #intelCard .card-body {
            transition: opacity 220ms ease;
        }

        .challenge-section {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 18px;
        }

        .challenge-section h3,
        .cosmetic-section h3 {
            margin: 0;
            font-size: 0.78rem;
            letter-spacing: 0.18em;
            text-transform: uppercase;
            color: rgba(148, 210, 255, 0.82);
        }

        .challenge-list {
            list-style: none;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .challenge-item {
            background: rgba(30, 41, 59, 0.55);
            border: 1px solid rgba(94, 234, 212, 0.08);
            border-radius: 12px;
            padding: 12px 14px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            box-shadow: 0 6px 18px rgba(15, 23, 42, 0.35);
        }

        .challenge-heading {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            gap: 12px;
        }

        .challenge-title {
            margin: 0;
            font-size: 0.95rem;
            color: rgba(226, 232, 240, 0.95);
        }

        .challenge-reset {
            font-size: 0.68rem;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            color: rgba(148, 163, 184, 0.7);
        }

        .challenge-description {
            margin: 0;
            color: rgba(226, 232, 240, 0.82);
            font-size: 0.82rem;
            line-height: 1.45;
        }

        .challenge-progress {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .challenge-progress-track {
            height: 8px;
            width: 100%;
            background: rgba(15, 23, 42, 0.65);
            border-radius: 999px;
            overflow: hidden;
        }

        .challenge-progress-fill {
            height: 100%;
            background: linear-gradient(135deg, rgba(56, 189, 248, 0.9), rgba(99, 102, 241, 0.9));
            border-radius: inherit;
            width: 0;
            transition: width 180ms ease;
        }

        .challenge-progress-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.74rem;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: rgba(148, 163, 184, 0.82);
        }

        .challenge-meta {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 10px;
            font-size: 0.76rem;
            color: rgba(148, 210, 255, 0.8);
        }

        .challenge-status {
            color: rgba(226, 232, 240, 0.92);
        }

        .challenge-claim {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 999px;
            border: none;
            font-size: 0.72rem;
            letter-spacing: 0.14em;
            text-transform: uppercase;
            background: linear-gradient(135deg, rgba(56, 189, 248, 0.85), rgba(129, 140, 248, 0.85));
            color: rgba(15, 23, 42, 0.92);
            cursor: pointer;
            transition: transform 140ms ease, box-shadow 140ms ease;
        }

        .challenge-claim:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 10px 18px rgba(37, 99, 235, 0.35);
        }

        .challenge-claim:disabled {
            opacity: 0.5;
            cursor: default;
            box-shadow: none;
        }

        .cosmetic-section {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 18px;
        }

        .cosmetic-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .cosmetic-group-label {
            font-size: 0.72rem;
            letter-spacing: 0.18em;
            text-transform: uppercase;
            color: rgba(148, 163, 184, 0.78);
        }

        .cosmetic-options {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .cosmetic-option {
            border: 1px solid rgba(148, 210, 255, 0.18);
            background: rgba(15, 23, 42, 0.45);
            color: rgba(226, 232, 240, 0.9);
            padding: 6px 12px;
            border-radius: 999px;
            font-size: 0.74rem;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            cursor: pointer;
            transition: transform 140ms ease, box-shadow 140ms ease, border-color 140ms ease;
        }

        .cosmetic-option:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 10px 18px rgba(15, 23, 42, 0.45);
        }

        .cosmetic-option.equipped {
            border-color: rgba(56, 189, 248, 0.75);
            box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.45), 0 12px 24px rgba(37, 99, 235, 0.25);
        }

        .cosmetic-option:disabled {
            opacity: 0.45;
            cursor: default;
        }

        .cosmetic-option.locked {
            border-style: dashed;
        }

        .intel-log {
            list-style: none;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            gap: 14px;
        }

        .intel-log li {
            position: relative;
            padding-left: 18px;
            color: rgba(226, 232, 240, 0.94);
        }

        .intel-log li::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0.45em;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: linear-gradient(135deg, #38bdf8, #6366f1);
            box-shadow: 0 0 10px rgba(99, 102, 241, 0.6);
        }

        .intel-log li.locked {
            color: rgba(148, 163, 184, 0.75);
        }

        .intel-log li.locked::before {
            background: linear-gradient(135deg, rgba(148, 163, 184, 0.7), rgba(100, 116, 139, 0.5));
            box-shadow: none;
        }

        .intel-log .intel-title {
            font-size: 0.72rem;
            letter-spacing: 0.24em;
            text-transform: uppercase;
            margin: 0 0 6px;
            color: rgba(148, 210, 255, 0.82);
        }

        .intel-log .intel-text {
            margin: 0;
            font-size: 0.84rem;
            line-height: 1.7;
        }

        #touchControls {
            position: fixed;
            inset: 0;
            display: none;
            pointer-events: none;
            z-index: 1;
            --touch-bottom: clamp(16px, 8vh, 72px);
            --joystick-left: max(16px, calc(50% - 450px - 108px));
            --fire-left: auto;
            --fire-right: max(16px, calc(50% - 450px - 96px));
        }

        @media (pointer: coarse) {
            #touchControls {
                display: block;
            }
        }

        #joystickZone {
            position: absolute;
            width: clamp(132px, 26vw, 188px);
            height: clamp(132px, 26vw, 188px);
            left: var(--joystick-left);
            bottom: var(--touch-bottom);
            border-radius: 50%;
            background: rgba(15, 23, 42, 0.58);
            border: 2px solid rgba(148, 163, 184, 0.32);
            box-shadow: 0 12px 28px rgba(15, 23, 42, 0.45);
            backdrop-filter: blur(2px);
            pointer-events: auto;
            touch-action: none;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        #joystickZone .joystick-ring {
            position: absolute;
            inset: 14%;
            border-radius: 50%;
            border: 2px dashed rgba(148, 163, 184, 0.28);
        }

        #joystickZone .joystick-thumb {
            position: absolute;
            left: 50%;
            top: 50%;
            width: 38%;
            height: 38%;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, rgba(125, 211, 252, 0.9), rgba(2, 132, 199, 0.75));
            box-shadow: 0 6px 16px rgba(14, 116, 144, 0.65);
            transform: translate(calc(-50% + var(--thumb-x, 0px)), calc(-50% + var(--thumb-y, 0px)));
            transition: transform 80ms ease-out;
        }

        #fireButton {
            position: absolute;
            left: var(--fire-left);
            right: var(--fire-right);
            bottom: var(--touch-bottom);
            width: clamp(108px, 24vw, 160px);
            height: clamp(108px, 24vw, 160px);
            border-radius: 40px;
            border: none;
            pointer-events: auto;
            font-size: clamp(1rem, 4vw, 1.2rem);
            font-weight: 700;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: #fff;
            background: radial-gradient(circle at 30% 30%, rgba(255, 107, 214, 0.92), rgba(255, 64, 129, 0.88));
            box-shadow: 0 18px 38px rgba(255, 64, 129, 0.45);
            transition: transform 120ms ease, box-shadow 120ms ease;
            touch-action: manipulation;
        }

        #fireButton:active,
        #fireButton.active {
            transform: translateY(2px) scale(0.98);
            box-shadow: 0 12px 28px rgba(255, 64, 129, 0.35);
        }

        #overlay {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: linear-gradient(rgba(5, 8, 25, 0.92), rgba(1, 3, 12, 0.94));
            text-align: center;
            padding: clamp(32px, 6vw, 64px);
            gap: clamp(14px, 3vw, 24px);
            transition: opacity 200ms ease;
            z-index: 4;
            overflow-y: auto;
        }

        #overlay.hidden {
            pointer-events: none;
            opacity: 0;
        }

        #overlay h1 {
            font-size: clamp(1.95rem, 5.25vw, 3.45rem);
            margin: 0;
            letter-spacing: clamp(0.26rem, 1.05vw, 0.64rem);
            color: #f9a8d4;
            text-shadow: 0 0 18px rgba(249, 168, 212, 0.55);
        }

        #overlay h1:empty {
            display: none;
        }

        #comicIntro {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: clamp(12px, 2vw, 21px);
            width: min(660px, 100%);
            margin: 0;
        }

        #comicIntro[hidden] {
            display: none;
        }

        .comic-panel {
            flex: 1 1 clamp(165px, 21%, 210px);
            min-height: 140px;
            border-radius: 18px;
            padding: clamp(12px, 1.5vw, 17px);
            position: relative;
            overflow: hidden;
            box-shadow:
                0 14px 28px rgba(5, 8, 25, 0.6),
                inset 0 0 0 1px rgba(148, 210, 255, 0.22);
            background:
                linear-gradient(135deg, rgba(56, 189, 248, 0.85), rgba(99, 102, 241, 0.72));
            color: #0b1220;
            text-align: left;
        }

        .comic-panel::after {
            content: '';
            position: absolute;
            inset: 0;
            background:
                radial-gradient(circle at top left, rgba(226, 232, 240, 0.35), transparent 55%),
                radial-gradient(circle at bottom right, rgba(14, 116, 144, 0.4), transparent 60%);
            mix-blend-mode: screen;
            pointer-events: none;
        }

        .comic-panel h3 {
            font-size: 0.72rem;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            margin: 0 0 12px;
        }

        .comic-panel p {
            margin: 0;
            font-size: 0.69rem;
            line-height: 1.45;
        }

        #callsignForm {
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: center;
            width: min(315px, 100%);
        }

        #callsignForm label {
            font-size: 0.62rem;
            letter-spacing: 0.14em;
            text-transform: uppercase;
            color: rgba(148, 210, 255, 0.82);
        }

        #callsignForm .input-row {
            position: relative;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        #playerNameInput {
            width: 100%;
            border-radius: 14px;
            border: 1px solid rgba(148, 210, 255, 0.35);
            background: rgba(8, 16, 32, 0.86);
            color: rgba(226, 232, 240, 0.95);
            padding: 9px 12px;
            font: inherit;
            letter-spacing: 0.04em;
            box-shadow: inset 0 0 0 1px rgba(14, 165, 233, 0.15);
        }

        #playerNameInput:focus-visible {
            outline: 2px solid rgba(148, 210, 255, 0.75);
            outline-offset: 3px;
        }

        #callsignHint {
            font-size: 0.56rem;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            color: rgba(148, 210, 255, 0.6);
        }

        #overlay p {
            margin: 0;
            font-size: 0.78rem;
            max-width: min(420px, 90vw);
            color: rgba(224, 231, 255, 0.88);
            white-space: pre-line;
        }

        #overlayActions {
            display: flex;
            flex-direction: column;
            align-items: stretch;
            gap: 10px;
            width: min(360px, 90vw);
        }

        #overlayActions button {
            width: 100%;
        }

        #overlay button {
            background: linear-gradient(135deg, rgba(56, 189, 248, 0.92), rgba(99, 102, 241, 0.92));
            border: none;
            border-radius: 999px;
            padding: 11px 24px;
            color: #fff;
            font-size: 0.72rem;
            font-weight: 700;
            letter-spacing: 0.14em;
            text-transform: uppercase;
            cursor: pointer;
            box-shadow: 0 18px 36px rgba(37, 99, 235, 0.45);
            transition: transform 160ms ease, box-shadow 160ms ease;
        }

        #overlay button:hover {
            transform: translateY(-2px);
            box-shadow: 0 22px 46px rgba(37, 99, 235, 0.52);
        }

        #overlay button:active {
            transform: translateY(1px);
            box-shadow: 0 14px 28px rgba(37, 99, 235, 0.48);
        }

        #overlay button[disabled] {
            cursor: default;
            opacity: 0.65;
            box-shadow: none;
        }

        #overlaySecondaryButton {
            background: transparent;
            border: 1px solid rgba(148, 210, 255, 0.45);
            color: rgba(224, 231, 255, 0.88);
            box-shadow: none;
        }

        #overlaySecondaryButton:hover {
            transform: translateY(-1px);
            box-shadow: 0 16px 32px rgba(37, 99, 235, 0.3);
        }

        #overlaySecondaryButton:active {
            transform: translateY(1px);
            box-shadow: 0 12px 24px rgba(37, 99, 235, 0.28);
        }

        #overlay.unsupported #highScorePanel {
            display: none;
        }

        #comboMeter {
            width: 160px;
            height: 8px;
            border-radius: 999px;
            overflow: hidden;
            background: rgba(255, 255, 255, 0.12);
            margin-top: 8px;
        }

        #comboFill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #6a5acd, #00e5ff);
            transition: width 100ms ease-out;
        }

        #comboMeter.charged {
            background: rgba(16, 185, 129, 0.32);
            box-shadow: 0 0 14px rgba(16, 185, 129, 0.45);
        }

        #comboMeter.charged #comboFill {
            filter: drop-shadow(0 0 6px rgba(16, 185, 129, 0.75));
        }

        #overlayPanels {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            width: 100%;
            max-width: 540px;
            gap: 14px;
        }

        #highScorePanel,
        #leaderboardPanel,
        #sharePanel {
            margin-top: 8px;
            padding: 9px 14px;
            border-radius: 12px;
            background: rgba(12, 15, 35, 0.6);
            box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.18);
            text-align: left;
            max-width: 240px;
        }

        #highScoreTitle {
            font-size: 0.64rem;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            margin-bottom: 8px;
            color: rgba(148, 163, 184, 0.95);
        }

        #leaderboardPanel .panel-title,
        #sharePanel .panel-title {
            font-size: 0.64rem;
            text-transform: uppercase;
            letter-spacing: 0.14em;
            margin-bottom: 8px;
            color: rgba(148, 163, 184, 0.95);
        }

        #leaderboardPanel .panel-header {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-bottom: 8px;
        }

        .panel-tabs {
            display: inline-flex;
            gap: 6px;
        }

        .panel-tabs .leaderboard-tab {
            background: rgba(30, 41, 59, 0.65);
            border: 1px solid rgba(148, 163, 184, 0.2);
            color: rgba(226, 232, 240, 0.88);
            border-radius: 999px;
            font-size: 0.58rem;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            padding: 4px 10px;
            cursor: pointer;
            transition: background 140ms ease, color 140ms ease, border-color 140ms ease;
        }

        .panel-tabs .leaderboard-tab.active {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.8), rgba(129, 140, 248, 0.85));
            color: #e0f2fe;
            border-color: rgba(96, 165, 250, 0.4);
        }

        .panel-tabs .leaderboard-tab:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .panel-status {
            font-size: 0.58rem;
            letter-spacing: 0.04em;
            color: rgba(148, 163, 184, 0.85);
            margin: 0;
        }

        .panel-status.success {
            color: rgba(134, 239, 172, 0.9);
        }

        .panel-status.loading {
            color: rgba(125, 211, 252, 0.88);
        }

        .panel-status.error {
            color: rgba(248, 113, 113, 0.92);
        }

        .panel-status.warning {
            color: rgba(251, 191, 36, 0.92);
        }

        .panel-status[hidden] {
            display: none;
        }

        #highScoreList {
            list-style: decimal inside;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            gap: 6px;
            font-size: 0.68rem;
        }

        #highScoreList li {
            color: rgba(226, 232, 240, 0.92);
        }

        #highScoreList li.empty {
            list-style: none;
            color: rgba(148, 163, 184, 0.85);
            font-style: italic;
        }

        #highScoreList li .time {
            font-weight: 600;
            color: #7dd3fc;
        }

        #highScoreList li .score {
            color: #facc15;
        }

        #leaderboardList {
            list-style: decimal inside;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            gap: 6px;
            font-size: 0.68rem;
        }

        #leaderboardList li {
            color: rgba(226, 232, 240, 0.92);
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        #leaderboardList li .meta {
            font-size: 0.54rem;
            letter-spacing: 0.06em;
            color: rgba(148, 163, 184, 0.78);
        }

        #leaderboardList li.empty {
            list-style: none;
            color: rgba(148, 163, 184, 0.85);
            font-style: italic;
        }

        #sharePanel {
            max-width: 315px;
            text-align: center;
        }

        #sharePanel .share-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 8px;
            justify-content: center;
        }

        #sharePanel button.share-button {
            background: linear-gradient(135deg, #38bdf8, #6366f1);
            padding: 8px 14px;
            font-size: 0.68rem;
            border-radius: 12px;
            border: none;
            color: #fff;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 10px 26px rgba(14, 165, 233, 0.35);
            transition: transform 140ms ease, box-shadow 140ms ease;
        }

        #sharePanel button.share-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 14px 32px rgba(14, 165, 233, 0.45);
        }

        #sharePanel button.share-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            box-shadow: none;
        }

        #shareStatus {
            margin: 0;
            font-size: 0.62rem;
            color: rgba(148, 210, 255, 0.85);
            min-height: 1.4em;
            text-align: center;
        }

        #shareStatus.success {
            color: rgba(129, 230, 217, 0.9);
        }

        #shareStatus.error {
            color: rgba(248, 113, 113, 0.9);
        }

        @media (max-width: 1250px) {
            #gameShell {
                grid-template-columns: 1fr;
                width: min(900px, 100%);
            }

            #instructions {
                width: min(520px, 100%);
                max-height: none;
                overflow: visible;
                padding-right: 0;
                margin: clamp(18px, 4vw, 28px) auto 0;
                margin-left: 0;
            }

            #stats {
                position: relative;
            }
        }

        @media (max-width: 768px) {
            :root {
                --mobile-hud-collapsed-height: clamp(64px, 16vw, 96px);
            }

            body {
                padding: clamp(16px, 4vw, 28px);
                padding-bottom: calc(var(--mobile-hud-collapsed-height) + clamp(18px, 4vw, 32px));
                align-items: center;
            }

            #preflightBar {
                width: 100%;
                padding: 0 clamp(12px, 6vw, 20px);
                margin: 0 auto;
            }

            #preflightPrompt {
                width: 100%;
                border-width: 3px;
                box-shadow:
                    0 0 0 6px #202020,
                    0 12px 0 rgba(0, 0, 0, 0.35);
            }

            #gameShell {
                gap: clamp(16px, 5vw, 24px);
                grid-template-columns: 1fr;
                width: 100%;
                max-width: min(620px, 100%);
                padding-inline: 0;
                margin-inline: auto;
            }

            #playfield {
                width: 100%;
                max-width: min(540px, 100%);
            }

            canvas {
                width: 100%;
                height: auto;
                max-width: 100%;
                box-shadow: 0 12px 28px rgba(0, 0, 0, 0.45);
            }

            #loadingStatus {
                width: min(480px, 100%);
            }

            #instructions {
                box-shadow: 0 -14px 32px rgba(2, 6, 23, 0.55);
                backdrop-filter: none;
                -webkit-backdrop-filter: none;
            }

            #instructions {
                position: fixed;
                left: 0;
                right: 0;
                bottom: 0;
                width: 100%;
                max-width: none;
                margin: 0;
                padding: 14px clamp(16px, 5vw, 22px) clamp(18px, 5vw, 26px);
                border-radius: 22px 22px 0 0;
                background: linear-gradient(165deg, rgba(15, 23, 42, 0.92), rgba(8, 16, 32, 0.9));
                box-shadow: 0 -18px 40px rgba(2, 6, 23, 0.65);
                max-height: min(70vh, 420px);
                overflow: hidden;
            }

            #instructionNav {
                position: static;
                order: 2;
                display: flex;
                align-items: center;
                justify-content: space-between;
                gap: 8px;
                padding: 0;
                margin: 0;
                background: transparent;
                border: none;
                box-shadow: none;
                overflow-x: auto;
            }

            #instructionNav a {
                flex: 1;
                min-width: max(68px, 18%);
                padding: 10px 12px;
                font-size: 0.62rem;
                letter-spacing: 0.12em;
                border-radius: 999px;
                border: 1px solid rgba(148, 210, 255, 0.28);
                background: rgba(15, 23, 42, 0.6);
                color: rgba(191, 219, 254, 0.92);
                box-shadow: inset 0 0 0 1px rgba(56, 189, 248, 0.1);
                white-space: nowrap;
            }

            #instructionNav a:hover,
            #instructionNav a:focus-visible {
                transform: none;
            }

            #instructionNav a.mobile-active {
                background: linear-gradient(135deg, rgba(56, 189, 248, 0.9), rgba(99, 102, 241, 0.82));
                color: rgba(12, 18, 32, 0.92);
                box-shadow: 0 8px 18px rgba(56, 189, 248, 0.35);
            }

            #instructionPanels {
                order: 1;
                flex: 1;
                overflow: hidden;
                display: none;
                padding-right: 2px;
            }

            #instructions[data-mobile-open] {
                overflow: hidden;
            }

            #instructions[data-mobile-open] #instructionPanels {
                display: block;
                overflow-y: auto;
            }

            #instructions[data-mobile-open] #instructionPanels > * {
                display: none;
            }

            #instructions[data-mobile-open="stats"] #instructionPanels > #stats,
            #instructions[data-mobile-open="controlsCard"] #instructionPanels > #controlsCard,
            #instructions[data-mobile-open="missionCard"] #instructionPanels > #missionCard,
            #instructions[data-mobile-open="intelCard"] #instructionPanels > #intelCard,
            #instructions[data-mobile-open="socialCard"] #instructionPanels > #socialCard {
                display: block;
            }

            #instructions:not([data-mobile-open]) {
                max-height: var(--mobile-hud-collapsed-height);
            }

            #instructions:not([data-mobile-open]) #instructionNav {
                padding-bottom: 2px;
            }

            #instructions:not([data-mobile-open]) #instructionPanels {
                display: none;
            }

            #joystickZone {
                left: clamp(12px, 6vw, 24px);
                bottom: calc(var(--mobile-hud-collapsed-height) + clamp(14px, 5vw, 28px));
            }

            #fireButton {
                right: clamp(12px, 6vw, 24px);
                bottom: calc(var(--mobile-hud-collapsed-height) + clamp(18px, 5vw, 32px));
            }
        }
    </style>
</head>
<body>
    <div id="loadingScreen">
        <img src="assets/logo.png" alt="Cyborg boot sequence" id="loadingImage">
        <div id="loadingStatus">
            <span class="loading-prefix">[SYS-BOOT:00]</span>
            <span class="loading-line">Initializing quantum cores  <span class="loading-percent">000%</span></span>
        </div>
    </div>
    <div id="backgroundContainer">
        <div class="backgroundLayer visible" id="backgroundLayerA"></div>
        <div class="backgroundLayer" id="backgroundLayerB"></div>
    </div>
    <button
        id="settingsButton"
        type="button"
        aria-haspopup="dialog"
        aria-controls="settingsDrawer"
        aria-expanded="false"
    >
        <span class="icon" aria-hidden="true"></span>
        <span class="label">Settings</span>
    </button>
    <div id="gameShell">
        <div id="playfield">
            <canvas id="gameCanvas" tabindex="0" aria-label="Nyan Escape flight deck"></canvas>
            <div id="debugOverlay" aria-hidden="true" hidden>
                <div data-debug-line="logical"></div>
                <div data-debug-line="physical"></div>
                <div data-debug-line="ratio"></div>
            </div>
            <div id="survivalTimer">Flight Time: <span class="value" id="timerValue">00:00.0</span></div>
            <div id="preflightBar">
                <div id="preflightPrompt" role="status" aria-live="polite" hidden>
                    <span class="hud-title" aria-hidden="true">Nyan Ready</span>
                    <span class="prompt-text desktop-only">Press Start (Enter) to launch</span>
                    <button id="mobilePreflightButton" type="button" hidden aria-hidden="true">Tap Start</button>
                </div>
                <div id="settingsHint" aria-live="polite">
                    <span class="desktop-only">Press Esc for settings</span>
                    <span class="touch-only">Tap  for settings</span>
                </div>
            </div>
        </div>
        <aside id="instructions" aria-label="Flight telemetry, controls, and mission information">
            <nav id="instructionNav" aria-label="Quick mission links">
                <a href="#stats" data-panel-target="stats" aria-controls="stats" aria-expanded="false">Telemetry</a>
                <a href="#controlsCard" data-panel-target="controlsCard" aria-controls="controlsCard" aria-expanded="false">Controls</a>
                <a href="#missionCard" data-panel-target="missionCard" aria-controls="missionCard" aria-expanded="false">Mission</a>
                <a href="#intelCard" data-panel-target="intelCard" aria-controls="intelCard" aria-expanded="false">Intel</a>
                <a href="#socialCard" data-panel-target="socialCard" aria-controls="socialCard" aria-expanded="false">Feed</a>
            </nav>
            <div id="instructionPanels">
                <section id="stats" role="complementary" aria-live="polite">
                    <h2 class="card-title">Flight Telemetry</h2>
                    <div class="stat-list" role="presentation">
                        <div class="stat-row">
                            <span class="stat-label">Score</span>
                            <span class="value" id="score">0</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Points</span>
                            <span class="value" id="nyan">0</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Streak</span>
                            <span class="value" id="streak">x1</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Best Tail</span>
                            <span class="value" id="bestStreak">0</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">MCAP</span>
                            <span class="value" id="mcap">6.6K</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">VOL</span>
                            <span class="value" id="vol">2.8K</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Boosts</span>
                            <span class="value" id="powerUps">None</span>
                        </div>
                    </div>
                    <div
                        id="comboMeter"
                        role="progressbar"
                        aria-label="Combo charge"
                        aria-valuemin="0"
                        aria-valuemax="100"
                        aria-valuenow="0"
                    >
                        <div id="comboFill"></div>
                    </div>
                </section>
                <section class="hud-card" id="controlsCard" aria-labelledby="controlsCardTitle">
                    <h2 class="card-title" id="controlsCardTitle">Flight Controls</h2>
                    <div class="card-body">
                        <div class="control-list" role="list">
                            <div class="control-row" role="listitem">
                                <div class="control-keys" aria-label="Movement keys">
                                    <span class="keycap" aria-hidden="true"></span>
                                    <span class="keycap" aria-hidden="true"></span>
                                    <span class="keycap" aria-hidden="true"></span>
                                    <span class="keycap" aria-hidden="true"></span>
                                </div>
                                <div class="control-action">Vector the catship through hazards.</div>
                            </div>
                            <div class="control-row" role="listitem">
                                <div class="control-keys" aria-label="Fire control">
                                    <span class="keycap wide" aria-hidden="true">Space</span>
                                </div>
                                <div class="control-action">Launch precision plasma bolts.</div>
                            </div>
                            <div class="control-row" role="listitem">
                                <div class="control-keys" aria-label="Settings shortcut">
                                    <span class="keycap wide" aria-hidden="true">Esc</span>
                                </div>
                                <div class="control-action">Open the quick settings panel mid-flight.</div>
                            </div>
                            <div class="control-row" role="listitem">
                                <div class="control-keys" aria-label="Touch controls">
                                    <span class="keycap wide" aria-hidden="true">Touch</span>
                                </div>
                                <div class="control-action">Drag the left pad to steer, tap Fire to engage, tap  to tweak settings.</div>
                            </div>
                        </div>
                    </div>
                </section>
                <section class="hud-card" id="missionCard" aria-labelledby="missionCardTitle">
                    <h2 class="card-title" id="missionCardTitle">Mission Brief</h2>
                    <div class="card-body">
                        <ul class="mission-list">
                            <li>Collect Points to fuel the escape and grow your score.</li>
                            <li>Slip between asteroids and hostile fire to stay in the fight.</li>
                            <li>Secure booster cores for temporary firepower and agility.</li>
                            <li>Snag the Radiant Shield to ricochet villains and asteroids away.</li>
                            <li>Channel Hyper Beam cores to carve safe corridors when the lane is crowded.</li>
                            <li>Keep the combo meter charged to amplify every point.</li>
                        </ul>
                    </div>
                </section>
                <section class="hud-card" id="intelCard" aria-labelledby="intelCardTitle">
                    <h2 class="card-title" id="intelCardTitle">Tactical Intel</h2>
                    <div class="card-body">
                        <div class="challenge-section" aria-live="polite">
                            <h3>Active Challenges</h3>
                            <ul class="challenge-list" id="challengeList" role="list"></ul>
                        </div>
                        <div class="cosmetic-section" aria-live="polite">
                            <h3>Cosmetic Loadout</h3>
                            <div class="cosmetic-group" role="group" aria-label="Ship skins">
                                <span class="cosmetic-group-label">Ship</span>
                                <div class="cosmetic-options" id="skinOptions"></div>
                            </div>
                            <div class="cosmetic-group" role="group" aria-label="Trail styles">
                                <span class="cosmetic-group-label">Trail</span>
                                <div class="cosmetic-options" id="trailOptions"></div>
                            </div>
                        </div>
                        <ul class="intel-log" id="intelLog" role="list" aria-live="polite"></ul>
                    </div>
                </section>
                <section class="hud-card" id="socialCard" aria-labelledby="socialCardTitle">
                    <h2 class="card-title" id="socialCardTitle">Squadron Feed</h2>
                    <div class="card-body">
                        <ul id="socialFeed" role="list"></ul>
                    </div>
                </section>
            </div>
        </aside>
    </div>
    <div id="touchControls" aria-hidden="true">
        <div id="joystickZone">
            <div class="joystick-ring"></div>
            <div class="joystick-thumb"></div>
        </div>
        <button id="fireButton" type="button" aria-label="Fire cosmic arrows">Fire</button>
    </div>
    <div id="overlay">
        <h1>NYAN ESCAPE</h1>
        <div id="comicIntro" class="comic-panels" hidden>
            <article class="comic-panel">
                <h3>Inciting Incident</h3>
                <p>Space Station Meowprise is under siege by neon asteroids. Only your star-kitted reflexes can cut a path to safety.</p>
            </article>
            <article class="comic-panel">
                <h3>Assemble the Crew</h3>
                <p>Power cores, Nova Pulses, and the Radiant Shield await. Stack boosts, chain streaks, and bend the odds in your favor.</p>
            </article>
            <article class="comic-panel">
                <h3>Broadcast the Escape</h3>
                <p>Every logged flight inspires the squadron. Chronicle your best three runs each cycle and rally the galaxy.</p>
            </article>
        </div>
        <p id="overlayMessage">Thread the cosmic needle, gather Points, and charge Nova Pulses to vaporize space junk. Ready to glide?</p>
        <form id="callsignForm" autocomplete="off" novalidate>
            <label for="playerNameInput">Pilot Callsign</label>
            <div class="input-row">
                <input id="playerNameInput" name="playerName" type="text" maxlength="24" autocomplete="off" spellcheck="false" placeholder="Ace Pilot" aria-describedby="callsignHint">
                <span id="callsignHint">Press Start (Enter) or click Launch to begin a run.</span>
            </div>
        </form>
        <div id="overlayActions">
            <button id="overlayButton" type="button" disabled aria-disabled="true">Launch Flight</button>
            <button id="overlaySecondaryButton" type="button" class="secondary" hidden aria-disabled="true">Skip Submission</button>
        </div>
        <div id="overlayPanels">
            <div id="highScorePanel">
                <div id="highScoreTitle">Top Flight Times</div>
                <ol id="highScoreList"></ol>
            </div>
            <div id="leaderboardPanel">
                <div class="panel-header">
                    <div class="panel-title" id="leaderboardTitle">Galaxy Standings</div>
                    <div class="panel-tabs" role="tablist" aria-label="Leaderboard scope">
                        <button
                            type="button"
                            class="leaderboard-tab active"
                            data-leaderboard-scope="global"
                            aria-pressed="true"
                        >
                            Global
                        </button>
                        <button
                            type="button"
                            class="leaderboard-tab"
                            data-leaderboard-scope="weekly"
                            aria-pressed="false"
                        >
                            Weekly
                        </button>
                    </div>
                </div>
                <p
                    id="leaderboardStatus"
                    class="panel-status"
                    role="status"
                    aria-live="polite"
                    hidden
                ></p>
                <ol id="leaderboardList"></ol>
            </div>
        </div>
        <div id="sharePanel">
            <div class="panel-title">Broadcast Run</div>
            <div class="share-buttons">
                <button id="shareButton" class="share-button" type="button">Share Flight Log</button>
                <button id="copyShareButton" class="share-button" type="button">Copy to Clipboard</button>
            </div>
            <p id="shareStatus" role="status" aria-live="polite"></p>
        </div>
    </div>
    <div
        id="settingsDrawer"
        role="dialog"
        aria-modal="true"
        aria-labelledby="settingsTitle"
        aria-hidden="true"
        hidden
    >
        <div class="settings-backdrop" data-settings-dismiss="backdrop"></div>
        <div class="settings-content" role="document">
            <button id="settingsCloseButton" type="button">Close</button>
            <h2 id="settingsTitle">Flight Settings</h2>
            <div class="settings-group" role="group" aria-labelledby="settingsTitle">
                <div class="settings-row">
                    <div class="setting-label">
                        Master Volume
                        <span>Overall output</span>
                    </div>
                    <input
                        id="masterVolumeSlider"
                        type="range"
                        min="0"
                        max="100"
                        value="85"
                        aria-valuemin="0"
                        aria-valuemax="100"
                        aria-valuenow="85"
                        aria-label="Master volume"
                    />
                    <output id="masterVolumeValue" for="masterVolumeSlider">85%</output>
                </div>
                <div class="settings-row">
                    <div class="setting-label">
                        Music Track
                        <span>Background score</span>
                    </div>
                    <label class="settings-toggle" for="musicToggle">
                        <input id="musicToggle" type="checkbox" checked />
                        <span id="musicToggleStatus" class="toggle-status">On</span>
                    </label>
                </div>
                <div class="settings-row">
                    <div class="setting-label">
                        Effects Audio
                        <span>Projectiles &amp; bursts</span>
                    </div>
                    <label class="settings-toggle" for="sfxToggle">
                        <input id="sfxToggle" type="checkbox" checked />
                        <span id="sfxToggleStatus" class="toggle-status">On</span>
                    </label>
                </div>
                <div class="settings-row">
                    <div class="setting-label">
                        Reduced Effects
                        <span>Dim particle storms</span>
                    </div>
                    <label class="settings-toggle" for="reducedEffectsToggle">
                        <input id="reducedEffectsToggle" type="checkbox" />
                        <span id="reducedEffectsStatus" class="toggle-status">Off</span>
                    </label>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas?.getContext ? canvas.getContext('2d') : null;

            function enableHighQualitySmoothing(context) {
                if (!context) {
                    return;
                }

                if (typeof context.imageSmoothingEnabled !== 'undefined') {
                    context.imageSmoothingEnabled = true;
                }

                if (typeof context.imageSmoothingQuality !== 'undefined') {
                    context.imageSmoothingQuality = 'high';
                }
            }

            enableHighQualitySmoothing(ctx);
            const supportsPointerEvents = typeof window !== 'undefined' && 'PointerEvent' in window;

            const audioManager = (() => {
                const clamp01 = (value) => Math.max(0, Math.min(1, value));

                const audioCapabilityProbe = (() => {
                    if (typeof window === 'undefined' || typeof document === 'undefined') {
                        return null;
                    }

                    if (typeof Audio !== 'function') {
                        return null;
                    }

                    try {
                        const element = document.createElement('audio');
                        return typeof element?.canPlayType === 'function' ? element : null;
                    } catch {
                        return null;
                    }
                })();

                const supportedFormats = audioCapabilityProbe
                    ? {
                        mp3: audioCapabilityProbe.canPlayType('audio/mpeg') !== '',
                        ogg: audioCapabilityProbe.canPlayType('audio/ogg; codecs="vorbis"') !== '',
                        wav: audioCapabilityProbe.canPlayType('audio/wav; codecs="1"') !== ''
                    }
                    : {};

                const supportedExtensions = new Set(
                    Object.entries(supportedFormats)
                        .filter(([, value]) => Boolean(value))
                        .map(([ext]) => ext)
                );

                const isSupported = Boolean(audioCapabilityProbe) && supportedExtensions.size > 0;

                const normalizeSources = (definition) => {
                    if (!definition) {
                        return [];
                    }

                    if (Array.isArray(definition)) {
                        return definition;
                    }

                    if (typeof definition === 'string') {
                        return [definition];
                    }

                    if (Array.isArray(definition.sources)) {
                        return definition.sources;
                    }

                    if (typeof definition.src === 'string') {
                        return [definition.src];
                    }

                    return [];
                };

                const resolveAudioSource = (definition) => {
                    const sources = normalizeSources(definition);

                    if (!sources.length) {
                        return '';
                    }

                    if (!audioCapabilityProbe) {
                        return sources[0];
                    }

                    const mimeForExtension = (ext) => {
                        switch (ext) {
                            case 'mp3':
                                return 'audio/mpeg';
                            case 'ogg':
                                return 'audio/ogg';
                            case 'wav':
                                return 'audio/wav';
                            case 'aac':
                                return 'audio/aac';
                            default:
                                return '';
                        }
                    };

                    for (const candidate of sources) {
                        const extension = candidate.split('?')[0].split('#')[0].split('.').pop()?.toLowerCase();
                        if (extension && supportedExtensions.size > 0 && !supportedExtensions.has(extension)) {
                            continue;
                        }

                        const mimeType = mimeForExtension(extension);
                        if (!mimeType || audioCapabilityProbe.canPlayType(mimeType) !== '') {
                            return candidate;
                        }
                    }

                    if (supportedExtensions.size > 0) {
                        const fallback = sources.find((candidate) => {
                            const extension = candidate.split('?')[0].split('#')[0].split('.').pop()?.toLowerCase();
                            return !extension || supportedExtensions.has(extension);
                        });
                        if (fallback) {
                            return fallback;
                        }
                    }

                    return sources[0];
                };

                const soundDefinitions = {
                    projectile: {
                        standard: { sources: ['assets/audio/projectile-standard.mp3'], voices: 6, volume: 0.55 },
                        spread: { sources: ['assets/audio/projectile-spread.mp3'], voices: 6, volume: 0.52 },
                        missile: { sources: ['assets/audio/projectile-missile.mp3'], voices: 4, volume: 0.6 }
                    },
                    collect: {
                        point: { sources: ['assets/audio/point.mp3'], voices: 4, volume: 0.6 }
                    },
                    explosion: {
                        villain1: { sources: ['assets/audio/explosion-villain1.mp3'], voices: 3, volume: 0.7 },
                        villain2: { sources: ['assets/audio/explosion-villain2.mp3'], voices: 3, volume: 0.7 },
                        villain3: { sources: ['assets/audio/explosion-villain3.mp3'], voices: 3, volume: 0.75 },
                        asteroid: { sources: ['assets/audio/explosion-asteroid.mp3'], voices: 3, volume: 0.68 },
                        powerbomb: { sources: ['assets/audio/explosion-powerbomb.mp3'], voices: 2, volume: 0.76 },
                        generic: { sources: ['assets/audio/explosion-generic.mp3'], voices: 3, volume: 0.66 }
                    }
                };

                const state = {
                    masterVolume: 0.85,
                    muted: false,
                    unlocked: !isSupported,
                    musicEnabled: true,
                    sfxEnabled: true
                };

                const pools = new Map();
                const musicDefinition = { sources: ['assets/audio/gameplay.mp3'], volume: 0.52 };
                const hyperBeamDefinition = { sources: ['assets/audio/hyperbeam.mp3'], volume: 0.62 };
                let gameplayMusic = null;
                let shouldResumeGameplayMusic = false;
                let hyperBeamAudio = null;
                let shouldResumeHyperBeam = false;
                let resumeGameplayAfterVisibility = false;
                let resumeHyperAfterVisibility = false;
                const fadeControllers = new WeakMap();
                const stopTimers = new WeakMap();

                const scheduleAnimationFrame = typeof window !== 'undefined' && typeof window.requestAnimationFrame === 'function'
                    ? window.requestAnimationFrame.bind(window)
                    : null;
                const cancelAnimationFrame = typeof window !== 'undefined' && typeof window.cancelAnimationFrame === 'function'
                    ? window.cancelAnimationFrame.bind(window)
                    : null;

                const clearStopTimer = (audio) => {
                    const timerId = stopTimers.get(audio);
                    if (timerId != null) {
                        window.clearTimeout(timerId);
                        stopTimers.delete(audio);
                    }
                };

                const stopExistingFade = (audio) => {
                    const cancel = fadeControllers.get(audio);
                    if (typeof cancel === 'function') {
                        cancel();
                        fadeControllers.delete(audio);
                    }
                };

                const fadeAudio = (audio, targetVolume, duration = 220) => {
                    if (!audio) {
                        return;
                    }

                    const resolvedTarget = clamp01(targetVolume ?? 0);
                    const currentVolume = clamp01(audio.volume ?? 0);

                    if (Math.abs(currentVolume - resolvedTarget) < 0.001 || duration <= 0) {
                        stopExistingFade(audio);
                        audio.volume = resolvedTarget;
                        return;
                    }

                    stopExistingFade(audio);

                    const startVolume = currentVolume;
                    const startTime = performance.now();
                    let rafId = null;
                    let timeoutId = null;
                    const useRaf = typeof scheduleAnimationFrame === 'function';

                    const cancel = () => {
                        if (useRaf && rafId != null) {
                            cancelAnimationFrame?.(rafId);
                        } else if (!useRaf && timeoutId != null) {
                            window.clearTimeout(timeoutId);
                        }
                    };

                    const step = (now) => {
                        const progress = clamp01((now - startTime) / duration);
                        const nextVolume = startVolume + (resolvedTarget - startVolume) * progress;
                        audio.volume = clamp01(nextVolume);

                        if (progress < 1) {
                            if (useRaf) {
                                rafId = scheduleAnimationFrame(step);
                            } else {
                                timeoutId = window.setTimeout(() => step(performance.now()), 16);
                            }
                        } else {
                            fadeControllers.delete(audio);
                        }
                    };

                    fadeControllers.set(audio, cancel);

                    if (useRaf) {
                        rafId = scheduleAnimationFrame(step);
                    } else {
                        timeoutId = window.setTimeout(() => step(performance.now()), 16);
                    }
                };

                const getLoopTargetVolume = (definition, category = 'sfx') => {
                    const base = clamp01((definition.volume ?? 1) * state.masterVolume);
                    if (category === 'music' && !state.musicEnabled) {
                        return 0;
                    }
                    if (category === 'sfx' && !state.sfxEnabled) {
                        return 0;
                    }
                    if (state.muted) {
                        return 0;
                    }
                    return base;
                };

                const prepareLoopForPlayback = (audio, definition, category = 'sfx') => {
                    if (!audio) {
                        return;
                    }

                    clearStopTimer(audio);
                    stopExistingFade(audio);

                    const target = getLoopTargetVolume(definition, category);
                    if (audio.paused) {
                        audio.volume = 0;
                    } else {
                        audio.volume = Math.min(audio.volume ?? target, target);
                    }
                };

                const fadeOutLoop = (audio, duration, { reset = true } = {}) => {
                    if (!audio) {
                        return;
                    }

                    stopExistingFade(audio);
                    clearStopTimer(audio);

                    if (duration <= 0) {
                        audio.volume = 0;
                        if (!audio.paused) {
                            audio.pause();
                        }
                        if (reset) {
                            try {
                                audio.currentTime = 0;
                            } catch {
                                // Ignore reset failures
                            }
                        }
                        return;
                    }

                    fadeAudio(audio, 0, duration);
                    const stopDelay = duration + 32;
                    const timerId = window.setTimeout(() => {
                        stopTimers.delete(audio);
                        try {
                            audio.volume = 0;
                            if (!audio.paused) {
                                audio.pause();
                            }
                            if (reset) {
                                audio.currentTime = 0;
                            }
                        } catch {
                            // Ignore errors when pausing/resetting
                        }
                    }, stopDelay);
                    stopTimers.set(audio, timerId);
                };

                const attemptPlayLoop = (audio, definition, category = 'sfx') => {
                    if (!audio || !state.unlocked || state.muted) {
                        return false;
                    }
                    if (category === 'music' && !state.musicEnabled) {
                        return false;
                    }
                    if (category === 'sfx' && !state.sfxEnabled) {
                        return false;
                    }

                    prepareLoopForPlayback(audio, definition, category);
                    const playPromise = audio.play();
                    if (playPromise?.catch) {
                        playPromise.catch(() => undefined);
                    }
                    fadeAudio(audio, getLoopTargetVolume(definition, category), 320);
                    return true;
                };

                if (isSupported) {
                    try {
                        const musicSrc = resolveAudioSource(musicDefinition);
                        if (musicSrc) {
                            gameplayMusic = new Audio(musicSrc);
                            gameplayMusic.preload = 'auto';
                            gameplayMusic.crossOrigin = 'anonymous';
                            gameplayMusic.loop = true;
                            gameplayMusic.volume = clamp01((musicDefinition.volume ?? 1) * state.masterVolume);
                            gameplayMusic.addEventListener('error', () => {
                                gameplayMusic = null;
                                shouldResumeGameplayMusic = false;
                            });
                        }
                    } catch {
                        gameplayMusic = null;
                    }

                    try {
                        const hyperBeamSrc = resolveAudioSource(hyperBeamDefinition);
                        if (hyperBeamSrc) {
                            hyperBeamAudio = new Audio(hyperBeamSrc);
                            hyperBeamAudio.preload = 'auto';
                            hyperBeamAudio.crossOrigin = 'anonymous';
                            hyperBeamAudio.loop = true;
                            hyperBeamAudio.volume = clamp01((hyperBeamDefinition.volume ?? 1) * state.masterVolume);
                            hyperBeamAudio.addEventListener('error', () => {
                                hyperBeamAudio = null;
                                shouldResumeHyperBeam = false;
                            });
                        }
                    } catch {
                        hyperBeamAudio = null;
                        shouldResumeHyperBeam = false;
                    }
                }

                function createSoundPool(definition) {
                    const { voices = 4 } = definition;
                    const src = resolveAudioSource(definition);
                    const elements = [];
                    let disabled = !src || !isSupported;

                    if (!disabled) {
                        for (let i = 0; i < voices; i++) {
                            try {
                                const audio = new Audio(src);
                                audio.preload = 'auto';
                                audio.crossOrigin = 'anonymous';
                                audio.volume = clamp01((definition.volume ?? 1) * state.masterVolume);
                                if (typeof audio.load === 'function') {
                                    audio.load();
                                }
                                audio.addEventListener('error', () => {
                                    disabled = true;
                                });
                                elements.push(audio);
                            } catch {
                                disabled = true;
                                break;
                            }
                        }
                    }

                    let index = 0;

                    const applyVolume = () => {
                        const base = clamp01((definition.volume ?? 1) * state.masterVolume);
                        const finalVolume = state.sfxEnabled && !state.muted ? base : 0;
                        for (const audio of elements) {
                            audio.volume = finalVolume;
                        }
                    };

                    applyVolume();

                    return {
                        play() {
                            if (!isSupported || disabled || state.muted || !state.unlocked || !state.sfxEnabled) {
                                return;
                            }

                            const audio = elements[index];
                            index = (index + 1) % elements.length;
                            if (!audio) return;

                            clearStopTimer(audio);
                            stopExistingFade(audio);
                            audio.volume = clamp01((definition.volume ?? 1) * state.masterVolume);
                            try {
                                audio.currentTime = 0;
                            } catch {
                                // Ignore if resetting currentTime fails
                            }

                            const playPromise = audio.play();
                            if (playPromise?.catch) {
                                playPromise.catch(() => undefined);
                            }
                        },
                        updateVolume: applyVolume
                    };
                }

                function updateAllPoolVolumes() {
                    for (const pool of pools.values()) {
                        if (typeof pool?.updateVolume === 'function') {
                            pool.updateVolume();
                        }
                    }
                }

                function getPool(category, key) {
                    const definition = soundDefinitions[category]?.[key];
                    if (!definition) {
                        return null;
                    }

                    const mapKey = `${category}:${key}`;
                    if (!pools.has(mapKey)) {
                        pools.set(mapKey, createSoundPool(definition));
                    }
                    return pools.get(mapKey);
                }

                function play(category, key, fallbackKey) {
                    if (!isSupported || state.muted || !state.sfxEnabled) return;
                    const pool = getPool(category, key) ?? (fallbackKey ? getPool(category, fallbackKey) : null);
                    pool?.play();
                }

                function updateGameplayMusicVolume({ immediate = false } = {}) {
                    if (!gameplayMusic) return;
                    const target = getLoopTargetVolume(musicDefinition, 'music');
                    if (immediate) {
                        stopExistingFade(gameplayMusic);
                        clearStopTimer(gameplayMusic);
                        gameplayMusic.volume = target;
                    } else {
                        fadeAudio(gameplayMusic, target, 200);
                    }
                }

                function updateHyperBeamVolume({ immediate = false } = {}) {
                    if (!hyperBeamAudio) return;
                    const target = getLoopTargetVolume(hyperBeamDefinition, 'sfx');
                    if (immediate) {
                        stopExistingFade(hyperBeamAudio);
                        clearStopTimer(hyperBeamAudio);
                        hyperBeamAudio.volume = target;
                    } else {
                        fadeAudio(hyperBeamAudio, target, 200);
                    }
                }

                function attemptPlayGameplayMusic() {
                    if (!attemptPlayLoop(gameplayMusic, musicDefinition, 'music')) {
                        return;
                    }
                }

                function attemptPlayHyperBeam() {
                    if (!attemptPlayLoop(hyperBeamAudio, hyperBeamDefinition, 'sfx')) {
                        return;
                    }
                }

                function playGameplayMusic() {
                    if (!isSupported || !gameplayMusic || !state.musicEnabled) {
                        shouldResumeGameplayMusic = false;
                        return;
                    }
                    shouldResumeGameplayMusic = true;
                    clearStopTimer(gameplayMusic);
                    try {
                        gameplayMusic.currentTime = 0;
                    } catch {
                        // Ignore if resetting currentTime fails (e.g., not yet loaded)
                    }
                    attemptPlayGameplayMusic();
                }

                function stopGameplayMusic({ reset = true } = {}) {
                    shouldResumeGameplayMusic = false;
                    if (!gameplayMusic) {
                        return;
                    }
                    fadeOutLoop(gameplayMusic, 220, { reset });
                }

                function playHyperBeam() {
                    if (!isSupported || !hyperBeamAudio || !state.sfxEnabled) {
                        shouldResumeHyperBeam = false;
                        return;
                    }
                    shouldResumeHyperBeam = true;
                    clearStopTimer(hyperBeamAudio);
                    try {
                        hyperBeamAudio.currentTime = 0;
                    } catch {
                        // Ignore if resetting currentTime fails (e.g., not yet loaded)
                    }
                    attemptPlayHyperBeam();
                }

                function stopHyperBeam({ reset = true } = {}) {
                    shouldResumeHyperBeam = false;
                    if (!hyperBeamAudio) {
                        return;
                    }
                    fadeOutLoop(hyperBeamAudio, 200, { reset });
                }

                function suspendForVisibilityChange() {
                    if (!isSupported) {
                        return;
                    }

                    resumeGameplayAfterVisibility = shouldResumeGameplayMusic && !!(gameplayMusic && !gameplayMusic.paused);
                    resumeHyperAfterVisibility = shouldResumeHyperBeam && !!(hyperBeamAudio && !hyperBeamAudio.paused);

                    if (resumeGameplayAfterVisibility) {
                        fadeOutLoop(gameplayMusic, 140, { reset: false });
                    }
                    if (resumeHyperAfterVisibility) {
                        fadeOutLoop(hyperBeamAudio, 140, { reset: false });
                    }
                }

                function resumeAfterVisibilityChange() {
                    if (!isSupported) {
                        return;
                    }

                    if (resumeGameplayAfterVisibility) {
                        attemptPlayGameplayMusic();
                        resumeGameplayAfterVisibility = false;
                    }
                    if (resumeHyperAfterVisibility) {
                        attemptPlayHyperBeam();
                        resumeHyperAfterVisibility = false;
                    }
                }

                function unlock() {
                    if (state.unlocked) return;
                    state.unlocked = true;
                    if (shouldResumeGameplayMusic) {
                        attemptPlayGameplayMusic();
                    }
                    if (shouldResumeHyperBeam) {
                        attemptPlayHyperBeam();
                    }
                }

                function setMasterVolume(volume) {
                    const numeric = Number.parseFloat(volume);
                    const clamped = Number.isFinite(numeric) ? clamp01(numeric) : state.masterVolume;
                    if (Math.abs(clamped - state.masterVolume) < 0.001) {
                        return state.masterVolume;
                    }
                    state.masterVolume = clamped;
                    updateGameplayMusicVolume({ immediate: true });
                    updateHyperBeamVolume({ immediate: true });
                    updateAllPoolVolumes();
                    return state.masterVolume;
                }

                function toggleMusic(forceValue) {
                    const next = typeof forceValue === 'boolean' ? forceValue : !state.musicEnabled;
                    if (state.musicEnabled === next) {
                        updateGameplayMusicVolume({ immediate: true });
                        return state.musicEnabled;
                    }
                    state.musicEnabled = next;
                    if (!state.musicEnabled) {
                        stopGameplayMusic({ reset: false });
                        updateGameplayMusicVolume({ immediate: true });
                    } else {
                        shouldResumeGameplayMusic = true;
                        updateGameplayMusicVolume({ immediate: true });
                        if (state.unlocked) {
                            attemptPlayGameplayMusic();
                        }
                    }
                    return state.musicEnabled;
                }

                function toggleSfx(forceValue) {
                    const next = typeof forceValue === 'boolean' ? forceValue : !state.sfxEnabled;
                    if (state.sfxEnabled === next) {
                        updateHyperBeamVolume({ immediate: true });
                        updateAllPoolVolumes();
                        return state.sfxEnabled;
                    }
                    const wasHyperActive = shouldResumeHyperBeam;
                    state.sfxEnabled = next;
                    if (!state.sfxEnabled) {
                        stopHyperBeam({ reset: false });
                        updateHyperBeamVolume({ immediate: true });
                    } else {
                        shouldResumeHyperBeam = wasHyperActive;
                        updateHyperBeamVolume({ immediate: true });
                        updateAllPoolVolumes();
                        if (shouldResumeHyperBeam && state.unlocked) {
                            attemptPlayHyperBeam();
                        }
                    }
                    if (!state.sfxEnabled) {
                        updateAllPoolVolumes();
                    }
                    return state.sfxEnabled;
                }

                const getMasterVolume = () => state.masterVolume;
                const isMusicEnabled = () => state.musicEnabled;
                const isSfxEnabled = () => state.sfxEnabled;

                return {
                    playProjectile(type) {
                        play('projectile', type, 'standard');
                    },
                    playCollect(type = 'point') {
                        play('collect', type, 'point');
                    },
                    playExplosion(type) {
                        play('explosion', type, 'generic');
                    },
                    playGameplayMusic,
                    stopGameplayMusic,
                    playHyperBeam,
                    stopHyperBeam,
                    suspendForVisibilityChange,
                    resumeAfterVisibilityChange,
                    unlock,
                    setMasterVolume,
                    toggleMusic,
                    toggleSfx,
                    getMasterVolume,
                    isMusicEnabled,
                    isSfxEnabled
                };
            })();

            window.addEventListener('pointerdown', audioManager.unlock, { once: true });
            window.addEventListener('keydown', audioManager.unlock, { once: true });
            if (typeof window !== 'undefined' && 'ontouchstart' in window) {
                window.addEventListener('touchstart', audioManager.unlock, { once: true });
            }

            const handleAudioSuspend = () => {
                audioManager.suspendForVisibilityChange();
            };
            const handleAudioResume = () => {
                audioManager.resumeAfterVisibilityChange();
            };

            window.addEventListener('blur', handleAudioSuspend);
            window.addEventListener('focus', handleAudioResume);

            if (typeof document !== 'undefined' && typeof document.addEventListener === 'function') {
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) {
                        handleAudioSuspend();
                    } else {
                        handleAudioResume();
                    }
                });
            }

            const assetOverrides =
                typeof window !== 'undefined' && window.NYAN_ASSET_OVERRIDES && typeof window.NYAN_ASSET_OVERRIDES === 'object'
                    ? window.NYAN_ASSET_OVERRIDES
                    : {};
            const gameplayOverrides =
                typeof window !== 'undefined' && window.NYAN_GAMEPLAY_OVERRIDES && typeof window.NYAN_GAMEPLAY_OVERRIDES === 'object'
                    ? window.NYAN_GAMEPLAY_OVERRIDES
                    : null;
            const cosmeticOverrides =
                assetOverrides.cosmetics && typeof assetOverrides.cosmetics === 'object'
                    ? assetOverrides.cosmetics
                    : {};

            const isPlainObject = (value) => Object.prototype.toString.call(value) === '[object Object]';

            function cloneConfig(value) {
                if (Array.isArray(value)) {
                    return value.map((item) => cloneConfig(item));
                }
                if (isPlainObject(value)) {
                    const cloned = {};
                    for (const [key, child] of Object.entries(value)) {
                        cloned[key] = cloneConfig(child);
                    }
                    return cloned;
                }
                return value;
            }

            function applyOverrides(base, overrides) {
                if (!isPlainObject(overrides)) {
                    return base;
                }
                for (const [key, value] of Object.entries(overrides)) {
                    if (value == null) {
                        continue;
                    }
                    if (Array.isArray(value)) {
                        const currentBaseArray = Array.isArray(base[key]) ? base[key] : [];
                        base[key] = value.map((item, index) => {
                            if (isPlainObject(item)) {
                                const baseItem = isPlainObject(currentBaseArray[index]) ? currentBaseArray[index] : {};
                                return applyOverrides(cloneConfig(baseItem), item);
                            }
                            return cloneConfig(item);
                        });
                        continue;
                    }
                    if (isPlainObject(value)) {
                        const baseValue = isPlainObject(base[key]) ? base[key] : {};
                        base[key] = applyOverrides(cloneConfig(baseValue), value);
                        continue;
                    }
                    base[key] = value;
                }
                return base;
            }

            function resolveAssetConfig(override, defaultSrc) {
                if (override == null) {
                    return defaultSrc;
                }

                if (typeof override === 'string') {
                    return override.trim() || defaultSrc;
                }

                if (typeof override === 'object') {
                    const config = { ...override };
                    if ((!config.src || typeof config.src !== 'string' || !config.src.trim()) && defaultSrc) {
                        config.src = defaultSrc;
                    }
                    if (typeof config.src === 'string') {
                        config.src = config.src.trim();
                        if (!config.src) {
                            delete config.src;
                        }
                    }
                    if (typeof config.fallback === 'string') {
                        config.fallback = config.fallback.trim();
                        if (!config.fallback) {
                            delete config.fallback;
                        }
                    }
                    return config;
                }

                return defaultSrc;
            }

            const defaultBackgrounds = ['assets/background1.png', 'assets/background2.png', 'assets/background3.png'];
            const backgroundOverrideEntries =
                Array.isArray(assetOverrides.backgrounds) && assetOverrides.backgrounds.length
                    ? assetOverrides.backgrounds
                    : defaultBackgrounds;
            let backgroundImages = backgroundOverrideEntries
                .map((entry, index) => resolveAssetConfig(entry, defaultBackgrounds[index % defaultBackgrounds.length]))
                .map((config) => (typeof config === 'string' ? config : config?.src))
                .filter((src) => typeof src === 'string' && src.length);
            if (backgroundImages.length === 0) {
                backgroundImages = [...defaultBackgrounds];
            }
            const backgroundLayers = [
                document.getElementById('backgroundLayerA'),
                document.getElementById('backgroundLayerB')
            ];
            const backgroundChangeInterval = 20000;
            let currentBackgroundIndex = 0;
            let activeLayerIndex = 0;

            const scoreEl = document.getElementById('score');
            const nyanEl = document.getElementById('nyan');
            const streakEl = document.getElementById('streak');
            const bestStreakEl = document.getElementById('bestStreak');
            const mcapEl = document.getElementById('mcap');
            const volEl = document.getElementById('vol');
            const powerUpsEl = document.getElementById('powerUps');
            const comboFillEl = document.getElementById('comboFill');
            const comboMeterEl = document.getElementById('comboMeter');
            const joystickZone = document.getElementById('joystickZone');
            const joystickThumb = joystickZone?.querySelector('.joystick-thumb') ?? null;
            const fireButton = document.getElementById('fireButton');
            const touchControls = document.getElementById('touchControls');
            const debugOverlayEl = document.getElementById('debugOverlay');
            const debugOverlayLines = debugOverlayEl
                ? {
                    logical: debugOverlayEl.querySelector('[data-debug-line="logical"]'),
                    physical: debugOverlayEl.querySelector('[data-debug-line="physical"]'),
                    ratio: debugOverlayEl.querySelector('[data-debug-line="ratio"]')
                }
                : {};

            const overlay = document.getElementById('overlay');
            const overlayMessage = document.getElementById('overlayMessage');
            const overlayButton = document.getElementById('overlayButton');
            const overlaySecondaryButton = document.getElementById('overlaySecondaryButton');
            const callsignForm = document.getElementById('callsignForm');
            const playerNameInput = document.getElementById('playerNameInput');
            const callsignHint = document.getElementById('callsignHint');
            const preflightPrompt = document.getElementById('preflightPrompt');
            const mobilePreflightButton = document.getElementById('mobilePreflightButton');
            const comicIntro = document.getElementById('comicIntro');
            const overlayTitle = overlay?.querySelector('h1') ?? null;
            const overlayDefaultTitle = overlayTitle?.textContent ?? '';
            const overlayDefaultMessage = overlayMessage?.textContent ?? '';
            const loadingScreen = document.getElementById('loadingScreen');
            const loadingStatus = document.getElementById('loadingStatus');
            const loadingImageEl = document.getElementById('loadingImage');
            const timerValueEl = document.getElementById('timerValue');
            const highScoreListEl = document.getElementById('highScoreList');
            const highScoreTitleEl = document.getElementById('highScoreTitle');
            const leaderboardTitleEl = document.getElementById('leaderboardTitle');
            const leaderboardListEl = document.getElementById('leaderboardList');
            const leaderboardStatusEl = document.getElementById('leaderboardStatus');
            const leaderboardTabButtons = Array.from(
                document.querySelectorAll('[data-leaderboard-scope]')
            );
            const shareButton = document.getElementById('shareButton');
            const copyShareButton = document.getElementById('copyShareButton');
            const shareStatusEl = document.getElementById('shareStatus');
            const socialFeedEl = document.getElementById('socialFeed');
            const intelLogEl = document.getElementById('intelLog');
            const challengeListEl = document.getElementById('challengeList');
            const skinOptionsEl = document.getElementById('skinOptions');
            const trailOptionsEl = document.getElementById('trailOptions');
            const instructionsEl = document.getElementById('instructions');
            const instructionNavEl = document.getElementById('instructionNav');
            const instructionPanelsEl = document.getElementById('instructionPanels');
            const settingsButton = document.getElementById('settingsButton');
            const settingsDrawer = document.getElementById('settingsDrawer');
            const settingsCloseButton = document.getElementById('settingsCloseButton');
            const masterVolumeSlider = document.getElementById('masterVolumeSlider');
            const masterVolumeValue = document.getElementById('masterVolumeValue');
            const musicToggle = document.getElementById('musicToggle');
            const musicToggleStatus = document.getElementById('musicToggleStatus');
            const sfxToggle = document.getElementById('sfxToggle');
            const sfxToggleStatus = document.getElementById('sfxToggleStatus');
            const reducedEffectsToggle = document.getElementById('reducedEffectsToggle');
            const reducedEffectsStatus = document.getElementById('reducedEffectsStatus');
            const bodyElement = document.body;
            let reducedEffectsMode = false;
            const instructionLinks = instructionNavEl
                ? Array.from(instructionNavEl.querySelectorAll('a[data-panel-target]'))
                : [];
            const instructionPanelNodes = instructionPanelsEl
                ? Array.from(instructionPanelsEl.children).filter((node) => node instanceof HTMLElement)
                : [];
            const coarsePointerQuery =
                typeof window !== 'undefined' && typeof window.matchMedia === 'function'
                    ? window.matchMedia('(pointer: coarse)')
                    : null;
            let isTouchInterface = coarsePointerQuery?.matches ?? ('ontouchstart' in window);
            const TOUCH_SMOOTHING_RATE = 26;
            const DEBUG_OVERLAY_STORAGE_KEY = 'nyanEscape.debugOverlay';
            const TARGET_ASPECT_RATIO = 3 / 2;
            const viewport = {
                width: 900,
                height: 600,
                cssWidth: 900,
                cssHeight: 600,
                physicalWidth: 900,
                physicalHeight: 600,
                dpr: window.devicePixelRatio || 1
            };

            let debugOverlayEnabled = false;
            let player = null;
            try {
                debugOverlayEnabled = window.localStorage.getItem(DEBUG_OVERLAY_STORAGE_KEY) === '1';
            } catch {
                debugOverlayEnabled = false;
            }

            let pendingResizeFrame = null;
            let devicePixelRatioQuery = null;

            function measureElementSize(element) {
                if (!element) {
                    return { width: 0, height: 0 };
                }
                const rect = element.getBoundingClientRect();
                if (rect.width > 0 && rect.height > 0) {
                    return { width: rect.width, height: rect.height };
                }
                const computed = window.getComputedStyle(element);
                const width = parseFloat(computed.width) || element.offsetWidth || 0;
                const height = parseFloat(computed.height) || element.offsetHeight || 0;
                return { width, height };
            }

            function updateTouchControlsLayout() {
                if (!touchControls || !canvas) {
                    return;
                }

                const viewportHeight = window.visualViewport?.height ?? window.innerHeight ?? 0;
                const viewportOffsetTop = window.visualViewport?.offsetTop ?? 0;
                const canvasRect = canvas.getBoundingClientRect();
                const bottomInset = Math.max(16, viewportHeight + viewportOffsetTop - canvasRect.bottom + 16);
                touchControls.style.setProperty('--touch-bottom', `${Math.round(bottomInset)}px`);

                const spacing = Math.max(16, Math.min(canvasRect.width * 0.08, 48));

                if (joystickZone) {
                    const { width: joystickWidth } = measureElementSize(joystickZone);
                    const availableLeft = canvasRect.left;
                    let joystickLeft;
                    if (availableLeft >= joystickWidth + spacing + 16) {
                        joystickLeft = availableLeft - joystickWidth - spacing;
                    } else {
                        joystickLeft = canvasRect.left + spacing;
                        if (joystickLeft + joystickWidth > window.innerWidth - 16) {
                            joystickLeft = Math.max(16, window.innerWidth * 0.5 - joystickWidth * 0.5);
                        }
                    }
                    touchControls.style.setProperty('--joystick-left', `${Math.round(joystickLeft)}px`);
                }

                if (fireButton) {
                    const { width: fireWidth } = measureElementSize(fireButton);
                    const availableRight = Math.max(0, window.innerWidth - canvasRect.right);
                    if (availableRight >= fireWidth + spacing + 16) {
                        const fireRight = Math.max(16, availableRight - spacing);
                        touchControls.style.setProperty('--fire-right', `${Math.round(fireRight)}px`);
                        touchControls.style.setProperty('--fire-left', 'auto');
                    } else {
                        let fireLeft = canvasRect.right - fireWidth - spacing;
                        if (fireLeft < 16) {
                            fireLeft = Math.max(16, canvasRect.left + canvasRect.width - fireWidth - spacing);
                        }
                        if (fireLeft + fireWidth > window.innerWidth - 16) {
                            fireLeft = Math.max(16, window.innerWidth - fireWidth - 16);
                        }
                        touchControls.style.setProperty('--fire-left', `${Math.round(fireLeft)}px`);
                        touchControls.style.setProperty('--fire-right', 'auto');
                    }
                }
            }

            function updateDebugOverlay() {
                if (!debugOverlayEl) {
                    return;
                }

                if (!debugOverlayEnabled) {
                    debugOverlayEl.classList.add('hidden');
                    debugOverlayEl.setAttribute('hidden', '');
                    return;
                }

                debugOverlayEl.classList.remove('hidden');
                debugOverlayEl.removeAttribute('hidden');

                if (debugOverlayLines.logical) {
                    debugOverlayLines.logical.textContent = `Logical: ${Math.round(viewport.width)}  ${Math.round(viewport.height)}`;
                }
                if (debugOverlayLines.physical) {
                    debugOverlayLines.physical.textContent = `Physical: ${viewport.physicalWidth}  ${viewport.physicalHeight}`;
                }
                if (debugOverlayLines.ratio) {
                    debugOverlayLines.ratio.textContent = `devicePixelRatio: ${viewport.dpr.toFixed(2)} (CSS: ${Math.round(viewport.cssWidth)}  ${Math.round(viewport.cssHeight)})`;
                }
            }

            function setDebugOverlayEnabled(enabled) {
                debugOverlayEnabled = Boolean(enabled);
                try {
                    if (debugOverlayEnabled) {
                        window.localStorage.setItem(DEBUG_OVERLAY_STORAGE_KEY, '1');
                    } else {
                        window.localStorage.removeItem(DEBUG_OVERLAY_STORAGE_KEY);
                    }
                } catch {
                    // Ignore storage errors
                }
                updateDebugOverlay();
            }

            function toggleDebugOverlay() {
                setDebugOverlayEnabled(!debugOverlayEnabled);
            }

            function measureAvailableCanvasSize() {
                const parent = canvas?.parentElement ?? null;
                const parentRect = parent?.getBoundingClientRect();
                const availableWidth = Math.max(240, Math.floor(parentRect?.width ?? window.innerWidth ?? viewport.width));
                let availableHeight = Math.floor((window.innerHeight ?? viewport.height) - (parentRect?.top ?? 0) - 32);
                if (!Number.isFinite(availableHeight) || availableHeight <= 0) {
                    availableHeight = Math.max(240, Math.floor((window.innerHeight ?? viewport.height) * 0.8));
                }
                return { width: availableWidth, height: Math.max(240, availableHeight) };
            }

            function rescaleWorld(previousWidth, previousHeight, nextWidth, nextHeight) {
                if (!previousWidth || !previousHeight || previousWidth === nextWidth || previousHeight === nextHeight) {
                    return;
                }
                const scaleX = nextWidth / previousWidth;
                const scaleY = nextHeight / previousHeight;

                if (Number.isFinite(scaleX) && Number.isFinite(scaleY)) {
                    if (player) {
                        player.x *= scaleX;
                        player.y *= scaleY;
                        const verticalBleed = nextHeight * (config?.player?.verticalBleed ?? 0);
                        player.x = clamp(player.x, 0, Math.max(0, nextWidth - player.width));
                        player.y = clamp(
                            player.y,
                            -verticalBleed,
                            Math.max(0, nextHeight - player.height + verticalBleed)
                        );
                    }

                    for (const star of stars) {
                        star.x *= scaleX;
                        star.y *= scaleY;
                        star.x = Math.max(-star.size, Math.min(nextWidth + star.size, star.x));
                        star.y = Math.max(0, Math.min(nextHeight, star.y));
                    }

                    for (const asteroid of asteroids) {
                        asteroid.x *= scaleX;
                        asteroid.y = clamp(asteroid.y * scaleY, asteroid.radius, nextHeight - asteroid.radius);
                        const maxX = nextWidth + (config?.asteroid?.clusterRadius ?? 160);
                        asteroid.x = Math.min(asteroid.x, maxX);
                    }
                }
            }

            function updateViewportMetrics({ preserveEntities = true } = {}) {
                if (!canvas || !ctx) {
                    return;
                }

                const previousWidth = viewport.width;
                const previousHeight = viewport.height;
                const available = measureAvailableCanvasSize();

                let cssWidth = Math.min(available.width, available.height * TARGET_ASPECT_RATIO);
                if (!Number.isFinite(cssWidth) || cssWidth <= 0) {
                    cssWidth = viewport.width;
                }
                if (cssWidth < 240) {
                    cssWidth = Math.min(available.width, 240);
                }
                let cssHeight = cssWidth / TARGET_ASPECT_RATIO;
                if (cssHeight > available.height) {
                    cssHeight = available.height;
                    cssWidth = cssHeight * TARGET_ASPECT_RATIO;
                }

                const dpr = Math.max(1, Math.min(4, window.devicePixelRatio || 1));
                const physicalWidth = Math.max(1, Math.round(cssWidth * dpr));
                const physicalHeight = Math.max(1, Math.round(cssHeight * dpr));

                canvas.style.width = `${cssWidth}px`;
                canvas.style.height = `${cssHeight}px`;

                if (canvas.width !== physicalWidth) {
                    canvas.width = physicalWidth;
                }
                if (canvas.height !== physicalHeight) {
                    canvas.height = physicalHeight;
                }

                viewport.width = cssWidth;
                viewport.height = cssHeight;
                viewport.cssWidth = cssWidth;
                viewport.cssHeight = cssHeight;
                viewport.physicalWidth = physicalWidth;
                viewport.physicalHeight = physicalHeight;
                viewport.dpr = dpr;

                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                enableHighQualitySmoothing(ctx);

                if (preserveEntities) {
                    rescaleWorld(previousWidth, previousHeight, cssWidth, cssHeight);
                }

                updateTouchControlsLayout();
                updateDebugOverlay();
            }

            function requestViewportUpdate() {
                if (pendingResizeFrame !== null) {
                    return;
                }
                pendingResizeFrame = window.requestAnimationFrame(() => {
                    pendingResizeFrame = null;
                    updateViewportMetrics();
                });
            }

            function cleanupDevicePixelRatioWatcher() {
                if (!devicePixelRatioQuery) {
                    return;
                }
                if (typeof devicePixelRatioQuery.removeEventListener === 'function') {
                    devicePixelRatioQuery.removeEventListener('change', handleDevicePixelRatioChange);
                } else if (typeof devicePixelRatioQuery.removeListener === 'function') {
                    devicePixelRatioQuery.removeListener(handleDevicePixelRatioChange);
                }
                devicePixelRatioQuery = null;
            }

            function handleDevicePixelRatioChange() {
                cleanupDevicePixelRatioWatcher();
                requestViewportUpdate();
                watchDevicePixelRatio();
            }

            function watchDevicePixelRatio() {
                if (typeof window === 'undefined' || typeof window.matchMedia !== 'function') {
                    return;
                }
                cleanupDevicePixelRatioWatcher();
                const dpr = window.devicePixelRatio || 1;
                const query = window.matchMedia(`(resolution: ${dpr}dppx)`);
                if (typeof query.addEventListener === 'function') {
                    query.addEventListener('change', handleDevicePixelRatioChange, { once: true });
                } else if (typeof query.addListener === 'function') {
                    query.addListener(handleDevicePixelRatioChange);
                }
                devicePixelRatioQuery = query;
            }

            updateViewportMetrics({ preserveEntities: false });
            watchDevicePixelRatio();
            updateDebugOverlay();

            window.addEventListener('resize', requestViewportUpdate);
            window.addEventListener('orientationchange', requestViewportUpdate);
            if (window.visualViewport) {
                window.visualViewport.addEventListener('resize', requestViewportUpdate);
                window.visualViewport.addEventListener('scroll', requestViewportUpdate);
            }

            const getLaunchControlText = () => (isTouchInterface ? 'Tap Start' : 'Press Start (Enter)');
            const getRetryControlText = () => (isTouchInterface ? 'Tap Start Again' : 'Press Start (Enter) Again');

            function refreshInteractionHints() {
                if (bodyElement) {
                    bodyElement.classList.toggle('touch-enabled', isTouchInterface);
                }
                if (mobilePreflightButton) {
                    mobilePreflightButton.hidden = !isTouchInterface;
                    mobilePreflightButton.setAttribute('aria-hidden', isTouchInterface ? 'false' : 'true');
                    mobilePreflightButton.textContent = isTouchInterface ? 'Tap Start' : 'Press Start';
                    const promptVisible = preflightPrompt && !preflightPrompt.hidden;
                    mobilePreflightButton.disabled = !promptVisible || !isTouchInterface;
                }
                if (callsignHint) {
                    callsignHint.textContent = isTouchInterface
                        ? 'Tap Start to begin a run.'
                        : 'Press Start (Enter) or click Launch to begin a run.';
                }
                updateTouchControlsLayout();
            }

            refreshInteractionHints();

            if (coarsePointerQuery) {
                const handleCoarsePointerChange = (event) => {
                    if (isTouchInterface !== event.matches) {
                        isTouchInterface = event.matches;
                        refreshInteractionHints();
                    }
                };
                if (typeof coarsePointerQuery.addEventListener === 'function') {
                    coarsePointerQuery.addEventListener('change', handleCoarsePointerChange);
                } else if (typeof coarsePointerQuery.addListener === 'function') {
                    coarsePointerQuery.addListener(handleCoarsePointerChange);
                }
            } else if (typeof window !== 'undefined') {
                window.addEventListener(
                    'touchstart',
                    () => {
                        if (!isTouchInterface) {
                            isTouchInterface = true;
                            refreshInteractionHints();
                        }
                    },
                    { once: true, passive: true }
                );
            }
            const mobileInstructionQuery = window.matchMedia('(max-width: 768px)');
            let isMobileInstructionLayout = mobileInstructionQuery.matches;

            const syncInstructionPanels = (activePanelId) => {
                if (!instructionsEl) {
                    return;
                }

                if (isMobileInstructionLayout && activePanelId) {
                    instructionsEl.setAttribute('data-mobile-open', activePanelId);
                } else {
                    instructionsEl.removeAttribute('data-mobile-open');
                }

                instructionLinks.forEach((link) => {
                    const targetId = link.dataset.panelTarget;
                    const isActive = Boolean(activePanelId) && targetId === activePanelId && isMobileInstructionLayout;
                    link.classList.toggle('mobile-active', isActive);
                    if (isMobileInstructionLayout) {
                        link.setAttribute('aria-expanded', String(isActive));
                        link.setAttribute('aria-selected', String(isActive));
                    } else {
                        link.setAttribute('aria-expanded', 'false');
                        link.removeAttribute('aria-selected');
                    }
                });

                instructionPanelNodes.forEach((panel) => {
                    if (!(panel instanceof HTMLElement)) {
                        return;
                    }

                    if (isMobileInstructionLayout) {
                        const isActive = Boolean(activePanelId) && panel.id === activePanelId;
                        panel.setAttribute('aria-hidden', String(!isActive));
                    } else {
                        panel.removeAttribute('aria-hidden');
                    }
                });
            };

            const resetInstructionPanels = () => {
                syncInstructionPanels(null);
            };

            if (instructionNavEl && instructionsEl && instructionPanelsEl) {
                instructionLinks.forEach((link) => {
                    link.addEventListener('click', (event) => {
                        const targetId = link.dataset.panelTarget;
                        if (!targetId) {
                            return;
                        }

                        if (isMobileInstructionLayout) {
                            event.preventDefault();
                            const currentOpen = instructionsEl.getAttribute('data-mobile-open');
                            if (currentOpen === targetId) {
                                syncInstructionPanels(null);
                            } else {
                                syncInstructionPanels(targetId);
                            }
                        }
                    });
                });

                const handleInstructionLayoutChange = (event) => {
                    isMobileInstructionLayout = event.matches;
                    resetInstructionPanels();
                };

                if (typeof mobileInstructionQuery.addEventListener === 'function') {
                    mobileInstructionQuery.addEventListener('change', handleInstructionLayoutChange);
                } else if (typeof mobileInstructionQuery.addListener === 'function') {
                    mobileInstructionQuery.addListener(handleInstructionLayoutChange);
                }

                resetInstructionPanels();
            }

            const intelLoreEntries = [
                {
                    id: 'mission',
                    unlockMs: 0,
                    title: 'Mission Uplink',
                    text:
                        'Station Echo routed all evac beacons through your hull. Keep combos alive to project a safe corridor.',
                    lockedHint: ''
                },
                {
                    id: 'allySignal',
                    unlockMs: 20000,
                    title: 'Ally Ping',
                    text:
                        'Pixel spotted supply pods shadowing the convoy. Collect Points fast and the pods will spill power cores.',
                    lockedHint: 'Survive 00:20 to decode Auroras priority feed.'
                },
                {
                    id: 'syndicateIntel',
                    unlockMs: 40000,
                    title: 'Syndicate Patterns',
                    text:
                        'Gravity Syndicate wings stagger volleysdash diagonally after each shot to bait their aim wide.',
                    lockedHint: 'Last 00:40 to crack the Syndicate firing matrix.'
                },
                {
                    id: 'reclaimerBrief',
                    unlockMs: 70000,
                    title: 'Void Reclaimer Brief',
                    text:
                        'Void Reclaimers absorb stray bolts until Hyper Beam charge hits 60%. Ride power cores and dump the beam point-blank.',
                    lockedHint: 'Endure 01:10 and Aurora will transmit Reclaimer weak points.'
                },
                {
                    id: 'convoyHope',
                    unlockMs: 100000,
                    title: 'Convoy Hope',
                    text:
                        'Colonists have begun their burn toward daylight. Every extra second you survive widens their escape corridor.',
                    lockedHint: 'Hold for 01:40 to hear the convoy break radio silence.'
                }
            ];

            function formatLoreUnlock(ms) {
                const totalSeconds = Math.max(0, Math.round(ms / 1000));
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }

            intelLoreEntries.forEach((entry) => {
                if (entry.unlockMs === 0) {
                    entry.unlocked = true;
                }
            });

            function renderIntelLog() {
                if (!intelLogEl) {
                    return;
                }
                intelLogEl.innerHTML = '';
                for (const entry of intelLoreEntries) {
                    const item = document.createElement('li');
                    const unlocked = Boolean(entry.unlocked || entry.unlockMs === 0);
                    item.classList.toggle('locked', !unlocked);
                    const title = document.createElement('p');
                    title.className = 'intel-title';
                    title.textContent = entry.title;
                    const body = document.createElement('p');
                    body.className = 'intel-text';
                    if (unlocked) {
                        body.textContent = entry.text;
                    } else {
                        const hint = entry.lockedHint || `Survive ${formatLoreUnlock(entry.unlockMs)} to decode.`;
                        body.textContent = hint;
                    }
                    item.appendChild(title);
                    item.appendChild(body);
                    intelLogEl.appendChild(item);
                }
            }

            let storedLoreProgressMs = 0;

            function updateIntelLore(currentTimeMs) {
                if (!intelLoreEntries.length) {
                    return;
                }
                const effectiveTime = Math.max(currentTimeMs ?? 0, storedLoreProgressMs ?? 0);
                let updated = false;
                for (const entry of intelLoreEntries) {
                    if (!entry.unlocked && effectiveTime >= entry.unlockMs) {
                        entry.unlocked = true;
                        updated = true;
                    }
                }
                if (updated) {
                    storedLoreProgressMs = Math.max(storedLoreProgressMs, effectiveTime);
                    renderIntelLog();
                    if (storageAvailable) {
                        writeStorage(STORAGE_KEYS.loreProgress, String(storedLoreProgressMs));
                    }
                }
            }

            renderIntelLog();

            const hudCache = {
                score: '',
                nyan: '',
                comboMultiplier: '',
                bestTailLength: '',
                marketCap: '',
                volume: '',
                powerUps: ''
            };
            let lastComboPercent = -1;
            let lastFormattedTimer = '';

            const isCanvasElement =
                typeof HTMLCanvasElement !== 'undefined' && canvas instanceof HTMLCanvasElement;

            if (!isCanvasElement || !ctx) {
                console.error('Unable to initialize the Nyan Escape flight deck: canvas support is unavailable.');

                loadingScreen?.classList.add('hidden');
                if (overlay) {
                    overlay.classList.add('unsupported');
                }
                if (overlayTitle) {
                    overlayTitle.textContent = 'Flight Deck Unsupported';
                }
                if (overlayMessage) {
                    overlayMessage.textContent =
                        'Your current browser is missing HTML canvas support, so Nyan Escape cannot launch. ' +
                        'Try again with a modern browser to enter the cosmic corridor.';
                }
                if (overlayButton) {
                    overlayButton.textContent = 'Unavailable';
                    overlayButton.setAttribute('aria-disabled', 'true');
                    overlayButton.disabled = true;
                    if (overlayButton.dataset.launchMode) {
                        delete overlayButton.dataset.launchMode;
                    }
                }
                if (intelLogEl) {
                    intelLogEl.innerHTML = '';
                    const item = document.createElement('li');
                    item.classList.add('locked');
                    const title = document.createElement('p');
                    title.className = 'intel-title';
                    title.textContent = 'Telemetry Offline';
                    const body = document.createElement('p');
                    body.className = 'intel-text';
                    body.textContent =
                        'Canvas rendering is disabled. Upgrade your browser to restore full mission control visuals.';
                    item.appendChild(title);
                    item.appendChild(body);
                    intelLogEl.appendChild(item);
                }

                return;
            }

            if (loadingImageEl) {
                const defaultLogo = loadingImageEl.getAttribute('src') || 'assets/logo.png';
                const loadingLogoConfig = resolveAssetConfig(assetOverrides.loadingLogo, defaultLogo);
                if (typeof loadingLogoConfig === 'string') {
                    loadingImageEl.src = loadingLogoConfig;
                } else if (loadingLogoConfig && typeof loadingLogoConfig === 'object') {
                    if (loadingLogoConfig.crossOrigin === true) {
                        loadingImageEl.crossOrigin = 'anonymous';
                    } else if (typeof loadingLogoConfig.crossOrigin === 'string' && loadingLogoConfig.crossOrigin) {
                        loadingImageEl.crossOrigin = loadingLogoConfig.crossOrigin;
                    }
                    if (typeof loadingLogoConfig.src === 'string' && loadingLogoConfig.src) {
                        loadingImageEl.src = loadingLogoConfig.src;
                    }
                }
            }

            function createCanvasTexture(width, height, draw) {
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const context = canvas.getContext('2d');
                if (!context) {
                    return null;
                }
                enableHighQualitySmoothing(context);
                draw(context, width, height);
                return canvas.toDataURL('image/png');
            }

            function loadImageWithFallback(config, fallbackFactory) {
                const image = new Image();
                image.decoding = 'async';

                let src = null;
                let fallbackSrc = null;

                if (typeof config === 'string') {
                    src = config;
                } else if (config && typeof config === 'object') {
                    if (config.crossOrigin === true) {
                        image.crossOrigin = 'anonymous';
                    } else if (typeof config.crossOrigin === 'string' && config.crossOrigin) {
                        image.crossOrigin = config.crossOrigin;
                    }

                    if (typeof config.src === 'string' && config.src) {
                        src = config.src;
                    }

                    if (typeof config.fallback === 'string' && config.fallback) {
                        fallbackSrc = config.fallback;
                    }
                }

                if (!fallbackSrc && typeof fallbackFactory === 'function') {
                    fallbackSrc = fallbackFactory() ?? null;
                }

                const assignFallback = () => {
                    if (fallbackSrc) {
                        image.src = fallbackSrc;
                    } else if (!src) {
                        image.removeAttribute('src');
                    }
                };

                if (fallbackSrc && src && src !== fallbackSrc) {
                    const handleError = () => {
                        image.removeEventListener('error', handleError);
                        assignFallback();
                    };
                    image.addEventListener('error', handleError, { once: true });
                }

                if (src) {
                    image.src = src;
                } else {
                    assignFallback();
                }

                return image;
            }

            function createCollectibleFallbackDataUrl(tier) {
                const size = 128;
                const font = '700 28px "Segoe UI", Tahoma, sans-serif';
                return (
                    createCanvasTexture(size, size, (context, width, height) => {
                        context.clearRect(0, 0, width, height);
                        const center = width / 2;
                        const radius = width * 0.42;
                        const glow = tier?.glow ?? {};
                        const innerGlow = glow.inner ?? 'rgba(255, 255, 255, 0.95)';
                        const outerGlow = glow.outer ?? 'rgba(255, 215, 0, 0.28)';
                        const gradient = context.createRadialGradient(
                            center,
                            center,
                            radius * 0.2,
                            center,
                            center,
                            radius
                        );
                        gradient.addColorStop(0, innerGlow);
                        gradient.addColorStop(1, outerGlow);
                        context.fillStyle = gradient;
                        context.beginPath();
                        context.arc(center, center, radius, 0, Math.PI * 2);
                        context.fill();
                        context.lineWidth = 4;
                        context.strokeStyle = 'rgba(255, 255, 255, 0.85)';
                        context.stroke();
                        const label = tier?.label ?? 'POINT';
                        context.font = font;
                        context.textAlign = 'center';
                        context.textBaseline = 'middle';
                        context.fillStyle = 'rgba(15, 23, 42, 0.82)';
                        context.fillText(label, center, center);
                    }) ?? tier?.src
                );
            }

            function createAsteroidFallbackDataUrl(seed = 0) {
                const size = 196;
                return createCanvasTexture(size, size, (context, width, height) => {
                    context.clearRect(0, 0, width, height);
                    context.save();
                    context.translate(width / 2, height / 2);
                    const radius = width * 0.42;
                    const sides = 9;
                    context.beginPath();
                    for (let i = 0; i < sides; i++) {
                        const angle = (i / sides) * Math.PI * 2;
                        const noise = 0.74 + (Math.sin(angle * (seed + 2.3)) + 1) * 0.12;
                        const r = radius * noise;
                        const x = Math.cos(angle) * r;
                        const y = Math.sin(angle) * r;
                        if (i === 0) {
                            context.moveTo(x, y);
                        } else {
                            context.lineTo(x, y);
                        }
                    }
                    context.closePath();
                    const gradient = context.createRadialGradient(0, -radius * 0.25, radius * 0.15, 0, 0, radius);
                    gradient.addColorStop(0, '#f8fafc');
                    gradient.addColorStop(0.6, '#a1a1aa');
                    gradient.addColorStop(1, '#4b5563');
                    context.fillStyle = gradient;
                    context.fill();
                    context.lineWidth = 6;
                    context.strokeStyle = 'rgba(15, 23, 42, 0.45)';
                    context.stroke();

                    const craterCount = 3 + (seed % 3);
                    for (let i = 0; i < craterCount; i++) {
                        const angle = (i / craterCount) * Math.PI * 2;
                        const distance = radius * 0.45;
                        const cx = Math.cos(angle + seed) * distance * 0.55;
                        const cy = Math.sin(angle * 1.2 + seed) * distance * 0.55;
                        const craterRadius = radius * (0.12 + (i / (craterCount + 2)) * 0.12);
                        const craterGradient = context.createRadialGradient(
                            cx,
                            cy,
                            craterRadius * 0.15,
                            cx,
                            cy,
                            craterRadius
                        );
                        craterGradient.addColorStop(0, 'rgba(226, 232, 240, 0.7)');
                        craterGradient.addColorStop(1, 'rgba(15, 23, 42, 0.7)');
                        context.fillStyle = craterGradient;
                        context.beginPath();
                        context.arc(cx, cy, craterRadius, 0, Math.PI * 2);
                        context.fill();
                    }
                    context.restore();
                });
            }

            function createPlayerFallbackDataUrl() {
                const width = 160;
                const height = 120;
                return createCanvasTexture(width, height, (context) => {
                    const gradient = context.createLinearGradient(0, 0, width, height);
                    gradient.addColorStop(0, '#38bdf8');
                    gradient.addColorStop(1, '#6366f1');
                    context.fillStyle = gradient;
                    context.fillRect(0, 0, width, height);

                    context.fillStyle = 'rgba(15, 23, 42, 0.65)';
                    context.beginPath();
                    context.moveTo(width * 0.22, height * 0.78);
                    context.lineTo(width * 0.5, height * 0.18);
                    context.lineTo(width * 0.78, height * 0.78);
                    context.closePath();
                    context.fill();

                    context.fillStyle = '#fdf4ff';
                    context.beginPath();
                    context.ellipse(width * 0.5, height * 0.58, width * 0.28, height * 0.2, 0, 0, Math.PI * 2);
                    context.fill();
                });
            }

            function createPlayerVariantDataUrl(variant) {
                const width = 160;
                const height = 120;
                const palettes = {
                    default: {
                        baseStart: '#38bdf8',
                        baseEnd: '#6366f1',
                        accent: '#fdf4ff',
                        visor: 'rgba(15, 23, 42, 0.65)',
                        glow: 'rgba(125, 211, 252, 0.35)'
                    },
                    midnight: {
                        baseStart: '#0f172a',
                        baseEnd: '#4338ca',
                        accent: '#c7d2fe',
                        visor: 'rgba(12, 19, 38, 0.75)',
                        glow: 'rgba(147, 197, 253, 0.28)'
                    },
                    sunrise: {
                        baseStart: '#fb7185',
                        baseEnd: '#f97316',
                        accent: '#fff7ed',
                        visor: 'rgba(88, 28, 28, 0.6)',
                        glow: 'rgba(252, 211, 77, 0.3)'
                    }
                };
                const palette = palettes[variant] ?? palettes.default;
                return createCanvasTexture(width, height, (context) => {
                    const gradient = context.createLinearGradient(0, 0, width, height);
                    gradient.addColorStop(0, palette.baseStart);
                    gradient.addColorStop(1, palette.baseEnd);
                    context.fillStyle = gradient;
                    context.fillRect(0, 0, width, height);

                    context.fillStyle = palette.visor;
                    context.beginPath();
                    context.moveTo(width * 0.22, height * 0.78);
                    context.lineTo(width * 0.5, height * 0.18);
                    context.lineTo(width * 0.78, height * 0.78);
                    context.closePath();
                    context.fill();

                    if (palette.glow) {
                        const glowGradient = context.createRadialGradient(
                            width * 0.5,
                            height * 0.52,
                            height * 0.12,
                            width * 0.5,
                            height * 0.52,
                            height * 0.4
                        );
                        glowGradient.addColorStop(0, palette.glow);
                        glowGradient.addColorStop(1, 'rgba(15, 23, 42, 0)');
                        context.fillStyle = glowGradient;
                        context.beginPath();
                        context.ellipse(width * 0.5, height * 0.58, width * 0.32, height * 0.26, 0, 0, Math.PI * 2);
                        context.fill();
                    }

                    context.fillStyle = palette.accent;
                    context.beginPath();
                    context.ellipse(width * 0.5, height * 0.58, width * 0.28, height * 0.2, 0, 0, Math.PI * 2);
                    context.fill();
                });
            }

            const villainFallbackPalette = ['#f472b6', '#34d399', '#fde68a'];
            function createVillainFallbackDataUrl(index = 0) {
                const size = 128;
                const baseColor = villainFallbackPalette[index % villainFallbackPalette.length];
                return createCanvasTexture(size, size, (context, width, height) => {
                    context.clearRect(0, 0, width, height);
                    context.save();
                    context.translate(width / 2, height / 2);
                    context.rotate((index % 4) * Math.PI * 0.12);
                    const gradient = context.createLinearGradient(-width / 2, -height / 2, width / 2, height / 2);
                    gradient.addColorStop(0, baseColor);
                    gradient.addColorStop(1, '#111827');
                    context.fillStyle = gradient;
                    context.beginPath();
                    context.moveTo(0, -height * 0.38);
                    context.lineTo(width * 0.32, 0);
                    context.lineTo(0, height * 0.38);
                    context.lineTo(-width * 0.32, 0);
                    context.closePath();
                    context.fill();
                    context.strokeStyle = 'rgba(15, 23, 42, 0.65)';
                    context.lineWidth = 6;
                    context.stroke();

                    context.fillStyle = 'rgba(15, 23, 42, 0.75)';
                    context.beginPath();
                    context.arc(0, 0, width * 0.14, 0, Math.PI * 2);
                    context.fill();
                    context.restore();
                });
            }

            const fallbackFontStack = '"Segoe UI", Tahoma, Geneva, Verdana, sans-serif';
            const customFontFamily = 'Flight Time';
            const primaryFontStack = customFontFamily
                ? `"${customFontFamily}", ${fallbackFontStack}`
                : fallbackFontStack;
            const fontsReady = customFontFamily ? loadCustomFont(customFontFamily) : Promise.resolve();

            const STORAGE_KEYS = {
                playerName: 'nyanEscape.playerName',
                highScores: 'nyanEscape.highScores',
                leaderboard: 'nyanEscape.leaderboard',
                socialFeed: 'nyanEscape.socialFeed',
                submissionLog: 'nyanEscape.submissionLog',
                loreProgress: 'nyanEscape.loreProgress',
                firstRunComplete: 'nyanEscape.firstRunComplete',
                settings: 'nyanEscape.settings',
                challenges: 'nyanEscape.challenges',
                deviceId: 'nyanEscape.deviceId'
            };

            let storageAvailable = false;
            try {
                const testKey = '__nyanEscapeTest__';
                localStorage.setItem(testKey, '1');
                localStorage.removeItem(testKey);
                storageAvailable = true;
            } catch (error) {
                storageAvailable = false;
            }

            let firstRunExperience = true;

            function readStorage(key) {
                if (!storageAvailable) return null;
                try {
                    return localStorage.getItem(key);
                } catch (error) {
                    storageAvailable = false;
                    return null;
                }
            }

            function writeStorage(key, value) {
                if (!storageAvailable) return;
                try {
                    localStorage.setItem(key, value);
                } catch (error) {
                    storageAvailable = false;
                }
            }

            const API_CONFIG = (() => {
                if (typeof window === 'undefined') {
                    return {
                        baseUrl: '',
                        timeoutMs: 8000,
                        cacheTtlMs: 120000,
                        scopes: ['global', 'weekly']
                    };
                }
                const rootDataset = document.documentElement?.dataset ?? {};
                const bodyDataset = document.body?.dataset ?? {};
                const rawBase =
                    window.NYAN_ESCAPE_API_BASE_URL ??
                    rootDataset.nyanApiBase ??
                    bodyDataset.nyanApiBase ??
                    '';
                const baseUrl = typeof rawBase === 'string' ? rawBase.trim() : '';
                return {
                    baseUrl: baseUrl ? baseUrl.replace(/\/+$/, '') : '',
                    timeoutMs: 8000,
                    cacheTtlMs: 120000,
                    scopes: ['global', 'weekly']
                };
            })();

            function generateUuid() {
                if (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function') {
                    return crypto.randomUUID();
                }
                const bytes = new Uint8Array(16);
                if (typeof crypto !== 'undefined' && typeof crypto.getRandomValues === 'function') {
                    crypto.getRandomValues(bytes);
                } else {
                    for (let i = 0; i < bytes.length; i++) {
                        bytes[i] = Math.floor(Math.random() * 256);
                    }
                }
                bytes[6] = (bytes[6] & 0x0f) | 0x40;
                bytes[8] = (bytes[8] & 0x3f) | 0x80;
                const hex = Array.from(bytes, (b) => b.toString(16).padStart(2, '0'));
                return (
                    `${hex[0]}${hex[1]}${hex[2]}${hex[3]}-` +
                    `${hex[4]}${hex[5]}-` +
                    `${hex[6]}${hex[7]}-` +
                    `${hex[8]}${hex[9]}-` +
                    `${hex[10]}${hex[11]}${hex[12]}${hex[13]}${hex[14]}${hex[15]}`
                );
            }

            let cachedDeviceId = null;

            function getDeviceIdentifier() {
                if (cachedDeviceId) {
                    return cachedDeviceId;
                }
                const stored = readStorage(STORAGE_KEYS.deviceId);
                if (stored && typeof stored === 'string') {
                    cachedDeviceId = stored;
                    return stored;
                }
                const generated = generateUuid();
                cachedDeviceId = generated;
                writeStorage(STORAGE_KEYS.deviceId, generated);
                return generated;
            }

            function buildApiUrl(path = '') {
                if (!API_CONFIG.baseUrl) {
                    return null;
                }
                const normalizedPath = String(path ?? '').replace(/^\/+/, '');
                const base = API_CONFIG.baseUrl.endsWith('/') ? API_CONFIG.baseUrl : `${API_CONFIG.baseUrl}/`;
                try {
                    return new URL(normalizedPath, base).toString();
                } catch (error) {
                    console.error('Invalid leaderboard API base URL', error);
                    return null;
                }
            }

            async function fetchWithTimeout(resource, options = {}) {
                const { timeout = API_CONFIG.timeoutMs, signal, ...rest } = options ?? {};
                if (typeof AbortController === 'undefined' || !timeout || timeout <= 0) {
                    return fetch(resource, { signal, ...rest });
                }
                const controller = new AbortController();
                const timers = setTimeout(() => {
                    controller.abort();
                }, timeout);
                const abortListener = () => {
                    controller.abort();
                };
                if (signal) {
                    if (signal.aborted) {
                        clearTimeout(timers);
                        throw new DOMException('Aborted', 'AbortError');
                    }
                    signal.addEventListener('abort', abortListener, { once: true });
                }
                try {
                    const combinedSignal = controller.signal;
                    return await fetch(resource, { ...rest, signal: combinedSignal });
                } finally {
                    clearTimeout(timers);
                    if (signal) {
                        signal.removeEventListener('abort', abortListener);
                    }
                }
            }

            async function parseJsonSafely(response) {
                try {
                    return await response.json();
                } catch (error) {
                    return null;
                }
            }

            if (storageAvailable) {
                const storedFirstRun = readStorage(STORAGE_KEYS.firstRunComplete);
                firstRunExperience = storedFirstRun !== 'true';
                const rawLoreProgress = readStorage(STORAGE_KEYS.loreProgress);
                const parsedLore = rawLoreProgress != null ? Number.parseInt(rawLoreProgress, 10) : NaN;
                if (!Number.isNaN(parsedLore) && parsedLore > 0) {
                    storedLoreProgressMs = parsedLore;
                    updateIntelLore(storedLoreProgressMs);
                }
            }

            if (comicIntro) {
                comicIntro.hidden = !firstRunExperience;
            }

            function loadHighScores() {
                const raw = readStorage(STORAGE_KEYS.highScores);
                if (!raw) return {};
                try {
                    const parsed = JSON.parse(raw);
                    return typeof parsed === 'object' && parsed !== null ? parsed : {};
                } catch (error) {
                    return {};
                }
            }

            function persistHighScores(data) {
                if (!storageAvailable) return;
                writeStorage(STORAGE_KEYS.highScores, JSON.stringify(data));
            }

            const DEFAULT_PLAYER_NAME = 'Ace Pilot';

            function sanitizeLeaderboardEntries(entries = []) {
                if (!Array.isArray(entries)) {
                    return [];
                }
                return entries
                    .filter((entry) => entry && typeof entry === 'object')
                    .map((entry) => {
                        const playerName = sanitizePlayerName(entry.player ?? entry.playerName ?? '') || DEFAULT_PLAYER_NAME;
                        const score = Number.isFinite(entry.score) ? Math.max(0, Math.floor(entry.score)) : 0;
                        const timeMs = Number.isFinite(entry.timeMs) ? Math.max(0, Math.floor(entry.timeMs)) : 0;
                        const bestStreak = Number.isFinite(entry.bestStreak)
                            ? Math.max(0, Math.floor(entry.bestStreak))
                            : 0;
                        const nyan = Number.isFinite(entry.nyan) ? Math.max(0, Math.floor(entry.nyan)) : 0;
                        const rawTimestamp = entry.recordedAt ?? entry.createdAt ?? entry.timestamp ?? Date.now();
                        let recordedAt = Date.now();
                        if (typeof rawTimestamp === 'string') {
                            const parsed = Date.parse(rawTimestamp);
                            recordedAt = Number.isFinite(parsed) ? parsed : Date.now();
                        } else {
                            const numeric = Number(rawTimestamp);
                            recordedAt = Number.isFinite(numeric) ? numeric : Date.now();
                        }
                        return {
                            player: playerName,
                            score,
                            timeMs,
                            bestStreak,
                            nyan,
                            recordedAt
                        };
                    })
                    .sort((a, b) => {
                        if (b.score !== a.score) return b.score - a.score;
                        if (b.timeMs !== a.timeMs) return b.timeMs - a.timeMs;
                        return a.recordedAt - b.recordedAt;
                    })
                    .slice(0, 50);
            }

            function sanitizeLeaderboardSnapshot(snapshot = {}) {
                if (Array.isArray(snapshot)) {
                    return {
                        global: sanitizeLeaderboardEntries(snapshot),
                        weekly: [],
                        fetchedAt: Date.now()
                    };
                }
                if (!snapshot || typeof snapshot !== 'object') {
                    return { global: [], weekly: [], fetchedAt: 0 };
                }
                const fetchedRaw = snapshot.fetchedAt ?? snapshot.updatedAt ?? Date.now();
                let fetchedAt = Date.now();
                if (typeof fetchedRaw === 'string') {
                    const parsed = Date.parse(fetchedRaw);
                    fetchedAt = Number.isFinite(parsed) ? parsed : Date.now();
                } else {
                    const numeric = Number(fetchedRaw);
                    fetchedAt = Number.isFinite(numeric) ? numeric : Date.now();
                }
                return {
                    global: sanitizeLeaderboardEntries(snapshot.global ?? snapshot.entries ?? []),
                    weekly: sanitizeLeaderboardEntries(snapshot.weekly ?? snapshot.week ?? []),
                    fetchedAt
                };
            }

            function loadLeaderboard() {
                const raw = readStorage(STORAGE_KEYS.leaderboard);
                if (!raw) {
                    return { global: [], weekly: [], fetchedAt: 0 };
                }
                try {
                    const parsed = JSON.parse(raw);
                    return sanitizeLeaderboardSnapshot(parsed);
                } catch (error) {
                    console.warn('Failed to parse cached leaderboard snapshot', error);
                    return { global: [], weekly: [], fetchedAt: 0 };
                }
            }

            function persistLeaderboard(snapshot) {
                if (!storageAvailable) return;
                const sanitized = sanitizeLeaderboardSnapshot(snapshot);
                writeStorage(STORAGE_KEYS.leaderboard, JSON.stringify(sanitized));
            }

            function loadSocialFeed() {
                const raw = readStorage(STORAGE_KEYS.socialFeed);
                if (!raw) return [];
                try {
                    const parsed = JSON.parse(raw);
                    return Array.isArray(parsed) ? parsed : [];
                } catch (error) {
                    return [];
                }
            }

            function persistSocialFeed(entries) {
                if (!storageAvailable) return;
                writeStorage(STORAGE_KEYS.socialFeed, JSON.stringify(entries));
            }

            function loadSubmissionLog() {
                const raw = readStorage(STORAGE_KEYS.submissionLog);
                if (!raw) return {};
                try {
                    const parsed = JSON.parse(raw);
                    if (typeof parsed !== 'object' || parsed === null) {
                        return {};
                    }
                    const sanitized = {};
                    for (const [key, value] of Object.entries(parsed)) {
                        if (!Array.isArray(value)) {
                            continue;
                        }
                        const normalized = value
                            .map((timestamp) => Number(timestamp))
                            .filter((timestamp) => Number.isFinite(timestamp));
                        sanitized[key] = normalized;
                    }
                    return sanitized;
                } catch (error) {
                    return {};
                }
            }

            function persistSubmissionLog(log) {
                if (!storageAvailable) return;
                writeStorage(STORAGE_KEYS.submissionLog, JSON.stringify(log));
            }

            const SUBMISSION_WINDOW_MS = 24 * 60 * 60 * 1000;
            const SUBMISSION_LIMIT = 3;

            let submissionLog = loadSubmissionLog();

            const DEFAULT_SETTINGS = {
                masterVolume: typeof audioManager.getMasterVolume === 'function'
                    ? audioManager.getMasterVolume()
                    : 0.85,
                musicEnabled: typeof audioManager.isMusicEnabled === 'function'
                    ? audioManager.isMusicEnabled()
                    : true,
                sfxEnabled: typeof audioManager.isSfxEnabled === 'function'
                    ? audioManager.isSfxEnabled()
                    : true,
                reducedEffects: false
            };

            let settingsState = { ...DEFAULT_SETTINGS };

            function sanitizeVolume(value, fallback = DEFAULT_SETTINGS.masterVolume) {
                const numeric = Number(value);
                if (!Number.isFinite(numeric)) {
                    return clamp(fallback, 0, 1);
                }
                return clamp(numeric, 0, 1);
            }

            function coerceSettings(partial, base = settingsState ?? DEFAULT_SETTINGS) {
                const source = { ...base };
                if (partial && typeof partial === 'object') {
                    if (Object.prototype.hasOwnProperty.call(partial, 'masterVolume')) {
                        source.masterVolume = partial.masterVolume;
                    }
                    if (Object.prototype.hasOwnProperty.call(partial, 'musicEnabled')) {
                        source.musicEnabled = partial.musicEnabled;
                    }
                    if (Object.prototype.hasOwnProperty.call(partial, 'sfxEnabled')) {
                        source.sfxEnabled = partial.sfxEnabled;
                    }
                    if (Object.prototype.hasOwnProperty.call(partial, 'reducedEffects')) {
                        source.reducedEffects = partial.reducedEffects;
                    }
                }
                return {
                    masterVolume: sanitizeVolume(source.masterVolume, base.masterVolume ?? DEFAULT_SETTINGS.masterVolume),
                    musicEnabled: source.musicEnabled !== false,
                    sfxEnabled: source.sfxEnabled !== false,
                    reducedEffects: source.reducedEffects === true
                };
            }

            function loadSettingsPreferences() {
                if (!storageAvailable) {
                    return { ...DEFAULT_SETTINGS };
                }
                const raw = readStorage(STORAGE_KEYS.settings);
                if (!raw) {
                    return { ...DEFAULT_SETTINGS };
                }
                try {
                    const parsed = JSON.parse(raw);
                    return coerceSettings(parsed, DEFAULT_SETTINGS);
                } catch (error) {
                    return { ...DEFAULT_SETTINGS };
                }
            }

            function persistSettingsPreferences() {
                if (!storageAvailable) {
                    return;
                }
                const payload = {
                    masterVolume: Number(settingsState.masterVolume.toFixed(3)),
                    musicEnabled: settingsState.musicEnabled,
                    sfxEnabled: settingsState.sfxEnabled,
                    reducedEffects: settingsState.reducedEffects
                };
                writeStorage(STORAGE_KEYS.settings, JSON.stringify(payload));
            }

            const CHALLENGE_STATE_VERSION = 1;

            function createDefaultCosmeticsState() {
                return {
                    ownedSkins: ['default'],
                    ownedTrails: ['rainbow'],
                    equipped: { skin: 'default', trail: 'rainbow' }
                };
            }

            function createDefaultChallengeState() {
                return {
                    version: CHALLENGE_STATE_VERSION,
                    slots: {},
                    history: [],
                    cosmetics: createDefaultCosmeticsState()
                };
            }

            function sanitizeChallengeGoal(goal) {
                if (!goal || typeof goal !== 'object') {
                    return { metric: 'score', target: 0, mode: 'sum' };
                }
                const metric = typeof goal.metric === 'string' ? goal.metric : 'score';
                const rawTarget = Number(goal.target);
                const target = Number.isFinite(rawTarget) && rawTarget > 0 ? rawTarget : 0;
                let mode = goal.mode === 'max' ? 'max' : 'sum';
                if (metric === 'time' || metric === 'score') {
                    mode = 'max';
                }
                const normalized = { metric, target, mode };
                if (goal.filter && typeof goal.filter === 'object') {
                    normalized.filter = { ...goal.filter };
                }
                return normalized;
            }

            function sanitizeChallengeSlot(slotKey, entry) {
                if (!entry || typeof entry !== 'object') {
                    return null;
                }
                const challengeId = typeof entry.challengeId === 'string' ? entry.challengeId : null;
                const rotation = typeof entry.rotation === 'string' ? entry.rotation : null;
                if (!challengeId || !rotation) {
                    return null;
                }
                const goal = sanitizeChallengeGoal(entry.goal);
                const progressValue = Number.isFinite(entry.progressValue) ? entry.progressValue : 0;
                return {
                    slot: slotKey,
                    challengeId,
                    rotation,
                    goal,
                    progressValue,
                    completedAt: typeof entry.completedAt === 'number' ? entry.completedAt : null,
                    claimedAt: typeof entry.claimedAt === 'number' ? entry.claimedAt : null,
                    createdAt: typeof entry.createdAt === 'number' ? entry.createdAt : Date.now(),
                    updatedAt: typeof entry.updatedAt === 'number' ? entry.updatedAt : Date.now()
                };
            }

            function migrateChallengeState(raw) {
                const base = createDefaultChallengeState();
                if (!isPlainObject(raw)) {
                    return base;
                }
                const state = {
                    version: Number.isInteger(raw.version) ? raw.version : 0,
                    slots: {},
                    history: Array.isArray(raw.history)
                        ? raw.history
                              .filter((entry) => isPlainObject(entry))
                              .slice(-24)
                              .map((entry) => ({ ...entry }))
                        : [],
                    cosmetics: isPlainObject(raw.cosmetics) ? { ...raw.cosmetics } : createDefaultCosmeticsState()
                };
                const slots = isPlainObject(raw.slots) ? raw.slots : {};
                for (const [slotKey, entry] of Object.entries(slots)) {
                    const normalized = sanitizeChallengeSlot(slotKey, entry);
                    if (normalized) {
                        state.slots[slotKey] = normalized;
                    }
                }
                const defaultCosmetics = createDefaultCosmeticsState();
                if (!Array.isArray(state.cosmetics.ownedSkins)) {
                    state.cosmetics.ownedSkins = [...defaultCosmetics.ownedSkins];
                } else {
                    state.cosmetics.ownedSkins = Array.from(
                        new Set(state.cosmetics.ownedSkins.map((value) => String(value)))
                    );
                    if (!state.cosmetics.ownedSkins.includes('default')) {
                        state.cosmetics.ownedSkins.unshift('default');
                    }
                }
                if (!Array.isArray(state.cosmetics.ownedTrails)) {
                    state.cosmetics.ownedTrails = [...defaultCosmetics.ownedTrails];
                } else {
                    state.cosmetics.ownedTrails = Array.from(
                        new Set(state.cosmetics.ownedTrails.map((value) => String(value)))
                    );
                    if (!state.cosmetics.ownedTrails.includes('rainbow')) {
                        state.cosmetics.ownedTrails.unshift('rainbow');
                    }
                }
                if (!isPlainObject(state.cosmetics.equipped)) {
                    state.cosmetics.equipped = { ...defaultCosmetics.equipped };
                } else {
                    const equippedSkin =
                        typeof state.cosmetics.equipped.skin === 'string'
                            ? state.cosmetics.equipped.skin
                            : defaultCosmetics.equipped.skin;
                    const equippedTrail =
                        typeof state.cosmetics.equipped.trail === 'string'
                            ? state.cosmetics.equipped.trail
                            : defaultCosmetics.equipped.trail;
                    state.cosmetics.equipped = {
                        skin: state.cosmetics.ownedSkins.includes(equippedSkin)
                            ? equippedSkin
                            : defaultCosmetics.equipped.skin,
                        trail: state.cosmetics.ownedTrails.includes(equippedTrail)
                            ? equippedTrail
                            : defaultCosmetics.equipped.trail
                    };
                }
                state.version = Math.max(state.version, 1);
                if (state.version !== CHALLENGE_STATE_VERSION) {
                    state.version = CHALLENGE_STATE_VERSION;
                }
                return state;
            }

            function loadChallengeState() {
                if (!storageAvailable) {
                    return createDefaultChallengeState();
                }
                const raw = readStorage(STORAGE_KEYS.challenges);
                if (!raw) {
                    return createDefaultChallengeState();
                }
                try {
                    const parsed = JSON.parse(raw);
                    return migrateChallengeState(parsed);
                } catch (error) {
                    return createDefaultChallengeState();
                }
            }

            function persistChallengeState(state) {
                if (!storageAvailable) {
                    return;
                }
                try {
                    writeStorage(STORAGE_KEYS.challenges, JSON.stringify(state));
                } catch (error) {
                    // Ignore write failures for challenge data
                }
            }

            function getDayIndex(date) {
                const start = new Date(date.getFullYear(), 0, 1);
                start.setHours(0, 0, 0, 0);
                const diff = date - start;
                return Math.floor(diff / 86400000);
            }

            function getWeekIndex(date) {
                const reference = new Date(date.getFullYear(), 0, 1);
                reference.setHours(0, 0, 0, 0);
                const day = reference.getDay();
                const offset = day === 0 ? 1 : day <= 1 ? 0 : 7 - day + 1;
                reference.setDate(reference.getDate() + offset);
                const diff = date - reference;
                return Math.max(0, Math.floor(diff / (86400000 * 7)));
            }

            function computeRotationId(slot, date) {
                if (slot === 'weekly') {
                    const week = getWeekIndex(date);
                    return `${date.getFullYear()}-W${week}`;
                }
                const day = getDayIndex(date);
                return `${date.getFullYear()}-${day}`;
            }

            function parseRotationId(slot, rotationId) {
                if (slot === 'weekly') {
                    const match = /^([0-9]{4})-W([0-9]+)$/.exec(rotationId ?? '');
                    if (match) {
                        const year = Number(match[1]);
                        const week = Number(match[2]);
                        if (Number.isFinite(year) && Number.isFinite(week)) {
                            const reference = new Date(year, 0, 1);
                            reference.setHours(0, 0, 0, 0);
                            const day = reference.getDay();
                            const offset = day === 0 ? 1 : day <= 1 ? 0 : 7 - day + 1;
                            reference.setDate(reference.getDate() + offset + week * 7);
                            return reference;
                        }
                    }
                } else {
                    const match = /^([0-9]{4})-([0-9]+)$/.exec(rotationId ?? '');
                    if (match) {
                        const year = Number(match[1]);
                        const day = Number(match[2]);
                        if (Number.isFinite(year) && Number.isFinite(day)) {
                            const reference = new Date(year, 0, 1);
                            reference.setHours(0, 0, 0, 0);
                            reference.setDate(reference.getDate() + day);
                            return reference;
                        }
                    }
                }
                return new Date();
            }

            function getRotationEnd(slot, rotationId, referenceDate = new Date()) {
                const base = parseRotationId(slot, rotationId) ?? referenceDate;
                if (slot === 'weekly') {
                    const end = new Date(base.getTime());
                    const day = end.getDay();
                    let daysUntilMonday = (8 - day) % 7;
                    if (daysUntilMonday === 0) {
                        daysUntilMonday = 7;
                    }
                    end.setDate(end.getDate() + daysUntilMonday);
                    end.setHours(0, 0, 0, 0);
                    return end.getTime();
                }
                const end = new Date(base.getTime());
                end.setHours(24, 0, 0, 0);
                return end.getTime();
            }

            function formatDurationShort(milliseconds) {
                const totalSeconds = Math.floor(milliseconds / 1000);
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                if (minutes > 0) {
                    return `${minutes}:${String(seconds).padStart(2, '0')}`;
                }
                return `${totalSeconds}s`;
            }

            function describeReward(reward) {
                if (!reward || typeof reward !== 'object') {
                    return '';
                }
                if (typeof reward.label === 'string' && reward.label) {
                    return reward.label;
                }
                if (reward.type === 'cosmetic') {
                    if (reward.category === 'skin') {
                        return 'Hull skin unlock';
                    }
                    if (reward.category === 'trail') {
                        return 'Trail effect unlock';
                    }
                }
                return 'Reward ready';
            }

            const CHALLENGE_DEFINITIONS = {
                daily: [
                    {
                        id: 'daily-survive-90',
                        slot: 'daily',
                        title: 'Hold the Lane',
                        description: 'Survive 90 seconds in a single run.',
                        goal: { metric: 'time', target: 90000, mode: 'max' },
                        reward: { type: 'cosmetic', category: 'trail', id: 'aurora', label: 'Aurora Wake Trail' }
                    },
                    {
                        id: 'daily-core-collector',
                        slot: 'daily',
                        title: 'Core Collector',
                        description: 'Secure 5 power-ups in a day.',
                        goal: { metric: 'powerUp', target: 5, mode: 'sum' },
                        reward: { type: 'cosmetic', category: 'trail', id: 'ember', label: 'Ember Wake Trail' }
                    }
                ],
                weekly: [
                    {
                        id: 'weekly-villain-hunter',
                        slot: 'weekly',
                        title: 'Villain Hunter',
                        description: 'Neutralize 30 villains this week.',
                        goal: { metric: 'villain', target: 30, mode: 'sum' },
                        reward: { type: 'cosmetic', category: 'skin', id: 'midnight', label: 'Midnight Mirage Hull' }
                    },
                    {
                        id: 'weekly-score-champion',
                        slot: 'weekly',
                        title: 'Score Champion',
                        description: 'Reach 75,000 score in a single run.',
                        goal: { metric: 'score', target: 75000, mode: 'max' },
                        reward: { type: 'cosmetic', category: 'skin', id: 'sunrise', label: 'Sunrise Shimmer Hull' }
                    }
                ]
            };

            function createChallengeManager(config = {}) {
                const {
                    definitions = CHALLENGE_DEFINITIONS,
                    cosmeticsCatalog = null,
                    onChallengeCompleted,
                    onRewardClaimed
                } = config ?? {};
                let state = loadChallengeState();
                const listeners = new Set();
                const definitionIndex = new Map();
                const cosmetics = cosmeticsCatalog ?? { skins: {}, trails: {} };
                let cachedSnapshot = null;

                function indexDefinitions() {
                    definitionIndex.clear();
                    for (const [slotKey, list] of Object.entries(definitions ?? {})) {
                        if (!Array.isArray(list)) {
                            continue;
                        }
                        for (const definition of list) {
                            if (definition && typeof definition === 'object' && typeof definition.id === 'string') {
                                definitionIndex.set(definition.id, { ...definition, slot: slotKey });
                            }
                        }
                    }
                }

                function selectDefinition(slot, date) {
                    const list = Array.isArray(definitions?.[slot]) ? definitions[slot] : [];
                    if (!list.length) {
                        return null;
                    }
                    const index = slot === 'weekly' ? getWeekIndex(date) : getDayIndex(date);
                    return list[index % list.length];
                }

                function formatProgress(goal, value, target) {
                    if (!goal || typeof goal !== 'object') {
                        return `${value} / ${target}`;
                    }
                    if (goal.metric === 'time') {
                        return `${formatDurationShort(value)} / ${formatDurationShort(target)}`;
                    }
                    if (goal.metric === 'score') {
                        return `${value.toLocaleString()} / ${target.toLocaleString()}`;
                    }
                    return `${value} / ${target}`;
                }

                function formatCountdown(slot, rotationId, now) {
                    const resetAt = getRotationEnd(slot, rotationId, new Date(now));
                    if (!resetAt) {
                        return '';
                    }
                    const remaining = Math.max(0, resetAt - now);
                    const totalSeconds = Math.ceil(remaining / 1000);
                    const days = Math.floor(totalSeconds / 86400);
                    const hours = Math.floor((totalSeconds % 86400) / 3600);
                    const minutes = Math.floor((totalSeconds % 3600) / 60);
                    if (days > 0) {
                        return `Resets in ${days}d ${hours}h`;
                    }
                    if (hours > 0) {
                        return `Resets in ${hours}h ${minutes}m`;
                    }
                    return `Resets in ${Math.max(1, minutes)}m`;
                }

                function computeActiveChallenges(snapshot) {
                    const list = [];
                    const now = Date.now();
                    for (const [slotKey, entry] of Object.entries(snapshot.slots)) {
                        if (!entry) continue;
                        const definition = definitionIndex.get(entry.challengeId) ?? {};
                        const goal = entry.goal ?? { metric: 'score', target: 0, mode: 'sum' };
                        const target = Math.max(0, Math.round(goal.target ?? 0));
                        const value = Math.max(0, Math.floor(entry.progressValue ?? 0));
                        const percent = target > 0 ? Math.min(100, Math.round((value / target) * 100)) : entry.completedAt ? 100 : 0;
                        const reward = definition.reward ?? null;
                        const completed = Boolean(entry.completedAt) || (target > 0 && value >= target);
                        const claimed = Boolean(entry.claimedAt);
                        const readyToClaim = completed && !claimed && Boolean(reward);
                        list.push({
                            id: definition.id ?? entry.challengeId,
                            slot: slotKey,
                            slotLabel: slotKey === 'daily' ? 'Daily' : slotKey === 'weekly' ? 'Weekly' : slotKey,
                            title: definition.title ?? entry.challengeId,
                            description: definition.description ?? '',
                            reward,
                            rewardLabel: describeReward(reward),
                            completed,
                            claimed,
                            readyToClaim,
                            progressValue: value,
                            target,
                            progressPercent: percent,
                            progressText: formatProgress(goal, value, target),
                            statusText: claimed
                                ? 'Reward claimed'
                                : readyToClaim
                                    ? 'Reward ready'
                                    : `${percent}% complete`,
                            buttonLabel: claimed ? 'Claimed' : readyToClaim ? 'Claim Reward' : 'Locked',
                            rotation: entry.rotation,
                            timeRemainingLabel: formatCountdown(slotKey, entry.rotation, now)
                        });
                    }
                    return list;
                }

                function buildSnapshot() {
                    const snapshot = {
                        version: CHALLENGE_STATE_VERSION,
                        slots: {},
                        history: Array.isArray(state.history)
                            ? state.history.slice(-24).map((entry) => ({ ...entry }))
                            : [],
                        cosmetics: {
                            ownedSkins: [...state.cosmetics.ownedSkins],
                            ownedTrails: [...state.cosmetics.ownedTrails],
                            equipped: { ...state.cosmetics.equipped }
                        }
                    };
                    for (const [slotKey, entry] of Object.entries(state.slots)) {
                        snapshot.slots[slotKey] = { ...entry, goal: { ...entry.goal }, slot: slotKey };
                    }
                    snapshot.activeChallenges = computeActiveChallenges(snapshot);
                    return snapshot;
                }

                function unlockReward(reward) {
                    if (!reward || reward.type !== 'cosmetic') {
                        return false;
                    }
                    if (reward.category === 'skin') {
                        if (cosmetics?.skins && !cosmetics.skins[reward.id]) {
                            return false;
                        }
                        let changed = false;
                        if (!state.cosmetics.ownedSkins.includes(reward.id)) {
                            state.cosmetics.ownedSkins.push(reward.id);
                            changed = true;
                        }
                        if (state.cosmetics.equipped.skin === 'default') {
                            state.cosmetics.equipped.skin = reward.id;
                            changed = true;
                        }
                        return changed;
                    }
                    if (reward.category === 'trail') {
                        if (cosmetics?.trails && !cosmetics.trails[reward.id]) {
                            return false;
                        }
                        let changed = false;
                        if (!state.cosmetics.ownedTrails.includes(reward.id)) {
                            state.cosmetics.ownedTrails.push(reward.id);
                            changed = true;
                        }
                        if (state.cosmetics.equipped.trail === 'rainbow') {
                            state.cosmetics.equipped.trail = reward.id;
                            changed = true;
                        }
                        return changed;
                    }
                    return false;
                }

                function ensureActive(date = new Date()) {
                    let mutated = false;
                    for (const slotKey of Object.keys(definitions ?? {})) {
                        const definition = selectDefinition(slotKey, date);
                        const rotationId = computeRotationId(slotKey, date);
                        if (!definition) {
                            if (state.slots[slotKey]) {
                                delete state.slots[slotKey];
                                mutated = true;
                            }
                            continue;
                        }
                        const current = state.slots[slotKey];
                        if (!current || current.challengeId !== definition.id || current.rotation !== rotationId) {
                            if (current) {
                                state.history.push({ ...current, archivedAt: Date.now(), slot: slotKey });
                                state.history = state.history.slice(-24);
                            }
                            state.slots[slotKey] = {
                                slot: slotKey,
                                challengeId: definition.id,
                                rotation: rotationId,
                                goal: sanitizeChallengeGoal(definition.goal),
                                progressValue: 0,
                                completedAt: null,
                                claimedAt: null,
                                createdAt: Date.now(),
                                updatedAt: Date.now()
                            };
                            mutated = true;
                        } else {
                            const normalizedGoal = sanitizeChallengeGoal(definition.goal);
                            if (
                                current.goal.metric !== normalizedGoal.metric ||
                                current.goal.mode !== normalizedGoal.mode ||
                                current.goal.target !== normalizedGoal.target
                            ) {
                                current.goal = normalizedGoal;
                                current.progressValue = Math.min(
                                    current.progressValue ?? 0,
                                    normalizedGoal.target ?? current.progressValue
                                );
                                if (current.completedAt && current.progressValue < normalizedGoal.target) {
                                    current.completedAt = null;
                                    current.claimedAt = null;
                                }
                                current.updatedAt = Date.now();
                                mutated = true;
                            }
                        }
                    }
                    return mutated;
                }

                function notifyListeners() {
                    for (const listener of listeners) {
                        try {
                            listener(cachedSnapshot);
                        } catch (error) {
                            console.error('challenge listener error', error);
                        }
                    }
                }

                function commitState({ notify = true, completions = [], rewardClaim = null } = {}) {
                    persistChallengeState(state);
                    cachedSnapshot = buildSnapshot();
                    if (notify) {
                        notifyListeners();
                    }
                    if (completions.length && typeof onChallengeCompleted === 'function') {
                        for (const completion of completions) {
                            try {
                                onChallengeCompleted(completion.definition, {
                                    slot: completion.slot,
                                    progress: { ...completion.entry },
                                    reward: completion.definition?.reward ?? null
                                });
                            } catch (error) {
                                console.error('challenge completion hook error', error);
                            }
                        }
                    }
                    if (rewardClaim && typeof onRewardClaimed === 'function') {
                        try {
                            onRewardClaimed(rewardClaim.definition, rewardClaim.reward);
                        } catch (error) {
                            console.error('challenge reward hook error', error);
                        }
                    }
                }

                function recordEvent(event, payload = {}) {
                    const date = new Date();
                    let mutated = ensureActive(date);
                    const completions = [];
                    for (const [slotKey, entry] of Object.entries(state.slots)) {
                        if (!entry) continue;
                        const goal = entry.goal ?? { metric: 'score', target: 0, mode: 'sum' };
                        const before = entry.progressValue ?? 0;
                        let after = before;
                        if (goal.metric === 'time' && event === 'time') {
                            const totalMs = Number(payload.totalMs ?? 0);
                            if (Number.isFinite(totalMs) && totalMs > after) {
                                after = totalMs;
                            }
                        } else if (goal.metric === 'score' && event === 'score') {
                            const totalScore = Number(payload.totalScore ?? 0);
                            if (Number.isFinite(totalScore) && totalScore > after) {
                                after = totalScore;
                            }
                        } else if (goal.metric === 'villain' && event === 'villain') {
                            const count = Number(payload.count ?? 1);
                            if (Number.isFinite(count) && count > 0) {
                                after = before + count;
                            }
                        } else if (goal.metric === 'powerUp' && event === 'powerUp') {
                            const allowedTypes = Array.isArray(goal.filter?.types) ? goal.filter.types : null;
                            if (!allowedTypes || allowedTypes.includes(payload.type)) {
                                after = before + 1;
                            }
                        }
                        if (after !== before) {
                            entry.progressValue = after;
                            entry.updatedAt = Date.now();
                            mutated = true;
                        }
                        const target = goal.target ?? 0;
                        if (target > 0 && entry.progressValue >= target && !entry.completedAt) {
                            entry.completedAt = Date.now();
                            mutated = true;
                            const definition = definitionIndex.get(entry.challengeId) ?? {
                                id: entry.challengeId,
                                slot: slotKey
                            };
                            completions.push({ slot: slotKey, entry: { ...entry }, definition });
                        }
                    }
                    if (mutated) {
                        commitState({ notify: true, completions });
                    }
                }

                function claimReward(challengeId) {
                    const date = new Date();
                    let mutated = ensureActive(date);
                    for (const [slotKey, entry] of Object.entries(state.slots)) {
                        if (!entry || entry.challengeId !== challengeId) {
                            continue;
                        }
                        if (!entry.completedAt || entry.claimedAt) {
                            return false;
                        }
                        const definition = definitionIndex.get(entry.challengeId) ?? { id: challengeId, slot: slotKey };
                        const reward = definition.reward ?? null;
                        if (reward) {
                            unlockReward(reward);
                        }
                        entry.claimedAt = Date.now();
                        entry.updatedAt = Date.now();
                        mutated = true;
                        commitState({ notify: true, rewardClaim: { definition, reward } });
                        return true;
                    }
                    if (mutated) {
                        commitState({ notify: true });
                    }
                    return false;
                }

                function equipCosmetic(category, id) {
                    let mutated = ensureActive(new Date());
                    if (category === 'skin') {
                        if (!state.cosmetics.ownedSkins.includes(id) || state.cosmetics.equipped.skin === id) {
                            return false;
                        }
                        if (cosmetics?.skins && !cosmetics.skins[id]) {
                            return false;
                        }
                        state.cosmetics.equipped.skin = id;
                        mutated = true;
                    } else if (category === 'trail') {
                        if (!state.cosmetics.ownedTrails.includes(id) || state.cosmetics.equipped.trail === id) {
                            return false;
                        }
                        if (cosmetics?.trails && !cosmetics.trails[id]) {
                            return false;
                        }
                        state.cosmetics.equipped.trail = id;
                        mutated = true;
                    } else {
                        return false;
                    }
                    if (mutated) {
                        commitState({ notify: true });
                    }
                    return true;
                }

                function subscribe(listener) {
                    if (typeof listener !== 'function') {
                        return () => {};
                    }
                    listeners.add(listener);
                    listener(cachedSnapshot);
                    return () => {
                        listeners.delete(listener);
                    };
                }

                indexDefinitions();
                const initialMutated = ensureActive(new Date());
                cachedSnapshot = buildSnapshot();
                if (initialMutated) {
                    persistChallengeState(state);
                    cachedSnapshot = buildSnapshot();
                }

                return {
                    recordEvent,
                    claimReward,
                    equipCosmetic,
                    subscribe,
                    getSnapshot: () => cachedSnapshot
                };
            }

            function applyReducedEffectsFlag(enabled) {
                reducedEffectsMode = Boolean(enabled);
                if (bodyElement) {
                    bodyElement.classList.toggle('reduced-effects', reducedEffectsMode);
                }
            }

            function updateSettingsUI() {
                if (masterVolumeSlider) {
                    const volumePercent = Math.round(settingsState.masterVolume * 100);
                    masterVolumeSlider.value = String(volumePercent);
                    masterVolumeSlider.setAttribute('aria-valuenow', String(volumePercent));
                    masterVolumeSlider.setAttribute('aria-valuetext', `${volumePercent} percent`);
                }
                if (masterVolumeValue) {
                    masterVolumeValue.textContent = `${Math.round(settingsState.masterVolume * 100)}%`;
                }
                if (musicToggle) {
                    musicToggle.checked = settingsState.musicEnabled;
                }
                if (musicToggleStatus) {
                    musicToggleStatus.textContent = settingsState.musicEnabled ? 'On' : 'Off';
                }
                if (sfxToggle) {
                    sfxToggle.checked = settingsState.sfxEnabled;
                }
                if (sfxToggleStatus) {
                    sfxToggleStatus.textContent = settingsState.sfxEnabled ? 'On' : 'Off';
                }
                if (reducedEffectsToggle) {
                    reducedEffectsToggle.checked = settingsState.reducedEffects;
                }
                if (reducedEffectsStatus) {
                    reducedEffectsStatus.textContent = settingsState.reducedEffects ? 'On' : 'Off';
                }
            }

            function applySettingsPreferences(partial, { persist = false } = {}) {
                settingsState = coerceSettings(partial, settingsState);
                audioManager.setMasterVolume(settingsState.masterVolume);
                audioManager.toggleMusic(settingsState.musicEnabled);
                audioManager.toggleSfx(settingsState.sfxEnabled);
                applyReducedEffectsFlag(settingsState.reducedEffects);
                updateSettingsUI();
                if (persist) {
                    persistSettingsPreferences();
                }
                return settingsState;
            }

            settingsState = loadSettingsPreferences();
            applySettingsPreferences(settingsState, { persist: false });

            const isSettingsDrawerOpen = () => Boolean(settingsDrawer && !settingsDrawer.hasAttribute('hidden'));

            function setSettingsDrawerOpen(open, { focusTarget = true } = {}) {
                if (!settingsDrawer) {
                    return;
                }
                if (open) {
                    settingsDrawer.hidden = false;
                    settingsDrawer.setAttribute('aria-hidden', 'false');
                    settingsButton?.setAttribute('aria-expanded', 'true');
                    bodyElement?.classList.add('settings-open');
                    const focusEl = masterVolumeSlider ?? settingsCloseButton ?? settingsButton;
                    if (focusTarget && focusEl) {
                        window.requestAnimationFrame(() => {
                            try {
                                focusEl.focus({ preventScroll: true });
                            } catch {
                                // Ignore focus errors
                            }
                        });
                    }
                } else {
                    settingsDrawer.hidden = true;
                    settingsDrawer.setAttribute('aria-hidden', 'true');
                    settingsButton?.setAttribute('aria-expanded', 'false');
                    bodyElement?.classList.remove('settings-open');
                    if (focusTarget && settingsButton) {
                        window.requestAnimationFrame(() => {
                            try {
                                settingsButton.focus({ preventScroll: true });
                            } catch {
                                // Ignore focus errors
                            }
                        });
                    }
                }
            }

            const openSettingsDrawer = (options = {}) => setSettingsDrawerOpen(true, options);
            const closeSettingsDrawer = (options = {}) => setSettingsDrawerOpen(false, options);
            const toggleSettingsDrawer = () => setSettingsDrawerOpen(!isSettingsDrawerOpen());

            if (settingsButton) {
                settingsButton.addEventListener('click', () => {
                    toggleSettingsDrawer();
                });
            }

            if (settingsCloseButton) {
                settingsCloseButton.addEventListener('click', () => {
                    closeSettingsDrawer();
                });
            }

            if (settingsDrawer) {
                settingsDrawer.addEventListener('click', (event) => {
                    const target = event.target;
                    if (target instanceof HTMLElement && target.dataset.settingsDismiss === 'backdrop') {
                        closeSettingsDrawer();
                    }
                });
            }

            if (masterVolumeSlider) {
                const handleVolumeChange = (persist) => {
                    const normalized = clamp(Number(masterVolumeSlider.value) / 100, 0, 1);
                    applySettingsPreferences({ masterVolume: normalized }, { persist });
                };
                masterVolumeSlider.addEventListener('input', () => handleVolumeChange(false));
                masterVolumeSlider.addEventListener('change', () => handleVolumeChange(true));
            }

            if (musicToggle) {
                musicToggle.addEventListener('change', () => {
                    applySettingsPreferences({ musicEnabled: musicToggle.checked }, { persist: true });
                });
            }

            if (sfxToggle) {
                sfxToggle.addEventListener('change', () => {
                    applySettingsPreferences({ sfxEnabled: sfxToggle.checked }, { persist: true });
                });
            }

            if (reducedEffectsToggle) {
                reducedEffectsToggle.addEventListener('change', () => {
                    applySettingsPreferences({ reducedEffects: reducedEffectsToggle.checked }, { persist: true });
                });
            }

            function ensureSubmissionLogEntry(name) {
                if (!name) return;
                if (!Array.isArray(submissionLog[name])) {
                    submissionLog[name] = [];
                }
            }

            function getSubmissionUsage(name, now = Date.now()) {
                ensureSubmissionLogEntry(name);
                const cutoff = now - SUBMISSION_WINDOW_MS;
                const recent = submissionLog[name]
                    .map((timestamp) => Number(timestamp))
                    .filter((timestamp) => Number.isFinite(timestamp) && timestamp >= cutoff)
                    .sort((a, b) => a - b);
                submissionLog[name] = recent;
                return { recent, count: recent.length };
            }

            function trackSubmissionUsage(name, timestamp) {
                const { recent } = getSubmissionUsage(name, timestamp);
                recent.push(timestamp);
                recent.sort((a, b) => a - b);
                submissionLog[name] = recent;
                persistSubmissionLog(submissionLog);
                return recent.length;
            }

            function sanitizePlayerName(value) {
                if (typeof value !== 'string') {
                    return '';
                }
                const condensed = value.replace(/\s+/g, ' ');
                const filtered = condensed.replace(/[^A-Za-z0-9 _\-]/g, '');
                return filtered.trim().slice(0, 24);
            }

            function getPendingPlayerName() {
                if (!playerNameInput) {
                    return playerName;
                }
                const sanitized = sanitizePlayerName(playerNameInput.value);
                return sanitized || DEFAULT_PLAYER_NAME;
            }

            function loadStoredPlayerName() {
                const storedName = readStorage(STORAGE_KEYS.playerName);
                const sanitized = sanitizePlayerName(storedName);
                if (sanitized) {
                    return sanitized;
                }
                return DEFAULT_PLAYER_NAME;
            }

            let highScoreData = loadHighScores();
            let playerName = loadStoredPlayerName();
            if (!highScoreData[playerName]) {
                highScoreData[playerName] = [];
            }
            ensureSubmissionLogEntry(playerName);
            writeStorage(STORAGE_KEYS.playerName, playerName);
            const cachedLeaderboards = loadLeaderboard();
            const leaderboardState = {
                scopes: {
                    global: cachedLeaderboards.global ?? [],
                    weekly: cachedLeaderboards.weekly ?? []
                },
                fetchedAt: cachedLeaderboards.fetchedAt ?? 0,
                source: cachedLeaderboards.fetchedAt ? 'cache' : 'empty',
                error: null
            };
            let activeLeaderboardScope = 'global';
            let leaderboardEntries = leaderboardState.scopes[activeLeaderboardScope] ?? [];
            const leaderboardStatusState = { message: '', type: 'info' };
            let leaderboardFetchPromise = null;
            let socialFeedData = loadSocialFeed();
            const canNativeShare = typeof navigator !== 'undefined' && typeof navigator.share === 'function';
            let lastRunSummary = null;
            let pendingSubmission = null;
            let preflightOverlayDismissed = false;

            function updatePlayerName(nextName) {
                const sanitized = sanitizePlayerName(nextName) || DEFAULT_PLAYER_NAME;
                if (sanitized === playerName) {
                    if (playerNameInput && playerNameInput.value !== sanitized) {
                        playerNameInput.value = sanitized;
                    }
                    return playerName;
                }
                playerName = sanitized;
                if (!highScoreData[playerName]) {
                    highScoreData[playerName] = [];
                }
                ensureSubmissionLogEntry(playerName);
                persistHighScores(highScoreData);
                writeStorage(STORAGE_KEYS.playerName, playerName);
                if (playerNameInput && playerNameInput.value !== sanitized) {
                    playerNameInput.value = sanitized;
                }
                updateHighScorePanel();
                if (lastRunSummary) {
                    lastRunSummary.player = playerName;
                    updateSharePanel();
                }
                refreshOverlayLaunchButton();
                return playerName;
            }

            function commitPlayerNameInput() {
                if (!playerNameInput) {
                    return updatePlayerName(playerName);
                }
                const sanitized = sanitizePlayerName(playerNameInput.value);
                const finalName = sanitized || DEFAULT_PLAYER_NAME;
                if (playerNameInput.value !== finalName) {
                    playerNameInput.value = finalName;
                }
                refreshOverlayLaunchButton();
                const updated = updatePlayerName(finalName);
                refreshHighScorePreview();
                revealGameScreenAfterNameEntry();
                return updated;
            }

            if (playerNameInput) {
                playerNameInput.value = playerName;
                refreshOverlayLaunchButton();
                refreshHighScorePreview();
                playerNameInput.addEventListener('input', () => {
                    refreshOverlayLaunchButton();
                    refreshHighScorePreview();
                });
                playerNameInput.addEventListener('blur', () => {
                    commitPlayerNameInput();
                });
                playerNameInput.addEventListener('keydown', (event) => {
                    if (event.key === 'Enter') {
                        commitPlayerNameInput();
                    }
                });
            }

            if (callsignForm) {
                callsignForm.addEventListener('submit', (event) => {
                    event.preventDefault();
                    commitPlayerNameInput();
                });
            }

            if (leaderboardTabButtons.length) {
                leaderboardTabButtons.forEach((button) => {
                    button.addEventListener('click', () => {
                        const scope = button?.dataset?.leaderboardScope ?? 'global';
                        setActiveLeaderboardScope(scope);
                    });
                });
            }

            applyLeaderboardSnapshot(cachedLeaderboards, {
                source: cachedLeaderboards.fetchedAt ? 'cache' : 'empty',
                persist: false
            });

            if (API_CONFIG.baseUrl) {
                refreshLeaderboardsFromApi({ force: true });
            } else {
                setLeaderboardStatus(
                    'Leaderboard sync unavailable  set NYAN_ESCAPE_API_BASE_URL to enable syncing.',
                    'warning'
                );
            }

            if (typeof window !== 'undefined') {
                window.addEventListener('online', () => {
                    if (API_CONFIG.baseUrl) {
                        refreshLeaderboardsFromApi({ force: true });
                    }
                });
            }

            function completeFirstRunExperience() {
                if (!firstRunExperience) {
                    return;
                }
                firstRunExperience = false;
                if (comicIntro) {
                    comicIntro.hidden = true;
                }
                writeStorage(STORAGE_KEYS.firstRunComplete, 'true');
            }

            function formatTime(milliseconds) {
                const totalSeconds = Math.floor(milliseconds / 1000);
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                const tenths = Math.floor((milliseconds % 1000) / 100);
                return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}.${tenths}`;
            }

            function buildRunSummaryMessage(baseMessage, summary, {
                placement = null,
                runsToday = null,
                limitReached = false,
                prompt = false,
                success = false,
                skipped = false,
                offline = false,
                conflict = false,
                errorMessage = null
            } = {}) {
                const lines = [
                    baseMessage,
                    `Flight Time: ${formatTime(summary.timeMs)}`,
                    `Final Score: ${summary.score}  Points collected: ${summary.nyan.toLocaleString()}`
                ];
                if (placement) {
                    lines.push(`Galaxy Standings: #${placement}`);
                }
                if (typeof runsToday === 'number') {
                    lines.push(`Daily Log: ${Math.min(runsToday, SUBMISSION_LIMIT)}/${SUBMISSION_LIMIT} submissions used.`);
                }
                if (limitReached) {
                    lines.push('Daily flight log limit reached. Try again after the cooldown.');
                }
                if (prompt) {
                    lines.push('Submit this flight log to record your score?');
                }
                if (success) {
                    lines.push('Score logged successfully! Ready for another run?');
                }
                if (skipped) {
                    lines.push('Submission skipped. Run not recorded.');
                }
                if (conflict) {
                    lines.push('Submission ignored  your best run is already on the board.');
                }
                if (offline) {
                    lines.push('Offline mode: storing this flight log locally until the next sync.');
                }
                if (errorMessage) {
                    lines.push(errorMessage);
                }
                return lines.join('\n');
            }

            function formatRelativeTime(timestamp) {
                if (!timestamp) return '';
                const now = Date.now();
                const diff = Math.max(0, now - timestamp);
                const seconds = Math.floor(diff / 1000);
                if (seconds < 60) return 'Just now';
                const minutes = Math.floor(seconds / 60);
                if (minutes < 60) return `${minutes}m ago`;
                const hours = Math.floor(minutes / 60);
                if (hours < 24) return `${hours}h ago`;
                const days = Math.floor(hours / 24);
                return `${days}d ago`;
            }

            function updateTimerDisplay() {
                if (!timerValueEl) return;
                const formatted = formatTime(state.elapsedTime);
                if (formatted !== lastFormattedTimer) {
                    lastFormattedTimer = formatted;
                    timerValueEl.textContent = formatted;
                }
            }

            async function recordHighScore(durationMs, score, metadata = {}) {
                const baseName = sanitizePlayerName(metadata.player) || playerName;
                if (!baseName || durationMs <= 0) {
                    return { recorded: false, placement: null, runsToday: 0, reason: 'invalid' };
                }
                ensureSubmissionLogEntry(baseName);
                if (!highScoreData[baseName]) {
                    highScoreData[baseName] = [];
                }
                const recordedAt = metadata.recordedAt ?? Date.now();
                const usage = getSubmissionUsage(baseName, recordedAt);
                if (usage.count >= SUBMISSION_LIMIT) {
                    return { recorded: false, placement: null, runsToday: usage.count, reason: 'limit' };
                }
                const entry = {
                    timeMs: durationMs,
                    score,
                    recordedAt,
                    bestStreak: metadata.bestStreak ?? 0,
                    nyan: metadata.nyan ?? 0
                };
                const userScores = highScoreData[baseName] ? [...highScoreData[baseName]] : [];
                userScores.push(entry);
                userScores.sort((a, b) => {
                    if (b.timeMs !== a.timeMs) return b.timeMs - a.timeMs;
                    if (b.score !== a.score) return b.score - a.score;
                    return b.recordedAt - a.recordedAt;
                });
                highScoreData[baseName] = userScores.slice(0, 3);
                persistHighScores(highScoreData);

                let runsToday = usage.count;
                let placement = null;
                let reason = null;
                let message = null;
                let source = 'remote';
                let recorded = false;

                const deviceId = getDeviceIdentifier();
                const submissionPayload = {
                    playerName: baseName,
                    deviceId,
                    score: entry.score,
                    timeMs: entry.timeMs,
                    bestStreak: entry.bestStreak,
                    nyan: entry.nyan,
                    recordedAt: entry.recordedAt,
                    clientSubmissionId: `${deviceId}:${entry.recordedAt}:${Math.max(0, Math.floor(entry.score))}`
                };

                const apiResult = await submitScoreToApi(submissionPayload);
                if (apiResult?.success) {
                    recorded = true;
                    placement = apiResult.placement ?? null;
                    reason = null;
                    message = apiResult.message ?? null;
                    if (apiResult.leaderboards) {
                        applyLeaderboardSnapshot(apiResult.leaderboards, { source: 'remote', persist: true, error: null });
                    } else {
                        await refreshLeaderboardsFromApi({ force: true });
                    }
                    runsToday = trackSubmissionUsage(baseName, recordedAt);
                } else if (apiResult?.reason === 'conflict') {
                    recorded = false;
                    source = 'remote';
                    reason = 'conflict';
                    placement = apiResult.placement ?? null;
                    message = apiResult.message ?? 'Existing submission already recorded for this device.';
                    if (apiResult.leaderboards) {
                        applyLeaderboardSnapshot(apiResult.leaderboards, { source: 'remote', persist: true, error: null });
                    } else {
                        await refreshLeaderboardsFromApi({ force: true });
                    }
                    setLeaderboardStatus(message, 'warning');
                } else if (apiResult?.reason === 'rateLimit' || apiResult?.reason === 'validation') {
                    recorded = false;
                    source = 'remote';
                    reason = apiResult.reason;
                    message = apiResult.message ?? 'Submission rejected by the leaderboard service.';
                    setLeaderboardStatus(message, 'error');
                } else {
                    recorded = true;
                    source = 'offline';
                    reason = apiResult?.reason ?? 'offline';
                    message = apiResult?.message ?? 'Unable to reach leaderboard service. Stored locally.';
                    placement = recordLeaderboardEntry({
                        player: baseName,
                        timeMs: entry.timeMs,
                        score: entry.score,
                        bestStreak: entry.bestStreak,
                        nyan: entry.nyan,
                        recordedAt: entry.recordedAt
                    });
                    runsToday = trackSubmissionUsage(baseName, recordedAt);
                }

                return { recorded, placement, runsToday, reason, message, source };
            }

            function renderHighScorePanelForName(name) {
                if (!highScoreListEl || !highScoreTitleEl) return;
                highScoreTitleEl.textContent = `Top Flight Times  ${name}`;
                highScoreListEl.innerHTML = '';
                const entries = highScoreData[name] ?? [];
                if (!entries.length) {
                    const emptyItem = document.createElement('li');
                    emptyItem.className = 'empty';
                    emptyItem.textContent = 'No recorded runs yet. Survive to set a record!';
                    highScoreListEl.appendChild(emptyItem);
                    return;
                }
                for (const entry of entries) {
                    const item = document.createElement('li');
                    const timeSpan = document.createElement('span');
                    timeSpan.className = 'time';
                    timeSpan.textContent = formatTime(entry.timeMs);
                    const scoreSpan = document.createElement('span');
                    scoreSpan.className = 'score';
                    scoreSpan.textContent = `  ${entry.score.toLocaleString()} pts`;
                    item.appendChild(timeSpan);
                    item.appendChild(scoreSpan);
                    highScoreListEl.appendChild(item);
                }
            }

            function updateHighScorePanel() {
                renderHighScorePanelForName(playerName);
            }

            function refreshOverlayLaunchButton() {
                if (!overlayButton || overlayButton.disabled) {
                    return;
                }
                const mode = overlayButton.dataset.launchMode;
                if (!mode || (mode !== 'launch' && mode !== 'retry')) {
                    return;
                }
                const pendingName = getPendingPlayerName();
                const prefix = mode === 'retry' ? 'Retry as' : 'Launch as';
                overlayButton.textContent = `${prefix} ${pendingName}`;
            }

            function refreshHighScorePreview() {
                if (!overlay || overlay.classList.contains('hidden')) {
                    updateHighScorePanel();
                    return;
                }
                renderHighScorePanelForName(getPendingPlayerName());
            }

            function updateLeaderboardPanel() {
                if (!leaderboardListEl) return;
                refreshLeaderboardTabState();
                leaderboardEntries = getLeaderboardEntriesForScope(activeLeaderboardScope);
                if (leaderboardTitleEl) {
                    leaderboardTitleEl.textContent =
                        activeLeaderboardScope === 'weekly' ? 'Weekly Standings' : 'Galaxy Standings';
                }
                leaderboardListEl.innerHTML = '';
                if (!leaderboardEntries.length) {
                    const empty = document.createElement('li');
                    empty.className = 'empty';
                    empty.textContent =
                        activeLeaderboardScope === 'weekly'
                            ? 'No weekly standings yet. Finish a run this week to seed the board!'
                            : 'No galaxy standings yet. Finish a run to seed the board!';
                    leaderboardListEl.appendChild(empty);
                    return;
                }

                leaderboardEntries.forEach((entry) => {
                    const item = document.createElement('li');
                    const main = document.createElement('span');
                    main.textContent = `${entry.player}  ${entry.score.toLocaleString()} pts`;
                    const meta = document.createElement('span');
                    meta.className = 'meta';
                    const streakText = entry.bestStreak ? `  x${entry.bestStreak} streak` : '';
                    meta.textContent = `${formatTime(entry.timeMs)}${streakText}`;
                    item.appendChild(main);
                    item.appendChild(meta);
                    leaderboardListEl.appendChild(item);
                });
            }

            function updateSocialFeedPanel() {
                if (!socialFeedEl) return;
                socialFeedEl.innerHTML = '';
                if (!socialFeedData.length) {
                    const empty = document.createElement('li');
                    empty.className = 'empty';
                    empty.textContent = 'Complete missions to broadcast your squadron exploits.';
                    socialFeedEl.appendChild(empty);
                    return;
                }

                const visibleEntries = socialFeedData.slice(0, 8);
                for (const entry of visibleEntries) {
                    const item = document.createElement('li');
                    const entryType = entry.type === 'run' ? 'score' : entry.type;
                    if (entryType) {
                        item.classList.add(`type-${entryType}`);
                    }
                    const textSpan = document.createElement('span');
                    textSpan.textContent = entry.message;
                    const timeSpan = document.createElement('span');
                    timeSpan.className = 'timestamp';
                    timeSpan.textContent = formatRelativeTime(entry.timestamp);
                    item.appendChild(textSpan);
                    item.appendChild(timeSpan);
                    socialFeedEl.appendChild(item);
                }
            }

            function addSocialMoment(message, { type = 'score', timestamp = Date.now() } = {}) {
                if (!message) return;
                socialFeedData.unshift({ message, type, timestamp });
                const limit = 12;
                socialFeedData = socialFeedData.slice(0, limit);
                persistSocialFeed(socialFeedData);
                updateSocialFeedPanel();
            }

            function getLeaderboardEntriesForScope(scope = activeLeaderboardScope) {
                const normalized = scope === 'weekly' ? 'weekly' : 'global';
                return leaderboardState.scopes[normalized] ?? [];
            }

            function refreshLeaderboardTabState() {
                if (!Array.isArray(leaderboardTabButtons) || !leaderboardTabButtons.length) {
                    return;
                }
                leaderboardTabButtons.forEach((button) => {
                    const scope = button?.dataset?.leaderboardScope === 'weekly' ? 'weekly' : 'global';
                    const isActive = scope === activeLeaderboardScope;
                    button.classList.toggle('active', isActive);
                    button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
                });
            }

            function setLeaderboardStatus(message, type = 'info') {
                leaderboardStatusState.message = message ?? '';
                leaderboardStatusState.type = type ?? 'info';
                if (!leaderboardStatusEl) {
                    return;
                }
                const statusTypes = ['success', 'error', 'warning', 'loading', 'info'];
                leaderboardStatusEl.classList.remove(...statusTypes);
                if (!message) {
                    leaderboardStatusEl.textContent = '';
                    leaderboardStatusEl.hidden = true;
                    return;
                }
                leaderboardStatusEl.hidden = false;
                leaderboardStatusEl.textContent = message;
                if (type && statusTypes.includes(type)) {
                    leaderboardStatusEl.classList.add(type);
                } else {
                    leaderboardStatusEl.classList.add('info');
                }
            }

            function updateLeaderboardStatus() {
                const entries = getLeaderboardEntriesForScope();
                if (!entries.length && (!leaderboardState.fetchedAt || leaderboardState.source === 'empty')) {
                    setLeaderboardStatus('', 'info');
                    return;
                }
                const scopeLabel = activeLeaderboardScope === 'weekly' ? 'Weekly' : 'Global';
                if (!leaderboardState.fetchedAt) {
                    setLeaderboardStatus(`${scopeLabel} standings ready.`, 'info');
                    return;
                }
                const relative = formatRelativeTime(leaderboardState.fetchedAt);
                if (leaderboardState.source === 'remote') {
                    const text = relative === 'Just now' ? 'just now' : relative;
                    setLeaderboardStatus(`${scopeLabel} standings synced ${text}.`, 'success');
                    return;
                }
                if (leaderboardState.source === 'offline') {
                    setLeaderboardStatus(
                        `${scopeLabel} standings stored offline  last sync ${relative}.`,
                        'warning'
                    );
                    return;
                }
                setLeaderboardStatus(`${scopeLabel} standings cached  last sync ${relative}.`, 'info');
            }

            function setActiveLeaderboardScope(scope) {
                const normalized = scope === 'weekly' ? 'weekly' : 'global';
                activeLeaderboardScope = normalized;
                leaderboardEntries = getLeaderboardEntriesForScope(normalized);
                refreshLeaderboardTabState();
                updateLeaderboardPanel();
                updateLeaderboardStatus();
            }

            function applyLeaderboardSnapshot(snapshot, { source = 'cache', persist = true, error = null } = {}) {
                const sanitized = sanitizeLeaderboardSnapshot(snapshot);
                leaderboardState.scopes.global = sanitized.global;
                leaderboardState.scopes.weekly = sanitized.weekly;
                leaderboardState.fetchedAt = sanitized.fetchedAt;
                leaderboardState.source = source;
                leaderboardState.error = error ?? null;
                if (persist) {
                    persistLeaderboard({
                        global: leaderboardState.scopes.global,
                        weekly: leaderboardState.scopes.weekly,
                        fetchedAt: leaderboardState.fetchedAt
                    });
                }
                if (
                    activeLeaderboardScope === 'weekly' &&
                    !leaderboardState.scopes.weekly.length &&
                    leaderboardState.scopes.global.length
                ) {
                    activeLeaderboardScope = 'global';
                }
                leaderboardEntries = getLeaderboardEntriesForScope(activeLeaderboardScope);
                refreshLeaderboardTabState();
                updateLeaderboardPanel();
                updateLeaderboardStatus();
            }

            function recordLeaderboardEntry(entry, { scope = 'global', persist = true } = {}) {
                if (!entry || !entry.player) return null;
                const normalized = {
                    player: sanitizePlayerName(entry.player) || DEFAULT_PLAYER_NAME,
                    timeMs: Number.isFinite(entry.timeMs) ? Math.max(0, Math.floor(entry.timeMs)) : 0,
                    score: Number.isFinite(entry.score) ? Math.max(0, Math.floor(entry.score)) : 0,
                    bestStreak: Number.isFinite(entry.bestStreak) ? Math.max(0, Math.floor(entry.bestStreak)) : 0,
                    nyan: Number.isFinite(entry.nyan) ? Math.max(0, Math.floor(entry.nyan)) : 0,
                    recordedAt: Number.isFinite(entry.recordedAt) ? entry.recordedAt : Date.now()
                };
                const targetScope = scope === 'weekly' ? 'weekly' : 'global';
                const entries = [...getLeaderboardEntriesForScope(targetScope), normalized];
                entries.sort((a, b) => {
                    if (b.score !== a.score) return b.score - a.score;
                    if (b.timeMs !== a.timeMs) return b.timeMs - a.timeMs;
                    return a.recordedAt - b.recordedAt;
                });
                const limit = 7;
                const placementIndex = entries.indexOf(normalized);
                const trimmed = entries.slice(0, limit);
                leaderboardState.scopes[targetScope] = trimmed;
                if (targetScope === 'global' && !leaderboardState.scopes.weekly.length) {
                    leaderboardState.scopes.weekly = trimmed;
                }
                leaderboardState.fetchedAt = Date.now();
                leaderboardState.source = 'offline';
                leaderboardState.error = null;
                if (persist) {
                    persistLeaderboard({
                        global: leaderboardState.scopes.global,
                        weekly: leaderboardState.scopes.weekly,
                        fetchedAt: leaderboardState.fetchedAt
                    });
                }
                leaderboardEntries = getLeaderboardEntriesForScope(activeLeaderboardScope);
                refreshLeaderboardTabState();
                updateLeaderboardPanel();
                updateLeaderboardStatus();
                setLeaderboardStatus('Offline  storing standings locally until sync resumes.', 'warning');
                if (placementIndex >= 0 && placementIndex < limit) {
                    return placementIndex + 1;
                }
                return null;
            }

            async function refreshLeaderboardsFromApi({ force = false } = {}) {
                if (!API_CONFIG.baseUrl) {
                    return null;
                }
                if (leaderboardFetchPromise) {
                    return leaderboardFetchPromise;
                }
                const now = Date.now();
                if (
                    !force &&
                    leaderboardState.source === 'remote' &&
                    leaderboardState.fetchedAt &&
                    now - leaderboardState.fetchedAt < API_CONFIG.cacheTtlMs
                ) {
                    return null;
                }
                const endpoint = buildApiUrl('leaderboards');
                if (!endpoint) {
                    return null;
                }
                const url = new URL(endpoint);
                url.searchParams.set('scopes', API_CONFIG.scopes.join(','));
                leaderboardFetchPromise = (async () => {
                    try {
                        setLeaderboardStatus('Syncing standings', 'loading');
                        const response = await fetchWithTimeout(url.toString(), {
                            method: 'GET',
                            headers: { Accept: 'application/json' }
                        });
                        const payload = await parseJsonSafely(response);
                        if (!response.ok) {
                            throw new Error(payload?.error || `Leaderboard request failed (${response.status})`);
                        }
                        const snapshot = sanitizeLeaderboardSnapshot(payload?.leaderboards ?? payload ?? {});
                        applyLeaderboardSnapshot(snapshot, { source: 'remote', persist: true, error: null });
                        return snapshot;
                    } catch (error) {
                        console.error('Failed to refresh leaderboard', error);
                        leaderboardState.error = error;
                        if (!leaderboardState.scopes.global.length && !leaderboardState.scopes.weekly.length) {
                            setLeaderboardStatus('Unable to reach leaderboard server.', 'error');
                        } else {
                            setLeaderboardStatus('Offline  showing last known standings.', 'warning');
                        }
                        return null;
                    } finally {
                        leaderboardFetchPromise = null;
                    }
                })();
                return leaderboardFetchPromise;
            }

            async function submitScoreToApi(payload) {
                const endpoint = buildApiUrl('scores');
                if (!endpoint) {
                    return {
                        success: false,
                        reason: 'unconfigured',
                        placement: null,
                        leaderboards: null,
                        message: 'Leaderboard sync not configured.'
                    };
                }
                try {
                    const response = await fetchWithTimeout(endpoint, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            Accept: 'application/json'
                        },
                        body: JSON.stringify(payload)
                    });
                    const data = await parseJsonSafely(response);
                    const snapshot = data?.leaderboards ? sanitizeLeaderboardSnapshot(data.leaderboards) : null;
                    if (response.ok) {
                        return {
                            success: true,
                            placement: Number.isFinite(data?.placement) ? Number(data.placement) : null,
                            leaderboards: snapshot,
                            reason: null,
                            message: data?.message ?? null
                        };
                    }
                    const errorMessage = data?.message || data?.error || 'Unable to submit score.';
                    if (response.status === 409) {
                        return {
                            success: false,
                            reason: 'conflict',
                            placement: Number.isFinite(data?.placement) ? Number(data.placement) : null,
                            leaderboards: snapshot,
                            message: errorMessage
                        };
                    }
                    if (response.status === 429) {
                        return {
                            success: false,
                            reason: 'rateLimit',
                            placement: null,
                            leaderboards: snapshot,
                            message: errorMessage
                        };
                    }
                    if (response.status === 400) {
                        return {
                            success: false,
                            reason: 'validation',
                            placement: null,
                            leaderboards: snapshot,
                            message: errorMessage
                        };
                    }
                    return {
                        success: false,
                        reason: 'server',
                        placement: null,
                        leaderboards: snapshot,
                        message: errorMessage
                    };
                } catch (error) {
                    const reason = error?.name === 'AbortError' ? 'timeout' : 'network';
                    const message =
                        reason === 'timeout'
                            ? 'Leaderboard service timed out. Saving locally.'
                            : 'Unable to reach leaderboard service. Saving locally.';
                    return {
                        success: false,
                        reason,
                        placement: null,
                        leaderboards: null,
                        message
                    };
                }
            }

            function applyEquippedCosmetics(equipped = {}) {
                const skinId =
                    equipped && typeof equipped.skin === 'string' && playerSkins[equipped.skin]
                        ? equipped.skin
                        : 'default';
                const trailId =
                    equipped && typeof equipped.trail === 'string' && trailStyles[equipped.trail]
                        ? equipped.trail
                        : 'rainbow';
                activePlayerImage = playerSkins[skinId]?.image ?? playerBaseImage;
                activeTrailStyle = trailStyles[trailId] ?? trailStyles.rainbow;
            }

            function renderChallengeList(snapshot = {}) {
                if (!challengeListEl) {
                    return;
                }
                challengeListEl.innerHTML = '';
                const activeChallenges = Array.isArray(snapshot.activeChallenges) ? snapshot.activeChallenges : [];
                if (!activeChallenges.length) {
                    const emptyItem = document.createElement('li');
                    emptyItem.className = 'challenge-item';
                    const message = document.createElement('p');
                    message.className = 'challenge-description';
                    message.textContent = 'Challenges are calibrating. Check back soon!';
                    emptyItem.appendChild(message);
                    challengeListEl.appendChild(emptyItem);
                    return;
                }
                for (const challenge of activeChallenges) {
                    const item = document.createElement('li');
                    item.className = 'challenge-item';
                    if (challenge?.id) {
                        item.dataset.challengeId = challenge.id;
                    }

                    const heading = document.createElement('div');
                    heading.className = 'challenge-heading';
                    const title = document.createElement('h4');
                    title.className = 'challenge-title';
                    const slotLabel = challenge?.slotLabel ?? 'Challenge';
                    title.textContent = `${slotLabel}: ${challenge?.title ?? 'Objective'}`;
                    heading.appendChild(title);
                    if (challenge?.timeRemainingLabel) {
                        const reset = document.createElement('span');
                        reset.className = 'challenge-reset';
                        reset.textContent = challenge.timeRemainingLabel;
                        heading.appendChild(reset);
                    }
                    item.appendChild(heading);

                    if (challenge?.description) {
                        const description = document.createElement('p');
                        description.className = 'challenge-description';
                        description.textContent = challenge.description;
                        item.appendChild(description);
                    }

                    const progress = document.createElement('div');
                    progress.className = 'challenge-progress';
                    const track = document.createElement('div');
                    track.className = 'challenge-progress-track';
                    const fill = document.createElement('div');
                    fill.className = 'challenge-progress-fill';
                    const percent = Math.min(100, Math.max(0, challenge?.progressPercent ?? 0));
                    fill.style.width = `${percent}%`;
                    track.appendChild(fill);
                    progress.appendChild(track);
                    const label = document.createElement('div');
                    label.className = 'challenge-progress-label';
                    const progressText = document.createElement('span');
                    progressText.textContent = challenge?.progressText ?? '';
                    label.appendChild(progressText);
                    const percentText = document.createElement('span');
                    percentText.textContent = `${percent}%`;
                    label.appendChild(percentText);
                    progress.appendChild(label);
                    item.appendChild(progress);

                    const meta = document.createElement('div');
                    meta.className = 'challenge-meta';
                    const reward = document.createElement('span');
                    reward.textContent = `Reward: ${challenge?.rewardLabel ?? ''}`;
                    meta.appendChild(reward);
                    const status = document.createElement('span');
                    status.className = 'challenge-status';
                    status.textContent = challenge?.statusText ?? '';
                    meta.appendChild(status);
                    item.appendChild(meta);

                    const claimButton = document.createElement('button');
                    claimButton.type = 'button';
                    claimButton.className = 'challenge-claim';
                    if (challenge?.id) {
                        claimButton.dataset.challengeId = challenge.id;
                    }
                    claimButton.textContent = challenge?.buttonLabel ?? 'Claim Reward';
                    if (!challenge?.readyToClaim || challenge?.claimed) {
                        claimButton.disabled = true;
                    }
                    item.appendChild(claimButton);

                    challengeListEl.appendChild(item);
                }
            }

            function renderCosmeticOptions(snapshot = {}) {
                const cosmetics = snapshot?.cosmetics ?? {};
                const ownedSkins = new Set(Array.isArray(cosmetics.ownedSkins) ? cosmetics.ownedSkins : []);
                const ownedTrails = new Set(Array.isArray(cosmetics.ownedTrails) ? cosmetics.ownedTrails : []);
                const equipped = cosmetics.equipped ?? {};

                if (skinOptionsEl) {
                    skinOptionsEl.innerHTML = '';
                    const skinOrder = ['default', 'midnight', 'sunrise'];
                    for (const skinId of skinOrder) {
                        const skin = playerSkins[skinId];
                        if (!skin) {
                            continue;
                        }
                        const button = document.createElement('button');
                        button.type = 'button';
                        button.className = 'cosmetic-option';
                        button.dataset.skinId = skin.id;
                        button.textContent = skin.label;
                        const owned = ownedSkins.has(skin.id);
                        if (!owned) {
                            button.disabled = true;
                            button.classList.add('locked');
                            button.setAttribute('title', 'Unlock by completing challenges');
                        } else {
                            button.removeAttribute('title');
                        }
                        if (equipped?.skin === skin.id) {
                            button.classList.add('equipped');
                            button.setAttribute('aria-pressed', 'true');
                        } else {
                            button.setAttribute('aria-pressed', 'false');
                        }
                        skinOptionsEl.appendChild(button);
                    }
                }

                if (trailOptionsEl) {
                    trailOptionsEl.innerHTML = '';
                    const trailOrder = ['rainbow', 'aurora', 'ember'];
                    for (const trailId of trailOrder) {
                        const trail = trailStyles[trailId];
                        if (!trail) {
                            continue;
                        }
                        const button = document.createElement('button');
                        button.type = 'button';
                        button.className = 'cosmetic-option';
                        button.dataset.trailId = trail.id;
                        button.textContent = trail.label;
                        const owned = ownedTrails.has(trail.id);
                        if (!owned) {
                            button.disabled = true;
                            button.classList.add('locked');
                            button.setAttribute('title', 'Unlock by completing challenges');
                        } else {
                            button.removeAttribute('title');
                        }
                        if (equipped?.trail === trail.id) {
                            button.classList.add('equipped');
                            button.setAttribute('aria-pressed', 'true');
                        } else {
                            button.setAttribute('aria-pressed', 'false');
                        }
                        trailOptionsEl.appendChild(button);
                    }
                }
            }

            if (challengeListEl) {
                challengeListEl.addEventListener('click', (event) => {
                    const target = event.target instanceof HTMLElement ? event.target.closest('.challenge-claim') : null;
                    if (!target || target.disabled) {
                        return;
                    }
                    const challengeId = target.dataset.challengeId;
                    if (challengeId && challengeManager) {
                        challengeManager.claimReward(challengeId);
                    }
                });
            }

            if (skinOptionsEl) {
                skinOptionsEl.addEventListener('click', (event) => {
                    const target = event.target instanceof HTMLElement ? event.target.closest('[data-skin-id]') : null;
                    if (!target || target.disabled) {
                        return;
                    }
                    const skinId = target.dataset.skinId;
                    if (skinId && challengeManager) {
                        challengeManager.equipCosmetic('skin', skinId);
                    }
                });
            }

            if (trailOptionsEl) {
                trailOptionsEl.addEventListener('click', (event) => {
                    const target = event.target instanceof HTMLElement ? event.target.closest('[data-trail-id]') : null;
                    if (!target || target.disabled) {
                        return;
                    }
                    const trailId = target.dataset.trailId;
                    if (trailId && challengeManager) {
                        challengeManager.equipCosmetic('trail', trailId);
                    }
                });
            }

            function getShareText(summary) {
                if (!summary) return '';
                const formattedTime = formatTime(summary.timeMs);
                const streakText = summary.bestStreak ? ` x${summary.bestStreak}` : '';
                const core = `${summary.player} survived ${formattedTime} for ${summary.score.toLocaleString()} pts${streakText} in Nyan Escape.`;
                const quotaText = summary.recorded !== false && summary.runsToday ? ` Run ${summary.runsToday}/3 logged today.` : '';
                const pickups = summary.nyan ? ` Pickups: ${summary.nyan.toLocaleString()} energy.` : '';
                const placementText = summary.placement ? ` Ranked #${summary.placement} on the local galaxy board.` : '';
                const locationUrl = typeof window !== 'undefined' && window.location ? ` Play: ${window.location.href}` : '';
                return `${core}${quotaText}${pickups}${placementText}${locationUrl}`.trim();
            }

            function showShareStatus(message, type = 'info') {
                if (!shareStatusEl) return;
                shareStatusEl.textContent = message;
                shareStatusEl.className = '';
                if (type === 'success') {
                    shareStatusEl.classList.add('success');
                } else if (type === 'error') {
                    shareStatusEl.classList.add('error');
                }
            }

            function updateSharePanel() {
                if (shareButton) {
                    shareButton.disabled = !lastRunSummary;
                    shareButton.setAttribute('title', 'Open X to post your flight log');
                }
                if (copyShareButton) {
                    copyShareButton.disabled = !lastRunSummary;
                }
                if (!lastRunSummary) {
                    showShareStatus('Complete a run to generate a broadcast log.');
                } else if (lastRunSummary.reason === 'pending') {
                    showShareStatus('Submission pending. Log the run or skip to continue.');
                } else if (lastRunSummary.recorded === false && lastRunSummary.reason === 'limit') {
                    showShareStatus('Daily log limit reached. Share this flight manually to hype the squadron.');
                } else if (lastRunSummary.reason === 'skipped') {
                    showShareStatus('Run not logged. Share manually or fly again.');
                } else {
                    showShareStatus('Flight log ready. Share to X or copy it for later.');
                }
            }

            async function handleShareClick(event) {
                event?.preventDefault?.();
                if (!lastRunSummary) {
                    return;
                }

                const text = getShareText(lastRunSummary);
                const shareUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}`;
                let popup = null;

                try {
                    popup = typeof window !== 'undefined' && typeof window.open === 'function'
                        ? window.open(shareUrl, '_blank', 'noopener,width=600,height=640')
                        : null;
                } catch (error) {
                    popup = null;
                }

                if (popup) {
                    popup.focus?.();
                    showShareStatus('Flight log loaded into X. Finalize your post!', 'success');
                    return;
                }

                if (canNativeShare && typeof navigator !== 'undefined' && typeof navigator.share === 'function') {
                    try {
                        await navigator.share({
                            title: 'Nyan Escape  Flight Log',
                            text
                        });
                        showShareStatus('Flight log transmitted to the squadron!', 'success');
                        return;
                    } catch (error) {
                        if (error?.name === 'AbortError') {
                            return;
                        }
                    }
                }

                showShareStatus('Unable to open X. Allow pop-ups or copy the log manually.', 'error');
            }

            async function handleCopyShareClick(event) {
                event?.preventDefault?.();
                if (!lastRunSummary) {
                    return;
                }
                const text = getShareText(lastRunSummary);
                const clipboard = typeof navigator !== 'undefined' ? navigator.clipboard : null;
                try {
                    if (clipboard?.writeText) {
                        await clipboard.writeText(text);
                    } else {
                        const textarea = document.createElement('textarea');
                        textarea.value = text;
                        textarea.setAttribute('readonly', '');
                        textarea.style.position = 'absolute';
                        textarea.style.left = '-9999px';
                        document.body.appendChild(textarea);
                        textarea.select();
                        document.execCommand('copy');
                        document.body.removeChild(textarea);
                    }
                    showShareStatus('Flight log copied. Rally the crew!', 'success');
                } catch (error) {
                    showShareStatus('Clipboard unavailable. Manually copy from the log.', 'error');
                }
            }

            updateHighScorePanel();
            updateLeaderboardPanel();
            updateSocialFeedPanel();
            updateSharePanel();

            if (shareButton) {
                shareButton.addEventListener('click', handleShareClick);
            }
            if (copyShareButton) {
                copyShareButton.addEventListener('click', handleCopyShareClick);
            }

            if (highScoreTitleEl && typeof highScoreTitleEl.addEventListener === 'function') {
                highScoreTitleEl.addEventListener('click', () => {
                    if (!playerNameInput) {
                        return;
                    }
                    try {
                        playerNameInput.focus({ preventScroll: true });
                    } catch {
                        playerNameInput.focus();
                    }
                    playerNameInput.select?.();
                });
            }

            function loadCustomFont(fontFamily) {
                if (!document.fonts?.load) {
                    return Promise.resolve();
                }

                const variantsToLoad = [
                    `400 16px "${fontFamily}"`,
                    `700 16px "${fontFamily}"`
                ];

                return Promise.all(variantsToLoad.map((descriptor) => document.fonts.load(descriptor)))
                    .then(() => undefined)
                    .catch(() => undefined);
            }

            function showPreflightOverlay() {
                const message = overlayDefaultMessage || overlayMessage?.textContent || '';
                showOverlay(message, 'Launch Flight', {
                    title: overlayDefaultTitle,
                    enableButton: true,
                    launchMode: 'launch'
                });
            }

            function runCyborgLoadingSequence() {
                const finishBootSequence = () => {
                    showPreflightOverlay();
                };

                if (!loadingScreen || !loadingStatus) {
                    fontsReady.catch(() => undefined).then(() => {
                        finishBootSequence();
                    });
                    return;
                }

                const steps = [
                    'BOOTING CYBERNETICS KERNEL',
                    'CALIBRATING OPTIC RELAYS',
                    'DECRYPTING NAV MATRICES',
                    'AUTHORIZING FLIGHT SEQUENCE'
                ];

                let progress = 0;
                let stepIndex = 0;
                const maxIndex = steps.length - 1;

                const updateStatus = () => {
                    const prefix = `[SYS-BOOT:${String(stepIndex + 1).padStart(2, '0')}]`;
                    const percentText = `${progress.toString().padStart(3, '0')}%`;
                    loadingStatus.innerHTML = `
                        <span class="loading-prefix">${prefix}</span>
                        <span class="loading-line">${steps[Math.min(stepIndex, maxIndex)]}  <span class="loading-percent">${percentText}</span></span>
                    `;
                };

                const hideLoading = () => {
                    loadingScreen.classList.add('hidden');
                    setTimeout(() => {
                        if (loadingScreen.parentElement) {
                            loadingScreen.parentElement.removeChild(loadingScreen);
                        }
                    }, 520);
                };

                const finishLoading = () => {
                    fontsReady.catch(() => undefined).then(() => {
                        hideLoading();
                        finishBootSequence();
                    });
                };

                const advance = () => {
                    const increment = Math.floor(Math.random() * 11) + 4;
                    progress = Math.min(progress + increment, 100);
                    stepIndex = Math.min(maxIndex, Math.floor((progress / 100) * steps.length));
                    updateStatus();

                    if (progress >= 100) {
                        setTimeout(finishLoading, 480);
                        return;
                    }

                    const delay = Math.random() * 320 + 160;
                    setTimeout(advance, delay);
                };

                updateStatus();
                setTimeout(advance, 420);
            }

            function preloadImages(sources) {
                if (!Array.isArray(sources) || sources.length === 0) {
                    return Promise.resolve([]);
                }
                const validSources = sources.filter((src) => typeof src === 'string' && src.length);
                if (validSources.length === 0) {
                    return Promise.resolve([]);
                }
                return Promise.all(validSources.map((src) => new Promise((resolve) => {
                    const img = new Image();
                    img.onload = resolve;
                    img.onerror = resolve;
                    img.src = src;
                })));
            }

            function setLayerBackground(layer, src) {
                if (layer) {
                    layer.style.backgroundImage = `url('${src}')`;
                }
            }

            function showLayer(layer) {
                if (layer) {
                    layer.classList.add('visible');
                }
            }

            function hideLayer(layer) {
                if (layer) {
                    layer.classList.remove('visible');
                }
            }

            function cycleBackground() {
                if (backgroundImages.length <= 1) {
                    return;
                }
                const nextIndex = (currentBackgroundIndex + 1) % backgroundImages.length;
                const nextLayerIndex = 1 - activeLayerIndex;
                const nextLayer = backgroundLayers[nextLayerIndex];
                const currentLayer = backgroundLayers[activeLayerIndex];

                setLayerBackground(nextLayer, backgroundImages[nextIndex]);

                requestAnimationFrame(() => {
                    showLayer(nextLayer);
                    hideLayer(currentLayer);
                    activeLayerIndex = nextLayerIndex;
                    currentBackgroundIndex = nextIndex;
                });
            }

            preloadImages(backgroundImages).then(() => {
                setLayerBackground(backgroundLayers[activeLayerIndex], backgroundImages[currentBackgroundIndex]);
                showLayer(backgroundLayers[activeLayerIndex]);
                if (backgroundImages.length > 1) {
                    setLayerBackground(backgroundLayers[1 - activeLayerIndex], backgroundImages[(currentBackgroundIndex + 1) % backgroundImages.length]);
                    setInterval(cycleBackground, backgroundChangeInterval);
                }
            });

            const skinOverrides =
                cosmeticOverrides.skins && typeof cosmeticOverrides.skins === 'object'
                    ? cosmeticOverrides.skins
                    : {};
            const playerBaseImage = loadImageWithFallback(
                resolveAssetConfig(assetOverrides.player, 'assets/player.png'),
                createPlayerFallbackDataUrl
            );
            const playerSkins = {
                default: {
                    id: 'default',
                    label: 'Standard Hull',
                    image: playerBaseImage
                },
                midnight: {
                    id: 'midnight',
                    label: 'Midnight Mirage',
                    image: loadImageWithFallback(resolveAssetConfig(skinOverrides.midnight, null), () =>
                        createPlayerVariantDataUrl('midnight')
                    )
                },
                sunrise: {
                    id: 'sunrise',
                    label: 'Sunrise Shimmer',
                    image: loadImageWithFallback(resolveAssetConfig(skinOverrides.sunrise, null), () =>
                        createPlayerVariantDataUrl('sunrise')
                    )
                }
            };
            const trailStyles = {
                rainbow: { id: 'rainbow', label: 'Prismatic Stream', type: 'spectrum' },
                aurora: {
                    id: 'aurora',
                    label: 'Aurora Wake',
                    type: 'palette',
                    colors: ['#38bdf8', '#8b5cf6', '#ec4899', '#22d3ee']
                },
                ember: {
                    id: 'ember',
                    label: 'Ember Wake',
                    type: 'palette',
                    colors: ['#f97316', '#fb7185', '#fde047']
                }
            };
            const cosmeticsCatalog = {
                skins: playerSkins,
                trails: {
                    rainbow: trailStyles.rainbow,
                    aurora: trailStyles.aurora,
                    ember: trailStyles.ember
                }
            };
            let activePlayerImage = playerBaseImage;
            let activeTrailStyle = trailStyles.rainbow;
            const challengeManager = createChallengeManager({
                definitions: CHALLENGE_DEFINITIONS,
                cosmeticsCatalog,
                onChallengeCompleted: (definition) => {
                    const title = definition?.title ?? 'Challenge';
                    addSocialMoment(`${title} complete!`, { type: 'challenge' });
                },
                onRewardClaimed: (definition, reward) => {
                    const rewardLabel = describeReward(reward);
                    const title = definition?.title ?? 'Challenge';
                    addSocialMoment(`${title}: ${rewardLabel}`, { type: 'challenge' });
                }
            });
            if (challengeManager && typeof challengeManager.subscribe === 'function') {
                challengeManager.subscribe((snapshot) => {
                    renderChallengeList(snapshot);
                    renderCosmeticOptions(snapshot);
                    applyEquippedCosmetics(snapshot?.cosmetics?.equipped);
                });
            } else {
                applyEquippedCosmetics();
            }

            const asteroidImageSources =
                Array.isArray(assetOverrides.asteroids) && assetOverrides.asteroids.length
                    ? assetOverrides.asteroids
                    : ['assets/asteroid1.png', 'assets/asteroid2.png', 'assets/asteroid3.png'];
            const asteroidImages = asteroidImageSources.map((entry, index) =>
                loadImageWithFallback(resolveAssetConfig(entry, null), () => createAsteroidFallbackDataUrl(index))
            );

            const powerUpOverrides =
                assetOverrides.powerUps && typeof assetOverrides.powerUps === 'object' ? assetOverrides.powerUps : {};
            const powerUpImageSources = {
                powerBomb: 'assets/powerbomb.png',
                bulletSpread: 'assets/powerburger.png',
                missiles: 'assets/powerpizza.png',
                hyperBeam: 'assets/powerbeam.svg',
                pumpDrive: 'assets/pump.png'
            };

            const powerUpImages = {};
            for (const [type, defaultSrc] of Object.entries(powerUpImageSources)) {
                powerUpImages[type] = loadImageWithFallback(
                    resolveAssetConfig(powerUpOverrides[type], defaultSrc),
                    () => defaultSrc
                );
            }

            const defaultCollectScore = 80;

            const defaultConfig = {
                baseGameSpeed: 160,
                speedGrowth: 5,
                obstacleSpawnInterval: 950,
                collectibleSpawnInterval: 1400,
                powerUpSpawnInterval: 11000,
                trailSpacing: 18,
                baseTrailLength: 20,
                trailGrowthPerStreak: 0.4,
                tailSmoothing: {
                    growth: 32,
                    shrink: 64
                },
                comboDecayWindow: 3200,
                projectileCooldown: 200,
                projectileSpeed: 900,
                difficulty: {
                    rampDuration: 90000,
                    speedRamp: { start: 0.28, end: 0.9 },
                    spawnIntensity: {
                        obstacle: { start: 0.38, end: 1.08 },
                        collectible: { start: 0.68, end: 1.02 },
                        powerUp: { start: 0.58, end: 0.95 }
                    },
                    healthRamp: { start: 0.7, end: 1.25 }
                },
                player: {
                    width: 120,
                    height: 120,
                    acceleration: 2100,
                    drag: 5.2,
                    maxSpeed: 480,
                    verticalBleed: 0.069,
                    dash: {
                        boostSpeed: 960,
                        duration: 220,
                        doubleTapWindow: 260,
                        dragMultiplier: 0.35
                    }
                },
                obstacle: {
                    minSize: 42,
                    maxSize: 128,
                    minSpeed: -20,
                    maxSpeed: 70
                },
                collectible: {
                    size: 42,
                    minSpeed: -30,
                    maxSpeed: 30,
                    verticalPadding: 48
                },
                powerUp: {
                    size: 85,
                    minSpeed: -20,
                    maxSpeed: 20,
                    wobbleAmplitude: 28,
                    wobbleSpeed: 3.4,
                    duration: {
                        powerBomb: 5200,
                        bulletSpread: 6200,
                        missiles: 5600,
                        hyperBeam: 5600,
                        radiantShield: 7200,
                        pumpDrive: 6200
                    }
                },
                hyperBeam: {
                    beamHeight: 190,
                    extraLength: 60,
                    rampUp: 280,
                    fadeOut: 220,
                    damagePerSecond: 24,
                    asteroidDamagePerSecond: 30,
                    sparkInterval: 140,
                    hitSparkRate: 7,
                    jitterAmplitude: 18,
                    waveSpeed: 0.006
                },
                defensePower: {
                    clearance: 18,
                    obstacleBounceDuration: 620,
                    obstacleKnockback: 520,
                    obstacleSpeedMultiplier: 1.15,
                    asteroidKnockback: 460,
                    hitCooldown: 520,
                    particleColor: { r: 148, g: 210, b: 255 },
                    auraColor: { r: 150, g: 214, b: 255 },
                    auraPulse: 0.18,
                    bounceDrag: 3.6
                },
                star: {
                    count: 120,
                    baseSpeed: 120
                },
                asteroid: {
                    initialCount: 4,
                    maxCount: 6,
                    spawnInterval: 2600,
                    clusterRadius: 160,
                    minSpacing: 14,
                    scale: 0.4,
                    bounceRestitution: 0.88,
                    collisionRadiusMultiplier: 0.88,
                    sizeRange: [90, 210],
                    speedRange: [40, 140],
                    rotationSpeedRange: [-0.6, 0.6],
                    driftRange: [-18, 18],
                    depthRange: [0.35, 1],
                    meteorShowerInterval: 22000,
                    meteorShowerVariance: 8000,
                    meteorShowerCount: 5,
                    meteorShowerSpeedMultiplier: 1.15
                },
                comboMultiplierStep: 0.15,
                score: {
                    collect: defaultCollectScore,
                    destroy: 120,
                    asteroid: 60,
                    dodge: 18,
                    villainEscape: 140
                }
            };

            const config = applyOverrides(cloneConfig(defaultConfig), gameplayOverrides ?? {});
            const baseCollectScoreRaw = config?.score?.collect;
            const baseCollectScore = Number.isFinite(Number(baseCollectScoreRaw))
                ? Math.max(1, Number(baseCollectScoreRaw))
                : defaultCollectScore;
            if (!config.score || !isPlainObject(config.score)) {
                config.score = { ...defaultConfig.score };
            }
            config.score.collect = baseCollectScore;

            const collectibleTiers = [
                {
                    key: 'point',
                    label: 'POINT',
                    src: 'assets/point.png',
                    points: baseCollectScore,
                    weight: 0.62,
                    sizeMultiplier: 1,
                    glow: {
                        inner: 'rgba(255, 215, 0, 0.9)',
                        outer: 'rgba(255, 215, 0, 0.25)'
                    },
                    particleColor: { r: 255, g: 215, b: 0 }
                },
                {
                    key: 'point2',
                    label: 'POINT+',
                    src: 'assets/point2.png',
                    points: Math.round(baseCollectScore * 1.75),
                    weight: 0.26,
                    sizeMultiplier: 1.08,
                    glow: {
                        inner: 'rgba(96, 165, 250, 0.9)',
                        outer: 'rgba(96, 165, 250, 0.22)'
                    },
                    particleColor: { r: 96, g: 165, b: 250 }
                },
                {
                    key: 'point3',
                    label: 'POINT++',
                    src: 'assets/point3.png',
                    points: Math.round(baseCollectScore * 2.5),
                    weight: 0.12,
                    sizeMultiplier: 1.16,
                    glow: {
                        inner: 'rgba(192, 132, 252, 0.95)',
                        outer: 'rgba(192, 132, 252, 0.28)'
                    },
                    particleColor: { r: 192, g: 132, b: 252 }
                }
            ];

            const collectibleOverrides =
                assetOverrides.collectibles && typeof assetOverrides.collectibles === 'object'
                    ? assetOverrides.collectibles
                    : {};
            for (const tier of collectibleTiers) {
                tier.asset = resolveAssetConfig(collectibleOverrides[tier.key], tier.src ?? null);
                if (typeof tier.asset === 'string') {
                    tier.src = tier.asset;
                } else if (tier.asset && typeof tier.asset === 'object' && typeof tier.asset.src === 'string') {
                    tier.src = tier.asset.src;
                }
            }

            const collectibleImages = {};
            for (const tier of collectibleTiers) {
                const fallbackSrc = createCollectibleFallbackDataUrl(tier);
                const assetConfig = tier.asset ?? tier.src ?? null;
                collectibleImages[tier.key] = loadImageWithFallback(
                    assetConfig ?? fallbackSrc,
                    () => fallbackSrc ?? tier.src ?? null
                );
            }

            const totalCollectibleWeight = collectibleTiers.reduce((sum, tier) => sum + tier.weight, 0);

            const state = {
                score: 0,
                nyan: 0,
                streak: 0,
                bestStreak: 0,
                tailLength: config.baseTrailLength,
                tailTarget: config.baseTrailLength,
                comboTimer: 0,
                gameSpeed: config.baseGameSpeed,
                timeSinceLastShot: 0,
                gameState: 'ready',
                elapsedTime: 0,
                powerUpTimers: {
                    powerBomb: 0,
                    bulletSpread: 0,
                    missiles: 0,
                    hyperBeam: 0,
                    radiantShield: 0,
                    pumpDrive: 0
                },
                powerBombPulseTimer: 0,
                lastVillainKey: null,
                recentVillains: [],
                meteorShowerTimer: 0,
                nextMeteorShower: 0,
                dashTimer: 0,
                shieldHitPulse: 0,
                bossBattle: {
                    triggered: false,
                    active: false,
                    bossSpawned: false,
                    defeated: false,
                    powerUpSpawned: false,
                    alertTimer: 0
                }
            };

            updateTimerDisplay();

            const keys = new Set();
            const dashTapTracker = new Map();
            const formControlSelector = 'input, textarea, select, button, [role="button"], [contenteditable="true"]';
            const textEntrySelector = [
                'textarea',
                '[contenteditable="true"]',
                'input:not([type])',
                'input[type="text"]',
                'input[type="search"]',
                'input[type="email"]',
                'input[type="password"]',
                'input[type="tel"]',
                'input[type="url"]',
                'input[type="number"]'
            ].join(',');

            function isFormControlTarget(target) {
                if (!target || typeof target.closest !== 'function') {
                    return false;
                }
                return Boolean(target.closest(formControlSelector));
            }

            function isTextEntryTarget(target) {
                if (!target || typeof target.closest !== 'function') {
                    return false;
                }
                return Boolean(target.closest(textEntrySelector));
            }
            const keyAliasMap = {
                ArrowUp: 'ArrowUp',
                Up: 'ArrowUp',
                Numpad8: 'ArrowUp',
                ArrowDown: 'ArrowDown',
                Down: 'ArrowDown',
                Numpad2: 'ArrowDown',
                ArrowLeft: 'ArrowLeft',
                Left: 'ArrowLeft',
                Numpad4: 'ArrowLeft',
                ArrowRight: 'ArrowRight',
                Right: 'ArrowRight',
                Numpad6: 'ArrowRight',
                Space: 'Space',
                Spacebar: 'Space',
                ' ': 'Space'
            };
            const preventDefaultKeys = new Set([
                'ArrowUp',
                'ArrowDown',
                'ArrowLeft',
                'ArrowRight',
                'KeyW',
                'KeyA',
                'KeyS',
                'KeyD',
                'Space'
            ]);
            function normalizeKey(event) {
                const { code, key } = event;
                if (code && keyAliasMap[code]) {
                    return keyAliasMap[code];
                }
                if (code) {
                    return code;
                }
                if (key && keyAliasMap[key]) {
                    return keyAliasMap[key];
                }
                if (key && key.length === 1) {
                    const upper = key.toUpperCase();
                    if (upper >= 'A' && upper <= 'Z') {
                        return `Key${upper}`;
                    }
                }
                return key ?? code;
            }
            const dashDirections = {
                ArrowUp: { x: 0, y: -1 },
                KeyW: { x: 0, y: -1 },
                ArrowDown: { x: 0, y: 1 },
                KeyS: { x: 0, y: 1 },
                ArrowLeft: { x: -1, y: 0 },
                KeyA: { x: -1, y: 0 },
                ArrowRight: { x: 1, y: 0 },
                KeyD: { x: 1, y: 0 }
            };
            const virtualInput = {
                moveX: 0,
                moveY: 0,
                firing: false,
                smoothedX: 0,
                smoothedY: 0
            };
            const joystickState = {
                pointerId: null,
                touchId: null
            };
            let firePointerId = null;
            let fireTouchId = null;
            const projectiles = [];
            const obstacles = [];
            const collectibles = [];
            const powerUps = [];
            const stars = [];
            const asteroids = [];
            let asteroidSpawnTimer = 0;
            const particles = [];
            const villainExplosions = [];
            const trail = [];
            const pumpTailState = {
                active: false,
                bars: [],
                waveTime: 0,
                fade: 0,
                amplitude: 1,
                frequency: 1.6,
                spread: 220,
                baseHeight: 160,
                centerX: 0,
                releasePending: false,
                segments: []
            };
            const areaBursts = [];
            const floatingTexts = [];
            const cameraShake = { intensity: 0, duration: 0, elapsed: 0, offsetX: 0, offsetY: 0 };
            const hyperBeamState = {
                intensity: 0,
                wave: 0,
                sparkTimer: 0,
                bounds: null
            };
            const spawnTimers = {
                obstacle: 0,
                collectible: 0,
                powerUp: 0
            };

            const HYPER_BEAM_POWER = 'hyperBeam';
            const SHIELD_POWER = 'radiantShield';
            const PUMP_POWER = 'pumpDrive';
            const powerUpTypes = ['powerBomb', 'bulletSpread', 'missiles', HYPER_BEAM_POWER, SHIELD_POWER, PUMP_POWER];
            const powerUpLabels = {
                powerBomb: 'Nova Pulse',
                bulletSpread: 'Starlight Spread',
                missiles: 'Comet Missiles',
                [HYPER_BEAM_POWER]: 'Hyper Beam',
                [SHIELD_POWER]: 'Radiant Shield',
                [PUMP_POWER]: 'Pump Drive'
            };
            const powerUpColors = {
                powerBomb: { r: 255, g: 168, b: 112 },
                bulletSpread: { r: 255, g: 128, b: 255 },
                missiles: { r: 255, g: 182, b: 92 },
                [HYPER_BEAM_POWER]: { r: 147, g: 197, b: 253 },
                [SHIELD_POWER]: { r: 148, g: 210, b: 255 },
                [PUMP_POWER]: { r: 255, g: 99, b: 247 }
            };

            const villainExplosionPalettes = {
                villain1: {
                    core: { r: 255, g: 170, b: 255 },
                    halo: { r: 140, g: 195, b: 255 },
                    spark: { r: 210, g: 240, b: 255 }
                },
                villain2: {
                    core: { r: 120, g: 255, b: 214 },
                    halo: { r: 90, g: 200, b: 255 },
                    spark: { r: 180, g: 255, b: 220 }
                },
                villain3: {
                    core: { r: 255, g: 120, b: 160 },
                    halo: { r: 255, g: 200, b: 120 },
                    spark: { r: 255, g: 180, b: 140 }
                },
                boss: {
                    core: { r: 255, g: 105, b: 180 },
                    halo: { r: 120, g: 190, b: 255 },
                    spark: { r: 240, g: 255, b: 255 }
                }
            };

            const BOSS_EVENT_TIME_MS = 60000;
            const BOSS_ALERT_DURATION = 2000;
            const bossVillainType = {
                key: 'boss',
                name: 'Celestial Behemoth',
                imageSrc: 'assets/boss1.png',
                width: 220,
                height: 220,
                health: 36,
                rotation: { min: 0, max: 0 },
                behavior: { type: 'hover', amplitude: 72, verticalSpeed: 70 }
            };

            const villainTypes = [
                {
                    key: 'villain1',
                    name: 'Void Raider',
                    imageSrc: 'assets/villain1.png',
                    size: { min: 44, max: 58 },
                    speedOffset: { min: 14, max: 34 },
                    rotation: { min: -1.8, max: 1.8 },
                    baseHealth: 1,
                    healthGrowth: 0.7,
                    behavior: { type: 'sine', amplitude: 36, speed: 2.8 }
                },
                {
                    key: 'villain2',
                    name: 'Nebula Marauder',
                    imageSrc: 'assets/villain2.png',
                    size: { min: 70, max: 96 },
                    speedOffset: { min: 8, max: 30 },
                    rotation: { min: -1.4, max: 1.4 },
                    baseHealth: 2.3,
                    healthGrowth: 1.2,
                    behavior: { type: 'drift', verticalSpeed: 120 }
                },
                {
                    key: 'villain3',
                    name: 'Abyss Overlord',
                    imageSrc: 'assets/villain3.png',
                    size: { min: 102, max: 138 },
                    speedOffset: { min: -2, max: 32 },
                    rotation: { min: -1, max: 1 },
                    baseHealth: 3.4,
                    healthGrowth: 1.8,
                    behavior: { type: 'tracker', acceleration: 200, maxSpeed: 260 }
                }
            ];

            const villainOverrides =
                assetOverrides.villains && typeof assetOverrides.villains === 'object'
                    ? assetOverrides.villains
                    : {};
            for (const villain of villainTypes) {
                villain.asset = resolveAssetConfig(villainOverrides[villain.key], villain.imageSrc);
                if (typeof villain.asset === 'string') {
                    villain.imageSrc = villain.asset;
                } else if (villain.asset && typeof villain.asset === 'object' && typeof villain.asset.src === 'string') {
                    villain.imageSrc = villain.asset.src;
                }
            }

            function getVillainWeights() {
                const progress = getDifficultyProgress();
                const eased = easeInOutQuad(progress);
                const baseWeights = [0.55, 0.32, 0.13];
                const villain2Boost = lerp(0, 0.12, eased);
                const villain3Boost = lerp(0, 0.07, Math.pow(progress, 1.4));

                const weights = [
                    Math.max(0.28, baseWeights[0] - (villain2Boost * 0.45 + villain3Boost)),
                    baseWeights[1] + villain2Boost,
                    Math.max(0.08, baseWeights[2] + villain3Boost)
                ];

                const total = weights.reduce((sum, weight) => sum + weight, 0);
                return weights.map((weight) => (total > 0 ? weight / total : 1 / weights.length));
            }

            function selectVillainType() {
                const weights = getVillainWeights();
                const adjustedWeights = [...weights];

                if (state.lastVillainKey) {
                    const lastIndex = villainTypes.findIndex((villain) => villain.key === state.lastVillainKey);
                    if (lastIndex >= 0) {
                        adjustedWeights[lastIndex] *= 0.45;
                    }
                }

                if (state.recentVillains.length) {
                    const recentCounts = {};
                    for (const key of state.recentVillains) {
                        recentCounts[key] = (recentCounts[key] ?? 0) + 1;
                    }
                    const historySize = Math.max(1, state.recentVillains.length);
                    for (let i = 0; i < villainTypes.length; i++) {
                        const key = villainTypes[i].key;
                        const recentCount = recentCounts[key] ?? 0;
                        if (recentCount > 0) {
                            const dampen = 1 + recentCount / historySize;
                            adjustedWeights[i] /= dampen;
                        }
                    }
                }

                if (villainTypes.length > 0) {
                    adjustedWeights[villainTypes.length - 1] *= 0.85;
                }

                const adjustedTotal = adjustedWeights.reduce((sum, weight) => sum + weight, 0);
                const normalizedTotal = adjustedTotal > 0 ? adjustedTotal : 1;
                const roll = Math.random();
                let cumulative = 0;

                for (let i = 0; i < villainTypes.length; i++) {
                    cumulative += adjustedWeights[i] / normalizedTotal;
                    if (roll <= cumulative) {
                        return villainTypes[i];
                    }
                }

                return villainTypes[villainTypes.length - 1];
            }

            const villainImages = {};
            for (const [index, villain] of villainTypes.entries()) {
                const image = loadImageWithFallback(
                    villain.asset ?? villain.imageSrc,
                    () => createVillainFallbackDataUrl(index) ?? villain.imageSrc
                );
                villainImages[villain.key] = image;
                villain.image = image;
            }

            const bossImage = loadImageWithFallback(
                bossVillainType.imageSrc,
                () => createVillainFallbackDataUrl(0) ?? bossVillainType.imageSrc
            );
            bossVillainType.image = bossImage;

            player = {
                x: viewport.width * 0.18,
                y: viewport.height * 0.5,
                width: config.player.width,
                height: config.player.height,
                vx: 0,
                vy: 0
            };

            function resetGame() {
                state.score = 0;
                state.nyan = 0;
                state.streak = 0;
                state.bestStreak = 0;
                state.tailLength = config.baseTrailLength;
                state.tailTarget = config.baseTrailLength;
                state.comboTimer = 0;
                state.gameSpeed = config.baseGameSpeed;
                state.timeSinceLastShot = 0;
                state.elapsedTime = 0;
                state.powerUpTimers.powerBomb = 0;
                state.powerUpTimers.bulletSpread = 0;
                state.powerUpTimers.missiles = 0;
                state.powerUpTimers.radiantShield = 0;
                state.powerUpTimers[HYPER_BEAM_POWER] = 0;
                state.powerUpTimers.pumpDrive = 0;
                state.powerBombPulseTimer = 0;
                state.shieldHitPulse = 0;
                state.lastVillainKey = null;
                state.recentVillains.length = 0;
                state.dashTimer = 0;
                state.bossBattle.triggered = false;
                state.bossBattle.active = false;
                state.bossBattle.bossSpawned = false;
                state.bossBattle.defeated = false;
                state.bossBattle.powerUpSpawned = false;
                state.bossBattle.alertTimer = 0;
                hyperBeamState.intensity = 0;
                hyperBeamState.wave = 0;
                hyperBeamState.sparkTimer = 0;
                hyperBeamState.bounds = null;
                player.x = viewport.width * 0.18;
                player.y = viewport.height * 0.5;
                player.vx = 0;
                player.vy = 0;
                projectiles.length = 0;
                obstacles.length = 0;
                collectibles.length = 0;
                powerUps.length = 0;
                villainExplosions.length = 0;
                particles.length = 0;
                trail.length = 0;
                pumpTailState.active = false;
                pumpTailState.bars.length = 0;
                pumpTailState.fade = 0;
                pumpTailState.waveTime = 0;
                pumpTailState.releasePending = false;
                pumpTailState.centerX = 0;
                areaBursts.length = 0;
                spawnTimers.obstacle = 0;
                spawnTimers.collectible = 0;
                spawnTimers.powerUp = 0;
                state.meteorShowerTimer = 0;
                state.nextMeteorShower = 0;
                audioManager.stopHyperBeam();
                createInitialStars();
                scheduleNextMeteorShower();
                comboFillEl.style.width = '100%';
                if (comboMeterEl) {
                    comboMeterEl.setAttribute('aria-valuenow', '100');
                }
                lastComboPercent = 100;
                lastFormattedTimer = '';
                updateHUD();
                updateTimerDisplay();
                resetVirtualControls();
            }

            function createInitialStars() {
                stars.length = 0;
                for (let i = 0; i < config.star.count; i++) {
                    stars.push({
                        x: Math.random() * viewport.width,
                        y: Math.random() * viewport.height,
                        speed: (Math.random() * 0.8 + 0.4) * config.star.baseSpeed,
                        size: Math.random() * 2.5 + 0.6,
                        twinkleOffset: Math.random() * Math.PI * 2
                    });
                }
            }

            function createAsteroid(initial = false) {
                const settings = config.asteroid;
                const scale = settings?.scale ?? 1;
                const depth = randomBetween(settings.depthRange[0], settings.depthRange[1]);
                const baseSize = lerp(settings.sizeRange[0], settings.sizeRange[1], depth);
                const size = baseSize * scale;
                const asteroid = {
                    depth,
                    baseSize,
                    size,
                    radius: size * 0.5,
                    mass: Math.max(1, size * size * 0.0004),
                    speed: lerp(settings.speedRange[0], settings.speedRange[1], depth),
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed:
                        randomBetween(settings.rotationSpeedRange[0], settings.rotationSpeedRange[1]) *
                        (0.4 + depth),
                    drift:
                        randomBetween(settings.driftRange[0], settings.driftRange[1]) *
                        Math.max(0.12, 1 - depth * 0.6),
                    vx: 0,
                    vy: 0,
                    x: 0,
                    y: 0,
                    image: asteroidImages[Math.floor(Math.random() * asteroidImages.length)] ?? null,
                    bobOffset: Math.random() * Math.PI * 2,
                    health: Math.max(1, Math.round(size / 32)),
                    hitFlash: 0,
                    shieldCooldown: 0
                };
                placeAsteroid(asteroid, initial);
                asteroid.vx = -asteroid.speed * (0.6 + asteroid.depth * 0.8);
                asteroid.vy = asteroid.drift;
                return asteroid;
            }

            function placeAsteroid(asteroid, initial = false) {
                const settings = config.asteroid ?? {};
                const clusterRadius = settings.clusterRadius ?? 160;
                const minSpacing = settings.minSpacing ?? 12;
                const spawnOffset = settings.spawnOffset ?? 140;
                const attempts = settings.placementAttempts ?? 24;

                for (let attempt = 0; attempt < attempts; attempt++) {
                    let anchor = null;
                    if (asteroids.length && (initial || Math.random() < 0.85)) {
                        anchor = asteroids[Math.floor(Math.random() * asteroids.length)];
                    }

                    let candidateX;
                    let candidateY;

                    if (anchor) {
                        candidateX = anchor.x + randomBetween(-clusterRadius, clusterRadius);
                        if (!initial) {
                            candidateX = Math.max(candidateX, viewport.width - clusterRadius * 0.8);
                        }
                        candidateY = anchor.y + randomBetween(-clusterRadius * 0.6, clusterRadius * 0.6);
                    } else if (initial) {
                        candidateX = Math.random() * viewport.width;
                        candidateY = Math.random() * viewport.height;
                    } else {
                        candidateX = viewport.width + spawnOffset + Math.random() * clusterRadius;
                        candidateY = Math.random() * viewport.height;
                    }

                    candidateX = clamp(candidateX, asteroid.radius + minSpacing, viewport.width + clusterRadius);
                    candidateY = clamp(
                        candidateY,
                        asteroid.radius + minSpacing,
                        viewport.height - asteroid.radius - minSpacing
                    );

                    let overlaps = false;
                    for (const other of asteroids) {
                        const dx = other.x - candidateX;
                        const dy = other.y - candidateY;
                        const minDist = asteroid.radius + other.radius + minSpacing;
                        if (dx * dx + dy * dy < minDist * minDist) {
                            overlaps = true;
                            break;
                        }
                    }

                    if (!overlaps) {
                        asteroid.x = candidateX;
                        asteroid.y = candidateY;
                        return;
                    }
                }

                asteroid.x = initial ? Math.random() * viewport.width : viewport.width + asteroid.size;
                asteroid.y = clamp(Math.random() * viewport.height, asteroid.radius, viewport.height - asteroid.radius);
            }

            function resolveAsteroidCollisions() {
                if (asteroids.length < 2) return;
                const settings = config.asteroid ?? {};
                const minSpacing = settings.minSpacing ?? 12;
                const restitution = settings.bounceRestitution ?? 0.9;

                for (let i = 0; i < asteroids.length - 1; i++) {
                    const a = asteroids[i];
                    for (let j = i + 1; j < asteroids.length; j++) {
                        const b = asteroids[j];
                        const dx = b.x - a.x;
                        const dy = b.y - a.y;
                        const minDistance = a.radius + b.radius + minSpacing;
                        const distanceSq = dx * dx + dy * dy;
                        if (distanceSq === 0 || distanceSq >= minDistance * minDistance) {
                            continue;
                        }

                        const distance = Math.sqrt(distanceSq);
                        const nx = dx / distance;
                        const ny = dy / distance;
                        const overlap = minDistance - distance;
                        const massA = a.mass ?? 1;
                        const massB = b.mass ?? 1;
                        const totalMass = massA + massB;

                        const moveA = overlap * (massB / totalMass);
                        const moveB = overlap * (massA / totalMass);

                        a.x -= nx * moveA;
                        a.y -= ny * moveA;
                        b.x += nx * moveB;
                        b.y += ny * moveB;

                        const relativeVelocity = (a.vx - b.vx) * nx + (a.vy - b.vy) * ny;
                        if (relativeVelocity > 0) {
                            continue;
                        }

                        const impulse = -(1 + restitution) * relativeVelocity;
                        const impulsePerMassA = impulse * (massB / totalMass);
                        const impulsePerMassB = impulse * (massA / totalMass);

                        a.vx += nx * impulsePerMassA;
                        a.vy += ny * impulsePerMassA;
                        b.vx -= nx * impulsePerMassB;
                        b.vy -= ny * impulsePerMassB;
                    }
                }
            }

            function createInitialAsteroids() {
                asteroids.length = 0;
                asteroidSpawnTimer = 0;
                const settings = config.asteroid ?? {};
                const count = settings.initialCount ?? settings.maxCount ?? 0;
                for (let i = 0; i < count; i++) {
                    asteroids.push(createAsteroid(true));
                }
                resolveAsteroidCollisions();
            }

            function scheduleNextMeteorShower() {
                const settings = config.asteroid ?? {};
                const interval = settings.meteorShowerInterval ?? 0;
                state.meteorShowerTimer = 0;
                if (!interval || interval <= 0) {
                    state.nextMeteorShower = 0;
                    return;
                }
                const variance = settings.meteorShowerVariance ?? 0;
                if (!variance) {
                    state.nextMeteorShower = interval;
                    return;
                }
                const minInterval = Math.max(2000, interval - variance);
                const maxInterval = interval + variance;
                state.nextMeteorShower = randomBetween(minInterval, maxInterval);
            }

            function spawnMeteorShower() {
                const settings = config.asteroid ?? {};
                const formation = settings.meteorShowerFormation ?? [
                    { x: 0, y: 0 },
                    { x: 70, y: -56 },
                    { x: 70, y: 56 },
                    { x: 140, y: -112 },
                    { x: 140, y: 112 }
                ];
                const desiredCount = settings.meteorShowerCount ?? formation.length;
                if (!desiredCount || desiredCount < 1) {
                    return false;
                }

                const offsets = formation.slice(0, desiredCount);
                if (!offsets.length) {
                    return false;
                }

                const required = offsets.length;
                if (settings.maxCount && required > settings.maxCount) {
                    return false;
                }
                if (settings.maxCount && asteroids.length + required > settings.maxCount) {
                    const excess = asteroids.length + required - settings.maxCount;
                    if (excess > 0) {
                        const removable = asteroids
                            .map((asteroid, index) => ({ index, x: asteroid.x }))
                            .sort((a, b) => b.x - a.x)
                            .slice(0, excess)
                            .map((item) => item.index)
                            .sort((a, b) => b - a);
                        for (const removeIndex of removable) {
                            asteroids.splice(removeIndex, 1);
                        }
                    }
                }

                const spawnOffset = settings.spawnOffset ?? 140;
                const spawnX = viewport.width + spawnOffset;
                const scale = settings.scale ?? 1;
                const minSize = Array.isArray(settings.sizeRange) ? settings.sizeRange[0] ?? 40 : 40;
                const actualSize = minSize * scale;
                const minSpacing = settings.minSpacing ?? 12;
                const minY = actualSize * 0.5 + minSpacing;
                const maxY = viewport.height - actualSize * 0.5 - minSpacing;
                const centerY = clamp(Math.random() * (maxY - minY) + minY, minY, maxY);
                const speedMultiplier = settings.meteorShowerSpeedMultiplier ?? 1;

                let spawnedAny = false;
                for (const offset of offsets) {
                    const asteroid = createAsteroid(false);
                    asteroid.depth = settings.depthRange ? settings.depthRange[0] : asteroid.depth;
                    asteroid.baseSize = minSize;
                    asteroid.size = actualSize;
                    asteroid.radius = asteroid.size * 0.5;
                    asteroid.mass = Math.max(1, asteroid.size * asteroid.size * 0.0004);
                    const hasSpeedRange = Array.isArray(settings.speedRange);
                    const baseSpeed = hasSpeedRange
                        ? lerp(settings.speedRange[0], settings.speedRange[1], 1)
                        : asteroid.speed;
                    asteroid.speed = baseSpeed * speedMultiplier;
                    asteroid.rotationSpeed = randomBetween(
                        settings.rotationSpeedRange?.[0] ?? -0.6,
                        settings.rotationSpeedRange?.[1] ?? 0.6
                    ) * (0.4 + asteroid.depth);
                    const driftRangeMin = settings.driftRange?.[0] ?? -18;
                    const driftRangeMax = settings.driftRange?.[1] ?? 18;
                    const driftScale = Math.max(0.18, 1 - asteroid.depth * 0.6);
                    asteroid.drift = randomBetween(driftRangeMin * 0.4, driftRangeMax * 0.4) * driftScale;
                    asteroid.vx = -asteroid.speed * (0.6 + asteroid.depth * 0.8);
                    asteroid.vy = asteroid.drift;
                    asteroid.x = spawnX + offset.x;
                    asteroid.y = clamp(centerY + offset.y, minY, maxY);
                    asteroid.health = Math.max(1, Math.round(asteroid.size / 32));
                    asteroid.hitFlash = 0;
                    asteroids.push(asteroid);
                    spawnedAny = true;
                }

                if (spawnedAny) {
                    asteroidSpawnTimer = 0;
                }

                return spawnedAny;
            }

            function updateAsteroids(delta) {
                const settings = config.asteroid ?? {};
                const spawnInterval = settings.spawnInterval ?? 0;
                if (state.gameState === 'running') {
                    asteroidSpawnTimer += delta;
                }

                let spawned = false;
                if (state.gameState === 'running' && settings.maxCount > 0 && spawnInterval > 0) {
                    while (asteroidSpawnTimer >= spawnInterval && asteroids.length < settings.maxCount) {
                        asteroidSpawnTimer -= spawnInterval;
                        asteroids.push(createAsteroid(false));
                        spawned = true;
                    }

                    if (asteroids.length >= settings.maxCount) {
                        asteroidSpawnTimer = Math.min(asteroidSpawnTimer, spawnInterval);
                    }
                }

                if (state.gameState !== 'running') {
                    state.meteorShowerTimer = 0;
                } else if (state.nextMeteorShower > 0) {
                    state.meteorShowerTimer += delta;
                    if (state.meteorShowerTimer >= state.nextMeteorShower) {
                        const created = spawnMeteorShower();
                        if (created) {
                            spawned = true;
                            scheduleNextMeteorShower();
                        } else {
                            state.meteorShowerTimer = state.nextMeteorShower * 0.6;
                        }
                    }
                }

                if (spawned) {
                    resolveAsteroidCollisions();
                }

                if (!asteroids.length) return;

                const deltaSeconds = delta / 1000;
                const parallaxFactor = 0.4 + state.gameSpeed / 900;
                const flowLerp = settings.flowLerp ?? 0.08;

                for (let i = asteroids.length - 1; i >= 0; i--) {
                    const asteroid = asteroids[i];
                    const targetVx = -asteroid.speed * parallaxFactor * (0.6 + asteroid.depth * 0.8);
                    asteroid.vx += (targetVx - asteroid.vx) * flowLerp;
                    const targetVy = asteroid.drift;
                    asteroid.vy += (targetVy - asteroid.vy) * flowLerp;

                    asteroid.x += asteroid.vx * deltaSeconds;
                    asteroid.y += asteroid.vy * deltaSeconds;
                    asteroid.rotation += asteroid.rotationSpeed * deltaSeconds;

                    if (asteroid.hitFlash > 0) {
                        asteroid.hitFlash = Math.max(0, asteroid.hitFlash - delta);
                    }

                    if (asteroid.shieldCooldown > 0) {
                        asteroid.shieldCooldown = Math.max(0, asteroid.shieldCooldown - delta);
                    }

                    if (asteroid.y < asteroid.radius) {
                        asteroid.y = asteroid.radius;
                        asteroid.vy = Math.abs(asteroid.vy || targetVy);
                    } else if (asteroid.y > viewport.height - asteroid.radius) {
                        asteroid.y = viewport.height - asteroid.radius;
                        asteroid.vy = -Math.abs(asteroid.vy || targetVy);
                    }

                    if (asteroid.x < -asteroid.size) {
                        asteroids.splice(i, 1);
                        asteroidSpawnTimer = 0;
                        continue;
                    }

                    if (state.gameState === 'running') {
                        const collisionRadius = asteroid.radius * (settings.collisionRadiusMultiplier ?? 1);
                        if (circleRectOverlap({ x: asteroid.x, y: asteroid.y, radius: collisionRadius }, player)) {
                            if (isShieldActive() && asteroid.shieldCooldown <= 0) {
                                repelAsteroidFromPlayer(asteroid);
                                continue;
                            }
                            triggerGameOver('An asteroid shattered your shields!');
                            return;
                        }

                        if (isPumpTailDamaging()) {
                            if (pumpTailIntersectsCircle({ x: asteroid.x, y: asteroid.y, radius: collisionRadius })) {
                                destroyAsteroid(i);
                                continue;
                            }
                        } else {
                            for (let j = trail.length - 1; j >= 0; j--) {
                                const t = trail[j];
                                if (Math.hypot(asteroid.x - t.x, asteroid.y - t.y) <= collisionRadius + 10) {
                                    if (isShieldActive()) {
                                        if (asteroid.shieldCooldown <= 0) {
                                            repelAsteroidFromPlayer(asteroid);
                                        }
                                        break;
                                    }
                                    triggerGameOver('Your tail clipped an asteroid!');
                                    return;
                                }
                            }
                        }
                    }
                }

                resolveAsteroidCollisions();

                const maxX = viewport.width + (settings.clusterRadius ?? 160);
                for (const asteroid of asteroids) {
                    asteroid.y = clamp(asteroid.y, asteroid.radius, viewport.height - asteroid.radius);
                    asteroid.x = Math.min(asteroid.x, maxX);
                }
            }

            function getAsteroidScoreValue(asteroid) {
                const base = config.score?.asteroid ?? 0;
                return base + Math.round((asteroid.size ?? 0) * 0.4);
            }

            function createAsteroidDebris(asteroid) {
                createParticles({
                    x: asteroid.x,
                    y: asteroid.y,
                    color: { r: 196, g: 206, b: 220 },
                    count: Math.round(12 + asteroid.radius * 0.6),
                    speedRange: [80, 360],
                    sizeRange: [0.7, 2.4],
                    lifeRange: [380, 760]
                });
            }

            function destroyAsteroid(index, options = {}) {
                const asteroid = asteroids[index];
                if (!asteroid) return;
                createAsteroidDebris(asteroid);
                audioManager.playExplosion('asteroid');
                if (options.createSpark !== false) {
                    createHitSpark({ x: asteroid.x, y: asteroid.y, color: { r: 186, g: 198, b: 214 } });
                }
                if (state.gameState === 'running' && options.awardScore !== false) {
                    awardScore(getAsteroidScoreValue(asteroid), {
                        x: asteroid.x,
                        y: asteroid.y,
                        type: 'asteroid',
                        color: '#fca5a5'
                    });
                    triggerScreenShake(Math.min(10, 4 + asteroid.radius * 0.04), 220);
                }
                asteroids.splice(index, 1);
                asteroidSpawnTimer = 0;
            }

            function damageAsteroid(asteroid, damage, index) {
                asteroid.health -= damage;
                asteroid.hitFlash = 220;
                if (asteroid.health <= 0) {
                    destroyAsteroid(index);
                } else {
                    createHitSpark({ x: asteroid.x, y: asteroid.y, color: { r: 172, g: 184, b: 204 } });
                }
            }

            function drawAsteroids(time) {
                if (!asteroids.length) return;
                ctx.save();
                for (const asteroid of asteroids) {
                    const bob = Math.sin(time * 0.0012 + asteroid.bobOffset) * asteroid.depth * 8;
                    const alpha = clamp(0.25 + asteroid.depth * 0.6, 0, 1);
                    const drawSize = asteroid.size;
                    ctx.save();
                    ctx.translate(asteroid.x, asteroid.y + bob);
                    ctx.rotate(asteroid.rotation);
                    ctx.globalAlpha = alpha;
                    const image = asteroid.image;
                    const flashStrength = clamp((asteroid.hitFlash ?? 0) / 220, 0, 1);
                    if (flashStrength > 0) {
                        ctx.filter = `brightness(${1 + flashStrength * 0.6}) saturate(${1 + flashStrength * 0.3})`;
                    }
                    if (image && image.complete && image.naturalWidth > 0) {
                        ctx.drawImage(image, -drawSize / 2, -drawSize / 2, drawSize, drawSize);
                    } else {
                        ctx.fillStyle = `rgba(94, 106, 134, ${alpha})`;
                        ctx.beginPath();
                        ctx.arc(0, 0, drawSize / 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    if (flashStrength > 0) {
                        ctx.filter = 'none';
                    }
                    ctx.restore();
                }
                ctx.restore();
            }

            function clamp(value, min, max) {
                return Math.max(min, Math.min(max, value));
            }

            function moveTowards(value, target, maxDelta) {
                if (value < target) {
                    return Math.min(target, value + maxDelta);
                }
                if (value > target) {
                    return Math.max(target, value - maxDelta);
                }
                return value;
            }

            function randomBetween(min, max) {
                return Math.random() * (max - min) + min;
            }

            function lerp(a, b, t) {
                return a + (b - a) * t;
            }

            function easeInOutQuad(t) {
                return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
            }

            function getDifficultyProgress() {
                if (!config.difficulty) return 1;
                return clamp(state.elapsedTime / config.difficulty.rampDuration, 0, 1);
            }

            function getSpeedRampMultiplier() {
                if (!config.difficulty?.speedRamp) return 1;
                const eased = easeInOutQuad(getDifficultyProgress());
                return lerp(config.difficulty.speedRamp.start, config.difficulty.speedRamp.end, eased);
            }

            function getSpawnIntensity(type) {
                const settings = config.difficulty?.spawnIntensity?.[type];
                if (!settings) return 1;
                const eased = easeInOutQuad(getDifficultyProgress());
                return lerp(settings.start, settings.end, eased);
            }

            function getHealthRampMultiplier() {
                const settings = config.difficulty?.healthRamp;
                if (!settings) return 1;
                const eased = easeInOutQuad(getDifficultyProgress());
                return lerp(settings.start, settings.end, eased);
            }

            function setPreflightPromptVisibility(visible) {
                if (!preflightPrompt) {
                    return;
                }
                preflightPrompt.hidden = !visible;
                preflightPrompt.setAttribute('aria-hidden', visible ? 'false' : 'true');
                if (mobilePreflightButton) {
                    mobilePreflightButton.disabled = !visible || !isTouchInterface;
                }
            }

            function showPreflightPrompt() {
                setPreflightPromptVisibility(true);
            }

            function hidePreflightPrompt() {
                setPreflightPromptVisibility(false);
            }

            function revealGameScreenAfterNameEntry() {
                if (preflightOverlayDismissed) {
                    return;
                }
                if (!overlay || overlay.classList.contains('hidden')) {
                    return;
                }
                if (overlayButton?.dataset.launchMode !== 'launch') {
                    return;
                }
                preflightOverlayDismissed = true;
                hideOverlay();
                showPreflightPrompt();
                focusGameCanvas();
            }

            function showOverlay(message, buttonText = getLaunchControlText(), options = {}) {
                hidePreflightPrompt();
                preflightOverlayDismissed = false;
                overlayMessage.textContent = message;
                const resolvedButtonText = buttonText || getLaunchControlText();
                if (overlayButton) {
                    const enableButton = options.enableButton ?? false;
                    overlayButton.textContent = resolvedButtonText;
                    overlayButton.disabled = !enableButton;
                    overlayButton.setAttribute('aria-disabled', enableButton ? 'false' : 'true');
                    if (enableButton && options.launchMode) {
                        overlayButton.dataset.launchMode = options.launchMode;
                        if (options.launchMode === 'launch' || options.launchMode === 'retry') {
                            refreshOverlayLaunchButton();
                        }
                    } else if (overlayButton.dataset.launchMode) {
                        overlayButton.textContent = resolvedButtonText;
                        delete overlayButton.dataset.launchMode;
                    }
                }
                if (overlaySecondaryButton) {
                    const secondaryConfig = options.secondaryButton;
                    if (secondaryConfig && secondaryConfig.text && secondaryConfig.launchMode) {
                        overlaySecondaryButton.hidden = false;
                        overlaySecondaryButton.disabled = Boolean(secondaryConfig.disabled);
                        overlaySecondaryButton.setAttribute(
                            'aria-disabled',
                            secondaryConfig.disabled ? 'true' : 'false'
                        );
                        overlaySecondaryButton.textContent = secondaryConfig.text;
                        overlaySecondaryButton.dataset.launchMode = secondaryConfig.launchMode;
                    } else {
                        overlaySecondaryButton.hidden = true;
                        overlaySecondaryButton.disabled = true;
                        overlaySecondaryButton.setAttribute('aria-disabled', 'true');
                        if (overlaySecondaryButton.dataset.launchMode) {
                            delete overlaySecondaryButton.dataset.launchMode;
                        }
                    }
                }
                if (overlayTitle) {
                    const titleText = options.title ?? overlayDefaultTitle;
                    overlayTitle.textContent = titleText;
                }
                const shouldShowComic = options.showComic ?? firstRunExperience;
                if (comicIntro) {
                    comicIntro.hidden = !shouldShowComic;
                }
                resetVirtualControls();
                if (overlay) {
                    overlay.classList.remove('hidden');
                    overlay.setAttribute('aria-hidden', 'false');
                }
                refreshHighScorePreview();
                window.requestAnimationFrame(() => {
                    try {
                        if (playerNameInput) {
                            playerNameInput.focus({ preventScroll: true });
                            playerNameInput.select?.();
                        } else if (overlayButton) {
                            overlayButton.focus({ preventScroll: true });
                        }
                    } catch {
                        // Ignore focus errors (e.g., if element is detached)
                    }
                });
            }

            function setOverlaySubmittingState(isSubmitting) {
                if (overlayButton) {
                    if (isSubmitting && !overlayButton.dataset.originalLabel) {
                        overlayButton.dataset.originalLabel = overlayButton.textContent ?? '';
                    }
                    overlayButton.disabled = isSubmitting;
                    overlayButton.setAttribute('aria-disabled', isSubmitting ? 'true' : 'false');
                    if (isSubmitting) {
                        overlayButton.textContent = 'Submitting';
                    } else if (overlayButton.dataset.originalLabel) {
                        if ((overlayButton.textContent ?? '') === 'Submitting') {
                            overlayButton.textContent = overlayButton.dataset.originalLabel;
                        }
                        delete overlayButton.dataset.originalLabel;
                    }
                }
                if (overlaySecondaryButton) {
                    const shouldDisable = isSubmitting || overlaySecondaryButton.hidden;
                    overlaySecondaryButton.disabled = shouldDisable;
                    overlaySecondaryButton.setAttribute('aria-disabled', shouldDisable ? 'true' : 'false');
                }
            }

            function hideOverlay() {
                if (overlay) {
                    overlay.classList.add('hidden');
                    overlay.setAttribute('aria-hidden', 'true');
                }
                if (overlayButton && typeof document !== 'undefined') {
                    const activeElement = document.activeElement;
                    if (activeElement === overlayButton) {
                        overlayButton.blur();
                    }
                }
                if (overlaySecondaryButton && !overlaySecondaryButton.hidden) {
                    overlaySecondaryButton.hidden = true;
                    overlaySecondaryButton.disabled = true;
                    overlaySecondaryButton.setAttribute('aria-disabled', 'true');
                    if (overlaySecondaryButton.dataset.launchMode) {
                        delete overlaySecondaryButton.dataset.launchMode;
                    }
                }
                if (playerNameInput && document.activeElement === playerNameInput) {
                    playerNameInput.blur();
                }
                refreshHighScorePreview();
            }

            function setJoystickThumbPosition(dx, dy) {
                if (!joystickThumb) return;
                const xValue = typeof dx === 'number' ? `${dx}px` : dx;
                const yValue = typeof dy === 'number' ? `${dy}px` : dy;
                joystickThumb.style.setProperty('--thumb-x', xValue);
                joystickThumb.style.setProperty('--thumb-y', yValue);
            }

            function resetJoystick() {
                const pointerId = joystickState.pointerId;
                if (pointerId !== null && joystickZone?.hasPointerCapture?.(pointerId)) {
                    joystickZone.releasePointerCapture(pointerId);
                }
                joystickState.pointerId = null;
                joystickState.touchId = null;
                virtualInput.moveX = 0;
                virtualInput.moveY = 0;
                virtualInput.smoothedX = 0;
                virtualInput.smoothedY = 0;
                setJoystickThumbPosition('0px', '0px');
            }

            function resetFiring() {
                const pointerId = firePointerId;
                if (pointerId !== null && fireButton?.hasPointerCapture?.(pointerId)) {
                    fireButton.releasePointerCapture(pointerId);
                }
                firePointerId = null;
                fireTouchId = null;
                virtualInput.firing = false;
                if (fireButton) {
                    fireButton.classList.remove('active');
                }
            }

            function resetVirtualControls() {
                resetJoystick();
                resetFiring();
            }

            function updateJoystickFromPointer(event) {
                if (!joystickZone) return;
                const rect = joystickZone.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                let dx = event.clientX - centerX;
                let dy = event.clientY - centerY;
                const maxDistance = rect.width * 0.5;
                const distance = Math.hypot(dx, dy);
                if (distance > maxDistance && distance > 0) {
                    const scale = maxDistance / distance;
                    dx *= scale;
                    dy *= scale;
                }

                setJoystickThumbPosition(dx, dy);

                const normalizedX = clamp(dx / maxDistance, -1, 1);
                const normalizedY = clamp(dy / maxDistance, -1, 1);
                const deadZone = 0.14;
                virtualInput.moveX = Math.abs(normalizedX) < deadZone ? 0 : normalizedX;
                virtualInput.moveY = Math.abs(normalizedY) < deadZone ? 0 : normalizedY;
            }

            function endJoystickControl() {
                resetJoystick();
            }

            function handleJoystickPointerEnd(event) {
                if (joystickState.pointerId !== event.pointerId) {
                    return;
                }
                if (joystickZone?.hasPointerCapture?.(event.pointerId)) {
                    joystickZone.releasePointerCapture(event.pointerId);
                }
                endJoystickControl();
            }

            function getTouchById(touchList, identifier) {
                if (!touchList || identifier == null) {
                    return null;
                }
                for (let i = 0; i < touchList.length; i++) {
                    const touch = touchList.item ? touchList.item(i) : touchList[i];
                    if (touch?.identifier === identifier) {
                        return touch;
                    }
                }
                return null;
            }

            function handleJoystickTouchEnd(identifier) {
                if (joystickState.touchId !== identifier) {
                    return;
                }
                endJoystickControl();
            }

            function engageFireControl(event) {
                const pointerId = event?.pointerId ?? null;
                firePointerId = pointerId;
                fireTouchId = null;
                virtualInput.firing = true;
                if (fireButton) {
                    fireButton.classList.add('active');
                    if (pointerId !== null) {
                        fireButton.setPointerCapture?.(pointerId);
                    }
                }
            }

            function engageFireTouchControl(identifier) {
                firePointerId = null;
                fireTouchId = identifier;
                virtualInput.firing = true;
                if (fireButton) {
                    fireButton.classList.add('active');
                }
            }

            function handleFirePointerEnd(event) {
                if (firePointerId !== event.pointerId) {
                    return;
                }
                if (fireButton?.hasPointerCapture?.(event.pointerId)) {
                    fireButton.releasePointerCapture(event.pointerId);
                }
                resetFiring();
            }

            function handleFireTouchEnd(identifier) {
                if (fireTouchId !== identifier) {
                    return;
                }
                resetFiring();
            }

            function focusGameCanvas() {
                if (!canvas) return;
                try {
                    canvas.focus({ preventScroll: true });
                } catch {
                    canvas.focus();
                }
            }

            function startGame() {
                hidePreflightPrompt();
                preflightOverlayDismissed = false;
                commitPlayerNameInput();
                completeFirstRunExperience();
                resetGame();
                pendingSubmission = null;
                state.gameState = 'running';
                lastTime = null;
                accumulatedDelta = 0;
                hideOverlay();
                audioManager.unlock();
                audioManager.playGameplayMusic();
                focusGameCanvas();
            }

            overlayButton.addEventListener('click', (event) => {
                event.preventDefault();
                if (overlayButton.disabled) {
                    if (playerNameInput) {
                        playerNameInput.focus({ preventScroll: true });
                        playerNameInput.select?.();
                    }
                    return;
                }
                const mode = overlayButton.dataset.launchMode || (state.gameState === 'ready' ? 'launch' : 'retry');
                handleOverlayAction(mode);
            });

            if (!supportsPointerEvents && overlayButton) {
                overlayButton.addEventListener('touchstart', (event) => {
                    event.preventDefault();
                    if (overlayButton.disabled) {
                        if (playerNameInput) {
                            playerNameInput.focus({ preventScroll: true });
                            playerNameInput.select?.();
                        }
                        return;
                    }
                    const mode = overlayButton.dataset.launchMode || (state.gameState === 'ready' ? 'launch' : 'retry');
                    handleOverlayAction(mode);
                }, { passive: false });
            }

            if (overlaySecondaryButton) {
                overlaySecondaryButton.addEventListener('click', (event) => {
                    event.preventDefault();
                    if (overlaySecondaryButton.disabled) {
                        return;
                    }
                    const mode = overlaySecondaryButton.dataset.launchMode || 'retry';
                    handleOverlayAction(mode);
                });
                if (!supportsPointerEvents) {
                    overlaySecondaryButton.addEventListener('touchstart', (event) => {
                        event.preventDefault();
                        if (overlaySecondaryButton.disabled) {
                            return;
                        }
                        const mode = overlaySecondaryButton.dataset.launchMode || 'retry';
                        handleOverlayAction(mode);
                    }, { passive: false });
                }
            }

            if (mobilePreflightButton) {
                mobilePreflightButton.addEventListener('click', () => {
                    if (state.gameState === 'ready') {
                        const mode = overlayButton?.dataset.launchMode || 'launch';
                        handleOverlayAction(mode);
                    } else if (state.gameState === 'gameover') {
                        const mode = overlayButton?.dataset.launchMode || (pendingSubmission ? 'submit' : 'retry');
                        handleOverlayAction(mode);
                    }
                });
            }

            if (canvas) {
                canvas.addEventListener('pointerdown', () => {
                    focusGameCanvas();
                });
                if (!supportsPointerEvents) {
                    canvas.addEventListener('touchstart', () => {
                        focusGameCanvas();
                    }, { passive: true });
                }
            }

            if (joystickZone) {
                if (supportsPointerEvents) {
                    joystickZone.addEventListener('pointerdown', (event) => {
                        if (typeof event.pointerType === 'string' && event.pointerType.toLowerCase() === 'touch') {
                            if (!isTouchInterface) {
                                isTouchInterface = true;
                                refreshInteractionHints();
                            }
                        }
                        joystickState.pointerId = event.pointerId;
                        joystickState.touchId = null;
                        focusGameCanvas();
                        event.preventDefault();
                        joystickZone.setPointerCapture?.(event.pointerId);
                        updateJoystickFromPointer(event);
                    });

                    joystickZone.addEventListener('pointermove', (event) => {
                        if (joystickState.pointerId !== event.pointerId) return;
                        updateJoystickFromPointer(event);
                    });

                    joystickZone.addEventListener('pointerup', (event) => {
                        handleJoystickPointerEnd(event);
                    });

                    joystickZone.addEventListener('pointercancel', (event) => {
                        handleJoystickPointerEnd(event);
                    });

                    joystickZone.addEventListener('lostpointercapture', (event) => {
                        if (joystickState.pointerId === event.pointerId) {
                            endJoystickControl();
                        }
                    });
                } else {
                    const handleTouchMove = (event) => {
                        const touch = getTouchById(event.changedTouches, joystickState.touchId);
                        if (!touch) {
                            return;
                        }
                        event.preventDefault();
                        updateJoystickFromPointer(touch);
                    };

                    const handleTouchEnd = (event) => {
                        const touch = getTouchById(event.changedTouches, joystickState.touchId);
                        if (!touch) {
                            return;
                        }
                        event.preventDefault();
                        handleJoystickTouchEnd(touch.identifier);
                    };

                    joystickZone.addEventListener('touchstart', (event) => {
                        if (joystickState.touchId !== null) {
                            return;
                        }
                        const touch = event.changedTouches.item(0);
                        if (!touch) {
                            return;
                        }
                        if (!isTouchInterface) {
                            isTouchInterface = true;
                            refreshInteractionHints();
                        }
                        joystickState.touchId = touch.identifier;
                        joystickState.pointerId = null;
                        focusGameCanvas();
                        event.preventDefault();
                        updateJoystickFromPointer(touch);
                    }, { passive: false });

                    joystickZone.addEventListener('touchmove', handleTouchMove, { passive: false });
                    joystickZone.addEventListener('touchend', handleTouchEnd, { passive: false });
                    joystickZone.addEventListener('touchcancel', handleTouchEnd, { passive: false });
                }
            }

            if (fireButton) {
                if (supportsPointerEvents) {
                    fireButton.addEventListener('pointerdown', (event) => {
                        if (typeof event.pointerType === 'string' && event.pointerType.toLowerCase() === 'touch') {
                            if (!isTouchInterface) {
                                isTouchInterface = true;
                                refreshInteractionHints();
                            }
                        }
                        focusGameCanvas();
                        event.preventDefault();
                        engageFireControl(event);
                    });

                    fireButton.addEventListener('pointerup', (event) => {
                        handleFirePointerEnd(event);
                    });

                    fireButton.addEventListener('pointercancel', (event) => {
                        handleFirePointerEnd(event);
                    });

                    fireButton.addEventListener('lostpointercapture', (event) => {
                        if (firePointerId === event.pointerId) {
                            resetFiring();
                        }
                    });
                } else {
                    const handleTouchEnd = (event) => {
                        const touch = getTouchById(event.changedTouches, fireTouchId);
                        if (!touch) {
                            return;
                        }
                        event.preventDefault();
                        handleFireTouchEnd(touch.identifier);
                    };

                    fireButton.addEventListener('touchstart', (event) => {
                        if (fireTouchId !== null) {
                            return;
                        }
                        const touch = event.changedTouches.item(0);
                        if (!touch) {
                            return;
                        }
                        if (!isTouchInterface) {
                            isTouchInterface = true;
                            refreshInteractionHints();
                        }
                        focusGameCanvas();
                        event.preventDefault();
                        engageFireTouchControl(touch.identifier);
                    }, { passive: false });

                    fireButton.addEventListener('touchend', handleTouchEnd, { passive: false });
                    fireButton.addEventListener('touchcancel', handleTouchEnd, { passive: false });
                }
            }

            window.addEventListener('keydown', (event) => {
                const normalizedKey = normalizeKey(event);
                if (!normalizedKey) {
                    return;
                }
                if (event.ctrlKey && event.shiftKey && normalizedKey === 'KeyD') {
                    event.preventDefault();
                    toggleDebugOverlay();
                    return;
                }
                const target = event.target;
                const isFormControl = isFormControlTarget(target);
                const isTextEntry = isTextEntryTarget(target);
                if (normalizedKey === 'Escape') {
                    if (isSettingsDrawerOpen()) {
                        event.preventDefault();
                        closeSettingsDrawer();
                        return;
                    }
                    if (!isTextEntry) {
                        event.preventDefault();
                        openSettingsDrawer();
                        return;
                    }
                }
                if (preventDefaultKeys.has(normalizedKey) && !isFormControl) {
                    event.preventDefault();
                }
                if (isTextEntry && normalizedKey !== 'Enter') {
                    return;
                }
                keys.add(normalizedKey);
                if (!event.repeat) {
                    const dashDirection = dashDirections[normalizedKey];
                    if (dashDirection) {
                        const now = performance.now();
                        const lastTap = dashTapTracker.get(normalizedKey);
                        if (lastTap && now - lastTap <= config.player.dash.doubleTapWindow) {
                            dashTapTracker.delete(normalizedKey);
                            triggerDash(dashDirection);
                        } else {
                            dashTapTracker.set(normalizedKey, now);
                        }
                    }
                }
                if (normalizedKey === 'Enter') {
                    if (state.gameState === 'ready') {
                        const mode = overlayButton?.dataset.launchMode || 'launch';
                        handleOverlayAction(mode);
                    } else if (state.gameState === 'gameover') {
                        const mode = overlayButton?.dataset.launchMode || (pendingSubmission ? 'submit' : 'retry');
                        handleOverlayAction(mode);
                    }
                }
            });

            window.addEventListener('keyup', (event) => {
                const normalizedKey = normalizeKey(event);
                if (!normalizedKey) {
                    return;
                }
                keys.delete(normalizedKey);
            });

            window.addEventListener('blur', () => {
                keys.clear();
                dashTapTracker.clear();
                resetVirtualControls();
            });

            function triggerDash(direction) {
                const dashConfig = config.player.dash;
                state.dashTimer = dashConfig.duration;
                if (direction.x !== 0) {
                    player.vx = direction.x * dashConfig.boostSpeed;
                }
                if (direction.y !== 0) {
                    player.vy = direction.y * dashConfig.boostSpeed;
                }
            }

            function isPowerUpActive(type) {
                return state.powerUpTimers[type] > 0;
            }

            function isShieldActive() {
                return isPowerUpActive(SHIELD_POWER);
            }

            function getPlayerCenter() {
                return {
                    x: player.x + player.width * 0.5,
                    y: player.y + player.height * 0.5
                };
            }

            function triggerShieldImpact(x, y, normalX = 0, normalY = 0) {
                const shieldConfig = config.defensePower ?? {};
                const color = shieldConfig.particleColor ?? { r: 148, g: 210, b: 255 };
                const offsetX = x + normalX * 12;
                const offsetY = y + normalY * 12;
                createParticles({
                    x: offsetX,
                    y: offsetY,
                    color,
                    count: 16,
                    speedRange: [160, 420],
                    sizeRange: [1.2, 3.2],
                    lifeRange: [320, 640]
                });
                state.shieldHitPulse = Math.min(1.2, (state.shieldHitPulse ?? 0) + 0.5);
            }

            function repelObstacleFromPlayer(obstacle) {
                const shieldConfig = config.defensePower ?? {};
                const { x: playerCenterX, y: playerCenterY } = getPlayerCenter();
                const obstacleCenterX = obstacle.x + obstacle.width * 0.5;
                const obstacleCenterY = obstacle.y + obstacle.height * 0.5;
                const dx = obstacleCenterX - playerCenterX;
                const dy = obstacleCenterY - playerCenterY;
                const distance = Math.max(Math.hypot(dx, dy), 1);
                const normalX = dx / distance;
                const normalY = dy / distance;
                const clearance = shieldConfig.clearance ?? 12;
                const playerHalfWidth = player.width * 0.5;
                const playerHalfHeight = player.height * 0.5;
                const obstacleHalfWidth = obstacle.width * 0.5;
                const obstacleHalfHeight = obstacle.height * 0.5;
                const targetCenterX = playerCenterX + normalX * (playerHalfWidth + obstacleHalfWidth + clearance);
                const targetCenterY = playerCenterY + normalY * (playerHalfHeight + obstacleHalfHeight + clearance);

                obstacle.x = targetCenterX - obstacleHalfWidth;
                obstacle.y = clamp(targetCenterY - obstacleHalfHeight, 16, viewport.height - obstacle.height - 16);

                const knockback = shieldConfig.obstacleKnockback ?? 520;
                obstacle.vx = normalX * knockback;
                obstacle.vy = normalY * (knockback * 0.7);
                obstacle.bounceTimer = shieldConfig.obstacleBounceDuration ?? 520;
                const speedMultiplier = shieldConfig.obstacleSpeedMultiplier ?? 1.1;
                obstacle.speed = -Math.max(Math.abs(obstacle.speed), state.gameSpeed) * speedMultiplier;
                obstacle.shieldCooldown = shieldConfig.hitCooldown ?? 400;
                obstacle.hitFlash = 160;

                triggerShieldImpact(targetCenterX, targetCenterY, normalX, normalY);
            }

            function repelAsteroidFromPlayer(asteroid) {
                const shieldConfig = config.defensePower ?? {};
                const { x: playerCenterX, y: playerCenterY } = getPlayerCenter();
                const dx = asteroid.x - playerCenterX;
                const dy = asteroid.y - playerCenterY;
                const distance = Math.max(Math.hypot(dx, dy), 1);
                const normalX = dx / distance;
                const normalY = dy / distance;
                const clearance = shieldConfig.clearance ?? 12;
                const playerRadius = Math.max(player.width, player.height) * 0.5;
                const targetDistance = playerRadius + asteroid.radius + clearance;
                asteroid.x = playerCenterX + normalX * targetDistance;
                asteroid.y = clamp(playerCenterY + normalY * targetDistance, asteroid.radius, viewport.height - asteroid.radius);

                const knockback = shieldConfig.asteroidKnockback ?? 420;
                asteroid.vx = normalX * knockback;
                asteroid.vy = normalY * (knockback * 0.75);
                asteroid.shieldCooldown = shieldConfig.hitCooldown ?? 400;
                asteroid.hitFlash = 180;

                triggerShieldImpact(asteroid.x, asteroid.y, normalX, normalY);
            }


            function attemptShoot(delta) {
                state.timeSinceLastShot += delta;
                const cooldown = config.projectileCooldown;
                if ((keys.has('Space') || virtualInput.firing) && state.timeSinceLastShot >= cooldown) {
                    spawnProjectiles();
                    state.timeSinceLastShot = 0;
                }
            }

            function spawnProjectiles() {
                const originX = player.x + player.width - 12;
                const originY = player.y + player.height * 0.5 - 6;
                const firedTypes = new Set();
                const createProjectile = (angle, type = 'standard') => {
                    const speed = config.projectileSpeed * (type === 'missile' ? 0.85 : 1);
                    const vx = Math.cos(angle) * speed;
                    const vy = Math.sin(angle) * speed;
                    firedTypes.add(type);
                    projectiles.push({
                        x: originX,
                        y: originY,
                        width: 24,
                        height: 12,
                        vx,
                        vy,
                        life: type === 'missile' ? 2800 : 2000,
                        type
                    });
                };

                if (isPowerUpActive('missiles')) {
                    createProjectile(0, 'missile');
                    createProjectile(0.1, 'missile');
                } else if (isPowerUpActive('bulletSpread')) {
                    const spread = 0.22;
                    createProjectile(-spread, 'spread');
                    createProjectile(0, 'spread');
                    createProjectile(spread, 'spread');
                } else {
                    createProjectile(0, 'standard');
                }

                for (const type of firedTypes) {
                    audioManager.playProjectile(type);
                }
            }

            function updateTailLength(delta) {
                const deltaSeconds = delta / 1000;
                if (state.tailLength < state.tailTarget) {
                    state.tailLength = Math.min(
                        state.tailTarget,
                        state.tailLength + config.tailSmoothing.growth * deltaSeconds
                    );
                } else if (state.tailLength > state.tailTarget) {
                    state.tailLength = Math.max(
                        state.tailTarget,
                        state.tailLength - config.tailSmoothing.shrink * deltaSeconds
                    );
                }
            }

            function updatePlayer(delta) {
                const deltaSeconds = delta / 1000;
                const keyboardX = (keys.has('ArrowRight') || keys.has('KeyD') ? 1 : 0) - (keys.has('ArrowLeft') || keys.has('KeyA') ? 1 : 0);
                const keyboardY = (keys.has('ArrowDown') || keys.has('KeyS') ? 1 : 0) - (keys.has('ArrowUp') || keys.has('KeyW') ? 1 : 0);
                let virtualX = virtualInput.moveX;
                let virtualY = virtualInput.moveY;
                if (isTouchInterface) {
                    const smoothingFactor = clamp(deltaSeconds * TOUCH_SMOOTHING_RATE, 0, 1);
                    virtualInput.smoothedX += (virtualInput.moveX - virtualInput.smoothedX) * smoothingFactor;
                    virtualInput.smoothedY += (virtualInput.moveY - virtualInput.smoothedY) * smoothingFactor;
                    virtualX = virtualInput.smoothedX;
                    virtualY = virtualInput.smoothedY;
                } else {
                    virtualInput.smoothedX = virtualInput.moveX;
                    virtualInput.smoothedY = virtualInput.moveY;
                }
                const inputX = clamp(keyboardX + virtualX, -1, 1);
                const inputY = clamp(keyboardY + virtualY, -1, 1);

                const accel = config.player.acceleration;
                const drag = config.player.drag;
                const dashConfig = config.player.dash;
                const isDashing = state.dashTimer > 0;
                const effectiveDrag = isDashing ? drag * dashConfig.dragMultiplier : drag;
                const maxSpeed = isDashing ? dashConfig.boostSpeed : config.player.maxSpeed;

                player.vx += (inputX * accel - player.vx * effectiveDrag) * deltaSeconds;
                player.vy += (inputY * accel - player.vy * effectiveDrag) * deltaSeconds;

                player.vx = clamp(player.vx, -maxSpeed, maxSpeed);
                player.vy = clamp(player.vy, -maxSpeed, maxSpeed);

                player.x += player.vx * deltaSeconds;
                player.y += player.vy * deltaSeconds;

                if (state.dashTimer > 0) {
                    state.dashTimer = Math.max(0, state.dashTimer - delta);
                }

                player.x = clamp(player.x, 0, viewport.width - player.width);
                const verticalBleed = viewport.height * config.player.verticalBleed;
                player.y = clamp(player.y, -verticalBleed, viewport.height - player.height + verticalBleed);

                attemptShoot(delta);

                updateTailLength(delta);
                if (isPowerUpActive(PUMP_POWER) || pumpTailState.fade > 0.001) {
                    if (isPowerUpActive(PUMP_POWER)) {
                        ensurePumpTailInitialized();
                    }
                } else {
                    updateTrail();
                }
            }

            function updateTrail() {
                const centerX = player.x + player.width * 0.45;
                const centerY = player.y + player.height * 0.55;
                const lastPoint = trail[trail.length - 1];
                if (!lastPoint || Math.hypot(centerX - lastPoint.x, centerY - lastPoint.y) > config.trailSpacing) {
                    trail.push({
                        x: centerX,
                        y: centerY
                    });
                    if (trail.length > state.tailLength) {
                        trail.shift();
                    }
                }
            }

            function ensurePumpTailInitialized() {
                if (pumpTailState.active) {
                    return;
                }
                pumpTailState.bars.length = 0;
                const barCount = Math.max(6, Math.round(state.tailLength));
                pumpTailState.active = true;
                pumpTailState.waveTime = 0;
                pumpTailState.fade = 0;
                pumpTailState.centerX = player.x + player.width * 0.3;
                pumpTailState.spread = Math.min(viewport.width * 0.85, Math.max(180, barCount * 26));
                const lengthFactor = state.tailLength / Math.max(1, config.baseTrailLength);
                pumpTailState.baseHeight = Math.min(
                    viewport.height * 0.52,
                    viewport.height * (0.16 + Math.min(0.32, lengthFactor * 0.26))
                );
                pumpTailState.amplitude = 0.38 + Math.min(1.1, lengthFactor * 0.5);
                pumpTailState.frequency = 1.6 + Math.min(1.6, lengthFactor * 0.35);
                pumpTailState.bars = Array.from({ length: barCount }, (_, index) => ({
                    offset: index - (barCount - 1) / 2,
                    phase: Math.random() * Math.PI * 2,
                    weight: 0.75 + Math.random() * 0.55
                }));
                pumpTailState.releasePending = false;
                trail.length = 0;
                updatePumpTailSegments();
            }

            function stopPumpTailEffect() {
                pumpTailState.active = false;
                pumpTailState.releasePending = true;
            }

            function updatePumpTailSegments() {
                const segments = pumpTailState.segments;
                segments.length = 0;

                if (!pumpTailState.bars.length || pumpTailState.fade <= 0) {
                    return;
                }

                const baseY = viewport.height - 28;
                const barCount = pumpTailState.bars.length;
                const spacing = barCount > 1 ? pumpTailState.spread / (barCount - 1) : 0;
                const startX = pumpTailState.centerX - (barCount > 1 ? pumpTailState.spread / 2 : 0);
                const baseWidth = barCount > 0 ? Math.min(48, Math.max(10, spacing * 0.52)) : 16;

                for (let i = 0; i < barCount; i++) {
                    const bar = pumpTailState.bars[i];
                    const normalizedIndex = barCount > 1 ? i / (barCount - 1) : 0;
                    const x = clamp(
                        startX + i * spacing,
                        baseWidth * 0.5,
                        viewport.width - baseWidth * 0.5
                    );
                    const wave = Math.sin(pumpTailState.waveTime + normalizedIndex * 1.6 + bar.phase);
                    const normalizedWave = wave * 0.5 + 0.5;
                    const height = pumpTailState.baseHeight * (
                        0.3 + pumpTailState.amplitude * bar.weight * normalizedWave
                    );
                    const scaledHeight = height * pumpTailState.fade;

                    if (scaledHeight <= 0) {
                        continue;
                    }

                    const topY = baseY - scaledHeight;
                    segments.push({
                        x: x - baseWidth / 2,
                        y: topY,
                        width: baseWidth,
                        height: scaledHeight,
                        centerX: x,
                        normalizedIndex,
                        baseY
                    });
                }
            }

            function updatePumpTail(delta) {
                const deltaSeconds = delta / 1000;
                const isActive = isPowerUpActive(PUMP_POWER);
                if (isActive) {
                    ensurePumpTailInitialized();
                } else if (pumpTailState.active) {
                    stopPumpTailEffect();
                }

                const fadeTarget = isActive ? 1 : 0;
                const fadeSpeed = isActive ? 2.6 : 3.5;
                pumpTailState.fade = moveTowards(pumpTailState.fade, fadeTarget, deltaSeconds * fadeSpeed);

                if (pumpTailState.fade <= 0.001 && !isActive) {
                    pumpTailState.fade = 0;
                    if (pumpTailState.releasePending) {
                        pumpTailState.bars.length = 0;
                        pumpTailState.releasePending = false;
                    }
                }

                if (pumpTailState.fade <= 0 && !isActive) {
                    pumpTailState.segments.length = 0;
                    return;
                }

                const waveAdvance = pumpTailState.frequency * Math.PI * 2 * (isActive ? 1 : 0.6);
                pumpTailState.waveTime += deltaSeconds * waveAdvance;
                if (pumpTailState.bars.length) {
                    const targetX = player.x + player.width * 0.3;
                    pumpTailState.centerX = moveTowards(
                        pumpTailState.centerX,
                        targetX,
                        deltaSeconds * 420
                    );
                    const lengthFactor = state.tailLength / Math.max(1, config.baseTrailLength);
                    const targetAmplitude = 0.38 + Math.min(1.1, lengthFactor * 0.5);
                    pumpTailState.amplitude = moveTowards(
                        pumpTailState.amplitude,
                        targetAmplitude,
                        deltaSeconds * 2.4
                    );
                    const targetBaseHeight = Math.min(
                        viewport.height * 0.52,
                        viewport.height * (0.16 + Math.min(0.32, lengthFactor * 0.26))
                    );
                    pumpTailState.baseHeight = moveTowards(
                        pumpTailState.baseHeight,
                        targetBaseHeight,
                        deltaSeconds * viewport.height * 0.6
                    );
                    const targetSpread = Math.min(
                        viewport.width * 0.85,
                        Math.max(180, Math.round(state.tailLength) * 26)
                    );
                    pumpTailState.spread = moveTowards(
                        pumpTailState.spread,
                        targetSpread,
                        deltaSeconds * 260
                    );
                }

                updatePumpTailSegments();
            }

            function drawPumpTail() {
                if (!pumpTailState.segments.length || pumpTailState.fade <= 0) {
                    return;
                }

                const time = performance.now();

                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                ctx.shadowBlur = 24 * pumpTailState.fade;

                for (const segment of pumpTailState.segments) {
                    const hue = (segment.normalizedIndex * 280 + time * 0.08) % 360;
                    const gradient = ctx.createLinearGradient(segment.centerX, segment.y, segment.centerX, segment.baseY);
                    gradient.addColorStop(0, `hsla(${hue}, 100%, 74%, ${0.72 * pumpTailState.fade})`);
                    gradient.addColorStop(1, `hsla(${(hue + 40) % 360}, 100%, 48%, ${0.18 * pumpTailState.fade})`);
                    ctx.fillStyle = gradient;
                    ctx.shadowColor = `hsla(${hue}, 100%, 70%, ${0.45 * pumpTailState.fade})`;
                    ctx.fillRect(segment.x, segment.y, segment.width, segment.height);

                    if (segment.height > 12) {
                        ctx.fillStyle = `hsla(${(hue + 60) % 360}, 100%, 85%, ${0.35 * pumpTailState.fade})`;
                        ctx.fillRect(segment.x, segment.y - 6, segment.width, 6);
                    }
                }

                ctx.restore();
            }

            function isPumpTailDamaging() {
                return pumpTailState.segments.length > 0 && pumpTailState.fade > 0;
            }

            function pumpTailIntersectsRect(rect) {
                if (!isPumpTailDamaging()) {
                    return false;
                }
                for (const segment of pumpTailState.segments) {
                    if (rectOverlap(segment, rect)) {
                        return true;
                    }
                }
                return false;
            }

            function pumpTailIntersectsCircle(circle) {
                if (!isPumpTailDamaging()) {
                    return false;
                }
                for (const segment of pumpTailState.segments) {
                    if (circleRectOverlap(circle, segment)) {
                        return true;
                    }
                }
                return false;
            }

            function findNearestObstacle(projectile) {
                let closest = null;
                let closestDistSq = Infinity;
                const projCenterX = projectile.x + projectile.width * 0.5;
                const projCenterY = projectile.y + projectile.height * 0.5;
                for (const obstacle of obstacles) {
                    const centerX = obstacle.x + obstacle.width * 0.5;
                    const centerY = obstacle.y + obstacle.height * 0.5;
                    const dx = centerX - projCenterX;
                    const dy = centerY - projCenterY;
                    const distSq = dx * dx + dy * dy;
                    if (distSq < closestDistSq) {
                        closest = { obstacle, dx, dy, distSq };
                        closestDistSq = distSq;
                    }
                }
                return closest?.obstacle ?? null;
            }

            function updateProjectiles(delta) {
                const deltaSeconds = delta / 1000;
                for (let i = projectiles.length - 1; i >= 0; i--) {
                    const projectile = projectiles[i];

                    if (projectile.type === 'missile') {
                        const target = findNearestObstacle(projectile);
                        if (target) {
                            const centerX = projectile.x + projectile.width * 0.5;
                            const centerY = projectile.y + projectile.height * 0.5;
                            const targetX = target.x + target.width * 0.5;
                            const targetY = target.y + target.height * 0.5;
                            const angle = Math.atan2(targetY - centerY, targetX - centerX);
                            const desiredSpeed = config.projectileSpeed * 1.05;
                            const desiredVx = Math.cos(angle) * desiredSpeed;
                            const desiredVy = Math.sin(angle) * desiredSpeed;
                            const turnStrength = Math.min(1, deltaSeconds * 3.5);
                            projectile.vx += (desiredVx - projectile.vx) * turnStrength;
                            projectile.vy += (desiredVy - projectile.vy) * turnStrength;
                        }
                    }

                    projectile.x += projectile.vx * deltaSeconds;
                    projectile.y += projectile.vy * deltaSeconds;
                    projectile.life -= delta;

                    if (
                        projectile.x > viewport.width + 80 ||
                        projectile.x + projectile.width < -80 ||
                        projectile.y < -120 ||
                        projectile.y > viewport.height + 120 ||
                        projectile.life <= 0
                    ) {
                        projectiles.splice(i, 1);
                    }
                }
            }

            function getVillainHealth(size, villainType) {
                const range = villainType.size.max - villainType.size.min;
                const normalized = range > 0 ? (size - villainType.size.min) / range : 0;
                const base = villainType.baseHealth + normalized * villainType.healthGrowth;
                const scaled = base * getHealthRampMultiplier();
                return Math.max(1, Math.round(scaled));
            }

            function createVillainBehaviorState(villainType, size) {
                const behavior = villainType.behavior ?? { type: 'none' };
                const state = { type: behavior.type };

                switch (behavior.type) {
                    case 'sine': {
                        const amplitude = behavior.amplitude ?? 40;
                        const available = Math.max(0, viewport.height - size - amplitude * 2);
                        const baseY = available > 0 ? Math.random() * available + amplitude : Math.random() * (viewport.height - size);
                        const phase = Math.random() * Math.PI * 2;
                        const initialY = clamp(baseY + Math.sin(phase) * amplitude, 0, viewport.height - size);
                        Object.assign(state, {
                            amplitude,
                            speed: behavior.speed ?? 3,
                            phase,
                            baseY,
                            initialY
                        });
                        break;
                    }
                    case 'hover': {
                        const amplitude = behavior.amplitude ?? 40;
                        const center = Math.random() * (viewport.height - size);
                        const lowerBound = 16;
                        const upperBound = Math.max(lowerBound, viewport.height - size - lowerBound);
                        let minY = clamp(center - amplitude, lowerBound, upperBound);
                        let maxY = clamp(center + amplitude, lowerBound, upperBound);
                        if (minY > maxY) {
                            const mid = (minY + maxY) / 2;
                            minY = mid;
                            maxY = mid;
                        }
                        Object.assign(state, {
                            minY,
                            maxY,
                            speed: behavior.verticalSpeed ?? 60,
                            direction: Math.random() < 0.5 ? -1 : 1,
                            initialY: clamp(center, minY, maxY)
                        });
                        break;
                    }
                    case 'drift': {
                        const initialY = Math.random() * (viewport.height - size);
                        const maxVertical = behavior.verticalSpeed ?? 120;
                        Object.assign(state, {
                            vy: randomBetween(-maxVertical, maxVertical),
                            verticalSpeed: maxVertical,
                            initialY
                        });
                        break;
                    }
                    case 'tracker': {
                        const initialY = Math.random() * (viewport.height - size);
                        Object.assign(state, {
                            vy: 0,
                            acceleration: behavior.acceleration ?? 120,
                            maxSpeed: behavior.maxSpeed ?? 180,
                            initialY
                        });
                        break;
                    }
                    default: {
                        state.initialY = Math.random() * (viewport.height - size);
                        break;
                    }
                }

                return state;
            }

            function isBossObstacle(obstacle) {
                return obstacle?.villainType?.key === bossVillainType.key;
            }

            function completeBossBattle() {
                state.bossBattle.active = false;
                state.bossBattle.bossSpawned = false;
                state.bossBattle.defeated = true;
                state.bossBattle.powerUpSpawned = false;
                state.bossBattle.alertTimer = 0;
                spawnTimers.obstacle = 0;
                spawnTimers.collectible = 0;
                spawnTimers.powerUp = 0;
            }

            function spawnBoss() {
                const width = bossVillainType.width;
                const height = bossVillainType.height ?? width;
                const spawnY = clamp(
                    viewport.height * 0.5 - height * 0.5,
                    32,
                    viewport.height - height - 32
                );
                const hoverAmplitude = bossVillainType.behavior?.amplitude ?? 0;
                const hoverSpeed = bossVillainType.behavior?.verticalSpeed ?? 60;
                const lowerBound = 16;
                const upperBound = Math.max(lowerBound, viewport.height - height - lowerBound);
                let minY = clamp(spawnY - hoverAmplitude, lowerBound, upperBound);
                let maxY = clamp(spawnY + hoverAmplitude, lowerBound, upperBound);
                if (minY > maxY) {
                    const mid = (minY + maxY) / 2;
                    minY = mid;
                    maxY = mid;
                }
                const behaviorState = {
                    type: 'hover',
                    speed: hoverSpeed,
                    minY,
                    maxY,
                    direction: 1
                };

                obstacles.push({
                    x: viewport.width + width,
                    y: clamp(spawnY, minY, maxY),
                    width,
                    height,
                    speed: Math.max(60, state.gameSpeed * 0.22),
                    rotation: 0,
                    rotationSpeed: 0,
                    health: bossVillainType.health,
                    maxHealth: bossVillainType.health,
                    hitFlash: 0,
                    vx: 0,
                    vy: 0,
                    bounceTimer: 0,
                    shieldCooldown: 0,
                    villainType: bossVillainType,
                    behaviorState,
                    image: bossVillainType.image
                });
                state.bossBattle.bossSpawned = true;
                state.lastVillainKey = bossVillainType.key;
            }

            function startBossBattle() {
                if (state.bossBattle.active || state.bossBattle.defeated) {
                    return;
                }
                state.bossBattle.triggered = true;
                state.bossBattle.active = true;
                state.bossBattle.bossSpawned = false;
                state.bossBattle.powerUpSpawned = false;
                state.bossBattle.alertTimer = BOSS_ALERT_DURATION;
                obstacles.length = 0;
                collectibles.length = 0;
                powerUps.length = 0;
                spawnTimers.obstacle = 0;
                spawnTimers.collectible = 0;
                spawnTimers.powerUp = 0;
                spawnBoss();
                spawnBossSupportPowerUp();
            }

            function spawnObstacle() {
                if (state.bossBattle.active) {
                    if (!state.bossBattle.bossSpawned) {
                        spawnBoss();
                    }
                    return;
                }
                const villainType = selectVillainType();
                const size = randomBetween(villainType.size.min, villainType.size.max);
                const health = getVillainHealth(size, villainType);
                const behaviorState = createVillainBehaviorState(villainType, size);
                const spawnY = behaviorState.initialY ?? Math.random() * (viewport.height - size);
                delete behaviorState.initialY;
                const rotationSpeed = randomBetween(villainType.rotation.min, villainType.rotation.max);
                obstacles.push({
                    x: viewport.width + size,
                    y: spawnY,
                    width: size,
                    height: size,
                    speed: state.gameSpeed + randomBetween(villainType.speedOffset.min, villainType.speedOffset.max),
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed,
                    health,
                    maxHealth: health,
                    hitFlash: 0,
                    vx: 0,
                    vy: 0,
                    bounceTimer: 0,
                    shieldCooldown: 0,
                    villainType,
                    behaviorState,
                    image: villainImages[villainType.key]
                });
                state.lastVillainKey = villainType.key;
                state.recentVillains.push(villainType.key);
                if (state.recentVillains.length > 6) {
                    state.recentVillains.shift();
                }
                if (behaviorState.baseY === undefined) {
                    behaviorState.baseY = spawnY;
                }
            }

            function spawnCollectible() {
                const tier = selectCollectibleTier();
                const baseSize = config.collectible.size ?? 32;
                const size = baseSize * (tier.sizeMultiplier ?? 1);
                const verticalPadding = config.collectible.verticalPadding ?? 48;
                const spawnRange = Math.max(viewport.height - size - verticalPadding * 2, 0);
                const spawnY = verticalPadding + Math.random() * spawnRange;
                collectibles.push({
                    x: viewport.width + size,
                    y: spawnY,
                    width: size,
                    height: size,
                    speed: state.gameSpeed + (Math.random() * (config.collectible.maxSpeed - config.collectible.minSpeed) + config.collectible.minSpeed),
                    wobbleTime: Math.random() * Math.PI * 2,
                    type: tier.key,
                    points: tier.points,
                    sprite: collectibleImages[tier.key],
                    glow: tier.glow,
                    particleColor: tier.particleColor,
                    label: tier.label
                });
            }

            function selectCollectibleTier() {
                if (collectibleTiers.length === 0) {
                    return {
                        key: 'point',
                        label: 'POINT',
                        src: 'assets/point.png',
                        points: baseCollectScore,
                        weight: 1,
                        sizeMultiplier: 1,
                        glow: null,
                        particleColor: { r: 255, g: 215, b: 0 }
                    };
                }

                const roll = Math.random() * (totalCollectibleWeight || 1);
                let cumulative = 0;
                for (const tier of collectibleTiers) {
                    cumulative += tier.weight;
                    if (roll <= cumulative) {
                        return tier;
                    }
                }
                return collectibleTiers[collectibleTiers.length - 1];
            }

            function spawnPowerUp() {
                const type = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
                const size = config.powerUp.size;
                powerUps.push({
                    x: viewport.width + size,
                    y: Math.random() * (viewport.height - size * 2) + size,
                    width: size,
                    height: size,
                    speed: state.gameSpeed + (Math.random() * (config.powerUp.maxSpeed - config.powerUp.minSpeed) + config.powerUp.minSpeed),
                    wobbleTime: Math.random() * Math.PI * 2,
                    type
                });
                return powerUps[powerUps.length - 1];
            }

            function spawnBossSupportPowerUp() {
                if (state.bossBattle.powerUpSpawned) {
                    return;
                }
                const powerUp = spawnPowerUp();
                if (powerUp) {
                    powerUp.x = viewport.width - powerUp.width * 0.5;
                }
                state.bossBattle.powerUpSpawned = true;
            }

            function applyVillainBehavior(obstacle, deltaSeconds) {
                const behaviorState = obstacle.behaviorState;
                const villainBehavior = obstacle.villainType?.behavior;
                if (!behaviorState || !villainBehavior) {
                    return;
                }

                switch (villainBehavior.type) {
                    case 'sine': {
                        behaviorState.phase += deltaSeconds * (behaviorState.speed ?? villainBehavior.speed ?? 3);
                        const amplitude = behaviorState.amplitude ?? villainBehavior.amplitude ?? 40;
                        const targetY = behaviorState.baseY + Math.sin(behaviorState.phase) * amplitude;
                        obstacle.y = clamp(targetY, 0, viewport.height - obstacle.height);
                        break;
                    }
                    case 'hover': {
                        const speed = behaviorState.speed ?? villainBehavior.verticalSpeed ?? 60;
                        const minY =
                            behaviorState.minY ?? clamp(obstacle.y - (villainBehavior.amplitude ?? 0), 16, viewport.height - obstacle.height - 16);
                        const maxY =
                            behaviorState.maxY ?? clamp(obstacle.y + (villainBehavior.amplitude ?? 0), 16, viewport.height - obstacle.height - 16);
                        if (behaviorState.minY === undefined) {
                            behaviorState.minY = minY;
                        }
                        if (behaviorState.maxY === undefined) {
                            behaviorState.maxY = maxY;
                        }
                        const direction = behaviorState.direction ?? 1;
                        obstacle.y += speed * direction * deltaSeconds;
                        if (obstacle.y <= behaviorState.minY) {
                            obstacle.y = behaviorState.minY;
                            behaviorState.direction = 1;
                        } else if (obstacle.y >= behaviorState.maxY) {
                            obstacle.y = behaviorState.maxY;
                            behaviorState.direction = -1;
                        } else {
                            behaviorState.direction = direction;
                        }
                        break;
                    }
                    case 'drift': {
                        obstacle.y += behaviorState.vy * deltaSeconds;
                        if (obstacle.y < 24) {
                            obstacle.y = 24;
                            behaviorState.vy = Math.abs(behaviorState.vy);
                        } else if (obstacle.y + obstacle.height > viewport.height - 24) {
                            obstacle.y = viewport.height - 24 - obstacle.height;
                            behaviorState.vy = -Math.abs(behaviorState.vy);
                        }
                        break;
                    }
                    case 'tracker': {
                        const targetY = player.y + player.height * 0.5 - obstacle.height * 0.5;
                        const direction = targetY - obstacle.y;
                        const accel = Math.sign(direction) * (behaviorState.acceleration ?? villainBehavior.acceleration ?? 120);
                        behaviorState.vy += accel * deltaSeconds;
                        const maxSpeed = behaviorState.maxSpeed ?? villainBehavior.maxSpeed ?? 180;
                        behaviorState.vy = clamp(behaviorState.vy, -maxSpeed, maxSpeed);
                        obstacle.y += behaviorState.vy * deltaSeconds;
                        obstacle.y = clamp(obstacle.y, 16, viewport.height - obstacle.height - 16);
                        break;
                    }
                    default:
                        break;
                }
            }

            function updateObstacles(delta) {
                const deltaSeconds = delta / 1000;
                for (let i = obstacles.length - 1; i >= 0; i--) {
                    const obstacle = obstacles[i];
                    const isBoss = isBossObstacle(obstacle);
                    obstacle.x -= obstacle.speed * deltaSeconds;
                    obstacle.rotation += obstacle.rotationSpeed * deltaSeconds;
                    if (obstacle.hitFlash > 0) {
                        obstacle.hitFlash = Math.max(0, obstacle.hitFlash - delta);
                    }

                    if (obstacle.shieldCooldown > 0) {
                        obstacle.shieldCooldown = Math.max(0, obstacle.shieldCooldown - delta);
                    }

                    if (obstacle.bounceTimer > 0) {
                        obstacle.bounceTimer = Math.max(0, obstacle.bounceTimer - delta);
                        const damping = Math.exp(-(config.defensePower?.bounceDrag ?? 3.4) * deltaSeconds);
                        obstacle.x += obstacle.vx * deltaSeconds;
                        obstacle.y += obstacle.vy * deltaSeconds;
                        obstacle.vx *= damping;
                        obstacle.vy *= damping;
                        if (obstacle.bounceTimer === 0) {
                            obstacle.speed = Math.abs(obstacle.speed);
                            obstacle.vx = 0;
                            obstacle.vy = 0;
                        }
                    }

                    applyVillainBehavior(obstacle, deltaSeconds);

                    if (obstacle.x + obstacle.width < 0) {
                        obstacles.splice(i, 1);
                        if (isBoss) {
                            return triggerGameOver('The boss overwhelmed your defenses!');
                        }
                        handleVillainEscape(obstacle);
                        continue;
                    }

                    obstacle.y = clamp(obstacle.y, 16, viewport.height - obstacle.height - 16);

                    if (isPumpTailDamaging() && pumpTailIntersectsRect(obstacle)) {
                        obstacles.splice(i, 1);
                        awardDestroy(obstacle);
                        createVillainExplosion(obstacle);
                        continue;
                    }

                    if (rectOverlap(player, obstacle)) {
                        if (isBoss) {
                            return triggerGameOver('The boss crushed your ship!');
                        }
                        if (isShieldActive() && obstacle.shieldCooldown <= 0) {
                            repelObstacleFromPlayer(obstacle);
                            continue;
                        }
                        return triggerGameOver('Your rainbow ship took a direct hit!');
                    }

                    if (!isPumpTailDamaging()) {
                        for (let j = trail.length - 1; j >= 0; j--) {
                            const t = trail[j];
                            if (circleRectOverlap({ x: t.x, y: t.y, radius: 10 }, obstacle)) {
                                if (isShieldActive() && !isBoss) {
                                    if (obstacle.shieldCooldown <= 0) {
                                        repelObstacleFromPlayer(obstacle);
                                    }
                                    break;
                                }
                                return triggerGameOver(
                                    isBoss
                                        ? 'The boss shattered your tail formation!'
                                        : 'Your tail tangled with space junk!'
                                );
                            }
                        }
                    }
                }
            }

            function updateCollectibles(delta) {
                const deltaSeconds = delta / 1000;
                for (let i = collectibles.length - 1; i >= 0; i--) {
                    const collectible = collectibles[i];
                    collectible.x -= collectible.speed * deltaSeconds;
                    collectible.wobbleTime += deltaSeconds * 4;
                    collectible.y += Math.sin(collectible.wobbleTime) * 18 * deltaSeconds;
                    const verticalPadding = config.collectible.verticalPadding ?? 48;
                    collectible.y = clamp(collectible.y, verticalPadding, viewport.height - collectible.height - verticalPadding);

                    if (collectible.x + collectible.width < 0) {
                        collectibles.splice(i, 1);
                        resetStreak();
                        continue;
                    }

                    if (rectOverlap(player, collectible)) {
                        collectibles.splice(i, 1);
                        awardCollect(collectible);
                        createParticles({
                            x: collectible.x + collectible.width * 0.5,
                            y: collectible.y + collectible.height * 0.5,
                            color: collectible.particleColor ?? { r: 255, g: 215, b: 0 }
                        });
                    }
                }
            }

            function triggerPowerBombPulse() {
                const centerX = player.x + player.width * 0.5;
                const centerY = player.y + player.height * 0.5;
                const burst = {
                    x: centerX,
                    y: centerY,
                    radius: 0,
                    maxRadius: 360,
                    speed: 760,
                    life: 650,
                    hitSet: new WeakSet()
                };
                areaBursts.push(burst);
                audioManager.playExplosion('powerbomb');
                createParticles({
                    x: centerX,
                    y: centerY,
                    color: { r: 255, g: 196, b: 128 }
                });
            }

            function activatePowerUp(type) {
                const duration = config.powerUp.duration[type];
                if (duration) {
                    state.powerUpTimers[type] = duration;
                }
                if (type === 'powerBomb') {
                    triggerPowerBombPulse();
                    state.powerBombPulseTimer = 900;
                } else if (type === SHIELD_POWER) {
                    state.shieldHitPulse = Math.max(state.shieldHitPulse, 0.6);
                    const { x, y } = getPlayerCenter();
                    triggerShieldImpact(x, y);
                } else if (type === HYPER_BEAM_POWER) {
                    hyperBeamState.sparkTimer = 0;
                    hyperBeamState.intensity = Math.max(hyperBeamState.intensity, 0.25);
                    audioManager.playHyperBeam();
                } else if (type === PUMP_POWER) {
                    ensurePumpTailInitialized();
                }
            }

            function updatePowerUps(delta) {
                const deltaSeconds = delta / 1000;
                for (let i = powerUps.length - 1; i >= 0; i--) {
                    const powerUp = powerUps[i];
                    powerUp.x -= powerUp.speed * deltaSeconds;
                    powerUp.wobbleTime += deltaSeconds * config.powerUp.wobbleSpeed;
                    powerUp.y += Math.sin(powerUp.wobbleTime) * config.powerUp.wobbleAmplitude * deltaSeconds;
                    powerUp.y = clamp(powerUp.y, 32, viewport.height - 32 - powerUp.height);

                    if (powerUp.x + powerUp.width < 0) {
                        powerUps.splice(i, 1);
                        continue;
                    }

                    if (rectOverlap(player, powerUp)) {
                        powerUps.splice(i, 1);
                        activatePowerUp(powerUp.type);
                        if (challengeManager) {
                            challengeManager.recordEvent('powerUp', { type: powerUp.type });
                        }
                        const color = powerUpColors[powerUp.type] ?? { r: 200, g: 200, b: 255 };
                        createParticles({
                            x: powerUp.x + powerUp.width * 0.5,
                            y: powerUp.y + powerUp.height * 0.5,
                            color
                        });
                    }
                }
            }

            function updatePowerUpTimers(delta) {
                for (const type of powerUpTypes) {
                    if (state.powerUpTimers[type] > 0) {
                        state.powerUpTimers[type] = Math.max(0, state.powerUpTimers[type] - delta);
                        if (type === 'powerBomb' && state.powerUpTimers[type] === 0) {
                            state.powerBombPulseTimer = 0;
                        }
                        if (type === SHIELD_POWER && state.powerUpTimers[type] === 0) {
                            state.shieldHitPulse = 0;
                        }
                        if (type === HYPER_BEAM_POWER && state.powerUpTimers[type] === 0) {
                            hyperBeamState.sparkTimer = 0;
                            audioManager.stopHyperBeam();
                        }
                        if (type === PUMP_POWER && state.powerUpTimers[type] === 0) {
                            stopPumpTailEffect();
                        }
                    }
                }
            }

            function updatePowerBomb(delta) {
                if (!isPowerUpActive('powerBomb')) return;
                state.powerBombPulseTimer -= delta;
                if (state.powerBombPulseTimer <= 0) {
                    triggerPowerBombPulse();
                    state.powerBombPulseTimer = 900;
                }
            }

            function computeHyperBeamBounds(hyperConfig) {
                const startX = player.x + player.width * 0.55;
                const width = Math.max(0, viewport.width - startX + (hyperConfig.extraLength ?? 40));
                if (width <= 0) {
                    return null;
                }
                const { y: centerY } = getPlayerCenter();
                const height = Math.min(hyperConfig.beamHeight ?? 180, viewport.height);
                let top = centerY - height / 2;
                if (top < 0) {
                    top = 0;
                } else if (top + height > viewport.height) {
                    top = Math.max(0, viewport.height - height);
                }
                return { x: startX, y: top, width, height };
            }

            function applyHyperBeamDamage(bounds, delta, hyperConfig) {
                if (!bounds) return;
                const intensity = hyperBeamState.intensity;
                if (intensity <= 0) return;

                const deltaSeconds = delta / 1000;
                const sparkColor = powerUpColors[HYPER_BEAM_POWER] ?? { r: 147, g: 197, b: 253 };
                const hitSparkRate = hyperConfig.hitSparkRate ?? 7;
                const damage = (hyperConfig.damagePerSecond ?? 20) * deltaSeconds * intensity;
                const asteroidDamage = (hyperConfig.asteroidDamagePerSecond ?? damage) * deltaSeconds * intensity;

                for (let i = obstacles.length - 1; i >= 0; i--) {
                    const obstacle = obstacles[i];
                    if (!rectOverlap(bounds, obstacle)) continue;

                    obstacle.health -= damage;
                    obstacle.hitFlash = Math.max(obstacle.hitFlash ?? 0, 180 * intensity);

                    if (obstacle.health <= 0) {
                        obstacles.splice(i, 1);
                        awardDestroy(obstacle);
                        createVillainExplosion(obstacle);
                        continue;
                    }

                    if (Math.random() < deltaSeconds * hitSparkRate * intensity) {
                        createHitSpark({
                            x: obstacle.x + obstacle.width * randomBetween(0.4, 0.9),
                            y: obstacle.y + obstacle.height * randomBetween(0.2, 0.8),
                            color: sparkColor
                        });
                    }
                }

                for (let i = asteroids.length - 1; i >= 0; i--) {
                    const asteroid = asteroids[i];
                    const radius = asteroid.radius * (config.asteroid?.collisionRadiusMultiplier ?? 1);
                    if (!circleRectOverlap({ x: asteroid.x, y: asteroid.y, radius }, bounds)) continue;
                    damageAsteroid(asteroid, asteroidDamage, i);
                }
            }

            function spawnHyperBeamParticles(bounds, delta, hyperConfig) {
                if (!bounds) return;
                const intensity = hyperBeamState.intensity;
                if (intensity <= 0) return;

                hyperBeamState.sparkTimer -= delta;
                if (hyperBeamState.sparkTimer > 0) {
                    return;
                }

                const baseInterval = hyperConfig.sparkInterval ?? 140;
                const intervalScale = reducedEffectsMode ? 1.4 : 1;
                const scaledInterval = (baseInterval / Math.max(0.45, intensity)) * intervalScale;
                hyperBeamState.sparkTimer = randomBetween(scaledInterval * 0.6, scaledInterval * 1.4);

                const color = powerUpColors[HYPER_BEAM_POWER] ?? { r: 147, g: 197, b: 253 };
                const particleScale = reducedEffectsMode ? 0.6 : 1;
                const count = Math.max(1, Math.round((1 + intensity * 2) * particleScale));
                const velocityScale = reducedEffectsMode ? 0.7 : 1;
                const lifeScale = reducedEffectsMode ? 0.75 : 1;
                const sizeScale = reducedEffectsMode ? 0.85 : 1;
                for (let i = 0; i < count; i++) {
                    const spawnX = randomBetween(bounds.x + bounds.width * 0.2, bounds.x + bounds.width * 0.9);
                    const spawnY = randomBetween(bounds.y, bounds.y + bounds.height);
                    particles.push({
                        x: spawnX,
                        y: spawnY,
                        vx: randomBetween(120, 240) * velocityScale,
                        vy: randomBetween(-140, 140) * velocityScale,
                        life: randomBetween(240, 420) * lifeScale,
                        color,
                        size: randomBetween(1.2, 2.6) * sizeScale
                    });
                }
            }

            function updateHyperBeam(delta) {
                const hyperConfig = config.hyperBeam ?? {};
                const isActive = isPowerUpActive(HYPER_BEAM_POWER);
                const rampUp = Math.max(1, hyperConfig.rampUp ?? 240);
                const fadeOut = Math.max(1, hyperConfig.fadeOut ?? 240);

                if (isActive) {
                    hyperBeamState.intensity = Math.min(1, hyperBeamState.intensity + (delta / rampUp));
                } else {
                    hyperBeamState.intensity = Math.max(0, hyperBeamState.intensity - (delta / fadeOut));
                }

                if (hyperBeamState.intensity <= 0) {
                    hyperBeamState.sparkTimer = 0;
                    hyperBeamState.bounds = null;
                    hyperBeamState.wave = 0;
                    audioManager.stopHyperBeam();
                    return;
                }

                const bounds = computeHyperBeamBounds(hyperConfig);
                hyperBeamState.bounds = bounds;
                hyperBeamState.wave = (hyperBeamState.wave + delta * (hyperConfig.waveSpeed ?? 0.006)) % (Math.PI * 2);

                if (!bounds) {
                    return;
                }

                if (state.gameState === 'running' && isActive) {
                    applyHyperBeamDamage(bounds, delta, hyperConfig);
                    spawnHyperBeamParticles(bounds, delta, hyperConfig);
                }
            }

            function updateShieldEffects(delta) {
                if (state.shieldHitPulse > 0) {
                    state.shieldHitPulse = Math.max(0, state.shieldHitPulse - delta / 900);
                }
            }

            function updateAreaBursts(delta) {
                const deltaSeconds = delta / 1000;
                for (let i = areaBursts.length - 1; i >= 0; i--) {
                    const burst = areaBursts[i];
                    burst.radius = Math.min(burst.maxRadius, burst.radius + burst.speed * deltaSeconds);
                    burst.life -= delta;

                    for (let j = obstacles.length - 1; j >= 0; j--) {
                        const obstacle = obstacles[j];
                        if (burst.hitSet.has(obstacle)) continue;
                        const centerX = obstacle.x + obstacle.width * 0.5;
                        const centerY = obstacle.y + obstacle.height * 0.5;
                        const distance = Math.hypot(centerX - burst.x, centerY - burst.y);
                        const hitRadius = burst.radius + obstacle.width * 0.5;
                        if (distance <= hitRadius) {
                            burst.hitSet.add(obstacle);
                            obstacles.splice(j, 1);
                            awardDestroy(obstacle);
                            createVillainExplosion(obstacle);
                        }
                    }

                    for (let j = asteroids.length - 1; j >= 0; j--) {
                        const asteroid = asteroids[j];
                        if (burst.hitSet.has(asteroid)) continue;
                        const distance = Math.hypot(asteroid.x - burst.x, asteroid.y - burst.y);
                        const hitRadius = burst.radius + asteroid.radius;
                        if (distance <= hitRadius) {
                            burst.hitSet.add(asteroid);
                            destroyAsteroid(j);
                        }
                    }

                    if (burst.life <= 0) {
                        areaBursts.splice(i, 1);
                    }
                }
            }

            function updateVillainExplosions(delta) {
                const deltaSeconds = delta / 1000;
                for (let i = villainExplosions.length - 1; i >= 0; i--) {
                    const explosion = villainExplosions[i];

                    if (typeof explosion.expansionSpeed === 'number' && typeof explosion.maxRadius === 'number') {
                        explosion.radius = Math.min(
                            explosion.maxRadius,
                            explosion.radius + explosion.expansionSpeed * deltaSeconds
                        );
                    }

                    if (typeof explosion.ringRadius === 'number' && typeof explosion.ringGrowth === 'number') {
                        const maxRing = explosion.maxRingRadius ?? Number.POSITIVE_INFINITY;
                        explosion.ringRadius = Math.min(maxRing, explosion.ringRadius + explosion.ringGrowth * deltaSeconds);
                    }

                    switch (explosion.type) {
                        case 'nova': {
                            explosion.pulse = (explosion.pulse ?? 0) + deltaSeconds * 5;
                            if (explosion.spokes) {
                                for (const spoke of explosion.spokes) {
                                    spoke.length = Math.min(spoke.maxLength, spoke.length + spoke.growth * deltaSeconds);
                                }
                            }
                            break;
                        }
                        case 'ionBurst': {
                            if (explosion.orbits) {
                                for (const orbit of explosion.orbits) {
                                    if (orbit.radius < orbit.targetRadius) {
                                        orbit.radius = Math.min(
                                            orbit.targetRadius,
                                            orbit.radius + orbit.growth * deltaSeconds
                                        );
                                    }
                                    orbit.angle += orbit.rotationSpeed * deltaSeconds;
                                    if (orbit.targetEccentricity !== undefined) {
                                        orbit.eccentricity +=
                                            (orbit.targetEccentricity - orbit.eccentricity) * deltaSeconds * 0.8;
                                    }
                                }
                            }
                            if (explosion.sparks) {
                                for (const spark of explosion.sparks) {
                                    spark.distance += spark.speed * deltaSeconds;
                                    spark.angle += spark.drift * deltaSeconds;
                                }
                            }
                            if (explosion.swirl) {
                                explosion.swirl.angle += explosion.swirl.speed * deltaSeconds;
                            }
                            break;
                        }
                        case 'gravityRift': {
                            if (explosion.core) {
                                explosion.core.radius = Math.max(
                                    explosion.core.minRadius,
                                    explosion.core.radius - explosion.core.collapseSpeed * deltaSeconds
                                );
                            }
                            if (explosion.shockwaves) {
                                for (const shock of explosion.shockwaves) {
                                    if (shock.delay > 0) {
                                        shock.delay = Math.max(0, shock.delay - delta);
                                        continue;
                                    }
                                    shock.radius = Math.min(shock.maxRadius, shock.radius + shock.speed * deltaSeconds);
                                }
                            }
                            if (explosion.fractures) {
                                for (const fracture of explosion.fractures) {
                                    fracture.length = Math.min(
                                        fracture.maxLength,
                                        fracture.length + fracture.growth * deltaSeconds
                                    );
                                }
                            }
                            if (explosion.embers) {
                                for (const ember of explosion.embers) {
                                    ember.radius += ember.growth * deltaSeconds;
                                    ember.angle += ember.rotationSpeed * deltaSeconds;
                                    ember.opacity = Math.max(0, ember.opacity - delta / explosion.maxLife);
                                }
                            }
                            break;
                        }
                        default:
                            break;
                    }

                    explosion.life -= delta;
                    if (explosion.life <= 0) {
                        villainExplosions.splice(i, 1);
                    }
                }
            }

            function updateStars(delta) {
                const deltaSeconds = delta / 1000;
                for (let i = stars.length - 1; i >= 0; i--) {
                    const star = stars[i];
                    star.x -= star.speed * deltaSeconds * (0.4 + state.gameSpeed / 600);
                    if (star.x < -star.size) {
                        star.x = viewport.width + star.size;
                        star.y = Math.random() * viewport.height;
                        star.speed = (Math.random() * 0.8 + 0.4) * config.star.baseSpeed;
                    }
                }
            }

            function updateParticles(delta) {
                const deltaSeconds = delta / 1000;
                for (let i = particles.length - 1; i >= 0; i--) {
                    const particle = particles[i];
                    particle.life -= delta;
                    if (particle.life <= 0) {
                        particles.splice(i, 1);
                        continue;
                    }
                    particle.x += particle.vx * deltaSeconds;
                    particle.y += particle.vy * deltaSeconds;
                    particle.vx *= 0.96;
                    particle.vy *= 0.96;
                }
            }

            function updateSpawns(delta) {
                spawnTimers.obstacle += delta;
                spawnTimers.collectible += delta;
                spawnTimers.powerUp += delta;

                if (state.bossBattle.active) {
                    if (!state.bossBattle.bossSpawned) {
                        spawnBoss();
                    }
                    return;
                }

                const obstacleInterval = config.obstacleSpawnInterval / (1 + state.gameSpeed * 0.005 * getSpawnIntensity('obstacle'));
                const collectibleInterval = config.collectibleSpawnInterval / (1 + state.gameSpeed * 0.004 * getSpawnIntensity('collectible'));
                const powerUpInterval = config.powerUpSpawnInterval / (1 + state.gameSpeed * 0.003 * getSpawnIntensity('powerUp'));

                if (spawnTimers.obstacle >= obstacleInterval) {
                    spawnTimers.obstacle = 0;
                    spawnObstacle();
                }

                if (spawnTimers.collectible >= collectibleInterval) {
                    spawnTimers.collectible = 0;
                    spawnCollectible();
                }

                if (spawnTimers.powerUp >= powerUpInterval) {
                    spawnTimers.powerUp = -Math.random() * 2000;
                    spawnPowerUp();
                }
            }

            function getProjectileDamage(projectile) {
                switch (projectile.type) {
                    case 'missile':
                        return 2;
                    case 'spread':
                        return 1;
                    default:
                        return 1;
                }
            }

            function updateProjectilesCollisions() {
                for (let i = projectiles.length - 1; i >= 0; i--) {
                    const projectile = projectiles[i];
                    let projectileRemoved = false;
                    for (let j = obstacles.length - 1; j >= 0; j--) {
                        const obstacle = obstacles[j];
                        if (!rectOverlap(projectile, obstacle)) continue;

                        const damage = getProjectileDamage(projectile);
                        obstacle.health -= damage;
                        obstacle.hitFlash = 160;

                        projectiles.splice(i, 1);
                        projectileRemoved = true;

                        if (obstacle.health <= 0) {
                            obstacles.splice(j, 1);
                            awardDestroy(obstacle);
                            createVillainExplosion(obstacle);
                        } else {
                            createHitSpark({
                                x: obstacle.x + obstacle.width * 0.5,
                                y: obstacle.y + obstacle.height * 0.5,
                                color: { r: 159, g: 168, b: 218 }
                            });
                        }
                        break;
                    }

                    if (projectileRemoved) {
                        continue;
                    }

                    for (let j = asteroids.length - 1; j >= 0; j--) {
                        const asteroid = asteroids[j];
                        const radius = asteroid.radius * (config.asteroid?.collisionRadiusMultiplier ?? 1);
                        if (!circleRectOverlap({ x: asteroid.x, y: asteroid.y, radius }, projectile)) continue;

                        const damage = getProjectileDamage(projectile);
                        projectiles.splice(i, 1);
                        damageAsteroid(asteroid, damage, j);
                        projectileRemoved = true;
                        break;
                    }
                }
            }

            function rectOverlap(a, b) {
                return a.x < b.x + b.width &&
                    a.x + a.width > b.x &&
                    a.y < b.y + b.height &&
                    a.y + a.height > b.y;
            }

            function circleRectOverlap(circle, rect) {
                const closestX = clamp(circle.x, rect.x, rect.x + rect.width);
                const closestY = clamp(circle.y, rect.y, rect.y + rect.height);
                const distanceX = circle.x - closestX;
                const distanceY = circle.y - closestY;
                return (distanceX * distanceX + distanceY * distanceY) < (circle.radius * circle.radius);
            }

            function createHitSpark({ x, y, color }) {
                const sparkCount = reducedEffectsMode ? 4 : 8;
                const speedScale = reducedEffectsMode ? 0.7 : 1;
                const lifeScale = reducedEffectsMode ? 0.75 : 1;
                const sizeScale = reducedEffectsMode ? 0.85 : 1;
                for (let i = 0; i < sparkCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = (Math.random() * 180 + 80) * speedScale;
                    particles.push({
                        x,
                        y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: (300 + Math.random() * 200) * lifeScale,
                        color,
                        size: (Math.random() * 2 + 0.8) * sizeScale
                    });
                }
            }

            function createParticles({ x, y, color, count = 18, speedRange = [60, 340], sizeRange = [1.4, 4.4], lifeRange = [500, 900] }) {
                const intensity = reducedEffectsMode ? 0.6 : 1;
                const spawnCount = Math.max(1, Math.round(count * intensity));
                const speedScale = reducedEffectsMode ? 0.75 : 1;
                const lifeScale = reducedEffectsMode ? 0.75 : 1;
                const sizeScale = reducedEffectsMode ? 0.85 : 1;
                for (let i = 0; i < spawnCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = randomBetween(speedRange[0], speedRange[1]) * speedScale;
                    particles.push({
                        x,
                        y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: randomBetween(lifeRange[0], lifeRange[1]) * lifeScale,
                        color,
                        size: randomBetween(sizeRange[0], sizeRange[1]) * sizeScale
                    });
                }
            }

            function spawnFloatingText({
                text,
                x,
                y,
                color = '#facc15',
                life = 1200,
                variant = 'score',
                multiplier = 1
            }) {
                if (!text) return;
                const scale = 1 + Math.max(0, multiplier - 1) * 0.4;
                floatingTexts.push({
                    text,
                    x,
                    y,
                    color,
                    life,
                    maxLife: life,
                    vx: (Math.random() * 24 - 12) * 0.4,
                    vy: -60 - Math.random() * 30,
                    gravity: 38,
                    scale,
                    variant
                });
            }

            function updateFloatingTexts(delta) {
                const deltaSeconds = delta / 1000;
                for (let i = floatingTexts.length - 1; i >= 0; i--) {
                    const entry = floatingTexts[i];
                    entry.life -= delta;
                    if (entry.life <= 0) {
                        floatingTexts.splice(i, 1);
                        continue;
                    }
                    entry.x += entry.vx * deltaSeconds;
                    entry.y += entry.vy * deltaSeconds;
                    entry.vy += entry.gravity * deltaSeconds;
                }
            }

            function drawFloatingTexts() {
                if (!floatingTexts.length) return;
                ctx.save();
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                for (const entry of floatingTexts) {
                    const alpha = clamp(entry.life / entry.maxLife, 0, 1);
                    const fontSize = 14 + entry.scale * 4;
                    ctx.globalAlpha = alpha;
                    ctx.font = `700 ${fontSize}px ${primaryFontStack}`;
                    ctx.fillStyle = entry.color;
                    let shadowColor = 'rgba(244, 114, 182, 0.65)';
                    if (entry.variant === 'collect') {
                        shadowColor = 'rgba(56, 189, 248, 0.75)';
                    } else if (entry.variant === 'penalty') {
                        shadowColor = 'rgba(248, 113, 113, 0.75)';
                    } else if (entry.variant === 'dodge') {
                        shadowColor = 'rgba(250, 204, 21, 0.65)';
                    }
                    ctx.shadowColor = shadowColor;
                    ctx.shadowBlur = 18 * alpha;
                    ctx.fillText(entry.text, entry.x, entry.y);
                }
                ctx.restore();
            }

            function drawBossAlert(time) {
                const remaining = state.bossBattle.alertTimer;
                if (!canvas || remaining <= 0) {
                    return;
                }
                const elapsed = BOSS_ALERT_DURATION - remaining;
                const flashPeriod = 200;
                const flashOn = Math.floor(elapsed / flashPeriod) % 2 === 0;
                if (!flashOn) {
                    return;
                }
                const alpha = clamp(remaining / BOSS_ALERT_DURATION, 0, 1);
                const centerX = viewport.width / 2;
                const centerY = viewport.height / 2;
                const fontSize = 64 + Math.sin(time * 0.008) * 4;
                ctx.save();
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.globalAlpha = alpha;
                ctx.font = `900 ${fontSize}px ${primaryFontStack}`;
                const gradient = ctx.createLinearGradient(centerX - 220, centerY, centerX + 220, centerY);
                gradient.addColorStop(0, '#facc15');
                gradient.addColorStop(0.5, '#f472b6');
                gradient.addColorStop(1, '#38bdf8');
                ctx.lineJoin = 'round';
                ctx.lineWidth = 6;
                ctx.strokeStyle = 'rgba(15, 23, 42, 0.9)';
                ctx.strokeText('BOSS FIGHT!', centerX, centerY);
                ctx.shadowColor = 'rgba(248, 250, 252, 0.85)';
                ctx.shadowBlur = 22;
                ctx.fillStyle = gradient;
                ctx.fillText('BOSS FIGHT!', centerX, centerY);
                ctx.restore();
            }

            function triggerScreenShake(strength = 6, duration = 220) {
                const strengthScale = reducedEffectsMode ? 0.65 : 1;
                const durationScale = reducedEffectsMode ? 0.75 : 1;
                const effectiveStrength = strength * strengthScale;
                const effectiveDuration = duration * durationScale;
                cameraShake.intensity = Math.max(cameraShake.intensity, effectiveStrength);
                cameraShake.duration = Math.max(cameraShake.duration, effectiveDuration);
                cameraShake.elapsed = 0;
            }

            function updateCameraShake(delta) {
                if (cameraShake.duration <= 0) {
                    cameraShake.offsetX = 0;
                    cameraShake.offsetY = 0;
                    return;
                }
                cameraShake.elapsed += delta;
                if (cameraShake.elapsed >= cameraShake.duration) {
                    cameraShake.intensity = 0;
                    cameraShake.duration = 0;
                    cameraShake.offsetX = 0;
                    cameraShake.offsetY = 0;
                    return;
                }
                const progress = cameraShake.elapsed / cameraShake.duration;
                const falloff = Math.pow(1 - progress, 2);
                const magnitude = cameraShake.intensity * falloff;
                cameraShake.offsetX = (Math.random() * 2 - 1) * magnitude;
                cameraShake.offsetY = (Math.random() * 2 - 1) * magnitude;
            }

            function createVillainExplosion(obstacle) {
                const centerX = obstacle.x + obstacle.width * 0.5;
                const centerY = obstacle.y + obstacle.height * 0.5;
                const palette = villainExplosionPalettes[obstacle.villainType?.key] ?? villainExplosionPalettes.villain1;
                const sizeFactor = obstacle.width;
                const villainKey = obstacle.villainType?.key;
                let explosion;

                switch (villainKey) {
                    case 'villain2': {
                        const orbitCount = 3 + Math.floor(sizeFactor / 36);
                        const orbits = Array.from({ length: orbitCount }, (_, index) => {
                            const depth = index / Math.max(1, orbitCount - 1);
                            const targetRadius = sizeFactor * (0.5 + depth * 0.65);
                            return {
                                radius: targetRadius * 0.45,
                                targetRadius,
                                growth: (260 + sizeFactor * 1.8) * (0.4 + depth * 0.8),
                                thickness: Math.max(3, sizeFactor * (0.035 + depth * 0.018)),
                                angle: Math.random() * Math.PI * 2,
                                rotationSpeed: randomBetween(-1.8, 1.8),
                                eccentricity: randomBetween(0.45, 0.7),
                                targetEccentricity: randomBetween(0.75, 1.05)
                            };
                        });
                        const sparks = Array.from({ length: 14 + Math.floor(sizeFactor / 12) }, () => ({
                            angle: Math.random() * Math.PI * 2,
                            distance: sizeFactor * randomBetween(0.28, 0.6),
                            speed: randomBetween(160, 260),
                            size: randomBetween(2, 5),
                            drift: randomBetween(-1.2, 1.2)
                        }));
                        explosion = {
                            type: 'ionBurst',
                            x: centerX,
                            y: centerY,
                            palette,
                            radius: sizeFactor * 0.34,
                            maxRadius: sizeFactor * 1.72,
                            expansionSpeed: 240 + sizeFactor * 1.6,
                            ringRadius: sizeFactor * 0.58,
                            maxRingRadius: sizeFactor * 2.8,
                            ringGrowth: 260 + sizeFactor * 1.8,
                            ringThickness: Math.max(4, sizeFactor * 0.08),
                            life: 640,
                            maxLife: 640,
                            orbits,
                            sparks,
                            swirl: { angle: Math.random() * Math.PI * 2, speed: randomBetween(1.1, 1.8) }
                        };
                        break;
                    }
                    case 'villain3': {
                        const shockwaves = [
                            {
                                radius: sizeFactor * 0.62,
                                maxRadius: sizeFactor * 3.3,
                                speed: 520 + sizeFactor * 2.4,
                                lineWidth: Math.max(9, sizeFactor * 0.14),
                                opacity: 0.55,
                                delay: 0
                            },
                            {
                                radius: sizeFactor * 0.34,
                                maxRadius: sizeFactor * 2.6,
                                speed: 420 + sizeFactor * 2.0,
                                lineWidth: Math.max(6, sizeFactor * 0.1),
                                opacity: 0.38,
                                delay: 140
                            }
                        ];
                        const fractures = Array.from({ length: 10 + Math.floor(sizeFactor / 12) }, () => ({
                            angle: Math.random() * Math.PI * 2,
                            length: sizeFactor * randomBetween(0.35, 0.8),
                            maxLength: sizeFactor * randomBetween(1.1, 1.8),
                            growth: randomBetween(160, 320),
                            width: Math.max(1.2, sizeFactor * 0.015)
                        }));
                        const embers = Array.from({ length: 18 + Math.floor(sizeFactor / 10) }, () => ({
                            radius: sizeFactor * randomBetween(0.6, 1.6),
                            growth: randomBetween(40, 120),
                            angle: Math.random() * Math.PI * 2,
                            rotationSpeed: randomBetween(-0.8, 0.8),
                            size: randomBetween(2.2, 5),
                            opacity: 0.65
                        }));
                        explosion = {
                            type: 'gravityRift',
                            x: centerX,
                            y: centerY,
                            palette,
                            radius: sizeFactor * 0.46,
                            maxRadius: sizeFactor * 1.52,
                            expansionSpeed: 300 + sizeFactor * 1.4,
                            life: 720,
                            maxLife: 720,
                            shockwaves,
                            fractures,
                            embers,
                            core: { radius: sizeFactor * 0.26, minRadius: sizeFactor * 0.08, collapseSpeed: 220 + sizeFactor * 0.9 }
                        };
                        break;
                    }
                    default: {
                        const spokes = Array.from({ length: 6 + Math.floor(sizeFactor / 16) }, () => ({
                            angle: Math.random() * Math.PI * 2,
                            length: sizeFactor * randomBetween(0.4, 0.7),
                            maxLength: sizeFactor * randomBetween(1, 1.6),
                            growth: randomBetween(180, 320),
                            width: Math.max(2, sizeFactor * 0.04)
                        }));
                        explosion = {
                            type: 'nova',
                            x: centerX,
                            y: centerY,
                            palette,
                            radius: sizeFactor * 0.45,
                            maxRadius: sizeFactor * 1.85,
                            expansionSpeed: 320 + sizeFactor * 2.1,
                            ringRadius: sizeFactor * 0.7,
                            maxRingRadius: sizeFactor * 2.4,
                            ringGrowth: 480 + sizeFactor * 2.6,
                            ringThickness: Math.max(4, sizeFactor * 0.12),
                            life: 520,
                            maxLife: 520,
                            spokes,
                            pulse: Math.random() * Math.PI * 2
                        };
                        break;
                    }
                }

                villainExplosions.push(explosion);
                audioManager.playExplosion(villainKey ?? 'generic');
                triggerScreenShake(Math.min(18, 8 + (sizeFactor ?? 0) * 0.05), 340);

                switch (explosion.type) {
                    case 'ionBurst': {
                        createParticles({
                            x: centerX,
                            y: centerY,
                            color: palette.core,
                            count: 34,
                            speedRange: [140, 360],
                            sizeRange: [1.2, 3.2],
                            lifeRange: [420, 700]
                        });
                        createParticles({
                            x: centerX,
                            y: centerY,
                            color: palette.spark,
                            count: 22,
                            speedRange: [200, 480],
                            sizeRange: [0.8, 2.2],
                            lifeRange: [320, 560]
                        });
                        break;
                    }
                    case 'gravityRift': {
                        createParticles({
                            x: centerX,
                            y: centerY,
                            color: palette.core,
                            count: 42,
                            speedRange: [180, 520],
                            sizeRange: [1.6, 4.8],
                            lifeRange: [520, 880]
                        });
                        createParticles({
                            x: centerX,
                            y: centerY,
                            color: palette.spark,
                            count: 28,
                            speedRange: [220, 620],
                            sizeRange: [1, 2.6],
                            lifeRange: [360, 640]
                        });
                        createHitSpark({ x: centerX, y: centerY, color: palette.halo });
                        break;
                    }
                    default: {
                        createParticles({
                            x: centerX,
                            y: centerY,
                            color: palette.core,
                            count: 28,
                            speedRange: [160, 420],
                            sizeRange: [1.1, 3.4],
                            lifeRange: [360, 620]
                        });

                        createParticles({
                            x: centerX,
                            y: centerY,
                            color: palette.spark,
                            count: 18,
                            speedRange: [220, 520],
                            sizeRange: [0.6, 1.6],
                            lifeRange: [260, 480]
                        });
                        break;
                    }
                }
            }

            function awardCollect(collectible) {
                const points = collectible?.points ?? config.score.collect;
                state.nyan += points;
                awardScore(points, {
                    x: collectible.x + collectible.width * 0.5,
                    y: collectible.y + collectible.height * 0.5,
                    type: 'collect',
                    color: '#7dd3fc'
                });
                triggerScreenShake(3, 160);
                audioManager.playCollect(collectible?.key ?? 'point');
            }

            function awardDestroy(obstacle) {
                const sizeBonus = Math.floor(obstacle.width * 0.6);
                const durabilityBonus = (obstacle.maxHealth ? obstacle.maxHealth - 1 : 0) * 90;
                awardScore(config.score.destroy + sizeBonus + durabilityBonus, {
                    x: obstacle.x + obstacle.width * 0.5,
                    y: obstacle.y + obstacle.height * 0.5,
                    type: 'villain',
                    color: '#f9a8d4'
                });
                triggerScreenShake(12, 300);
                if (challengeManager) {
                    challengeManager.recordEvent('villain', {
                        count: 1,
                        type: obstacle?.villainType?.key ?? null
                    });
                }
                if (isBossObstacle(obstacle)) {
                    completeBossBattle();
                    spawnFloatingText({
                        text: 'Boss Neutralized!',
                        x: obstacle.x + obstacle.width * 0.5,
                        y: obstacle.y,
                        color: '#38bdf8',
                        life: 1400,
                        variant: 'score',
                        multiplier: 1
                    });
                }
            }

            function awardDodge() {
                state.score += config.score.dodge;
                state.comboTimer = Math.max(0, state.comboTimer - 400);
                spawnFloatingText({
                    text: `+${config.score.dodge} Dodge`,
                    x: player.x + player.width,
                    y: player.y + player.height * 0.5,
                    color: '#fde68a',
                    life: 900,
                    variant: 'dodge'
                });
            }

            function getVillainEscapePenalty(obstacle) {
                const basePenalty = config.score?.villainEscape ?? 0;
                const durabilityPenalty = Math.max(0, (obstacle.maxHealth ?? 0) - 1) * 45;
                const sizePenalty = Math.round((obstacle.width ?? 0) * 0.35);
                return Math.max(0, basePenalty + durabilityPenalty + sizePenalty);
            }

            function handleVillainEscape(obstacle) {
                const penalty = getVillainEscapePenalty(obstacle);
                if (penalty > 0) {
                    state.score = Math.max(0, state.score - penalty);
                    spawnFloatingText({
                        text: `-${penalty} pts`,
                        x: player.x + player.width * 0.5,
                        y: player.y + player.height * 0.5,
                        color: '#f87171',
                        life: 1100,
                        variant: 'penalty'
                    });
                    triggerScreenShake(8, 240);
                }
                state.comboTimer = config.comboDecayWindow;
                resetStreak();
                createHitSpark({
                    x: player.x + player.width * 0.5,
                    y: player.y + player.height * 0.5,
                    color: { r: 255, g: 120, b: 120 }
                });
            }

            function awardScore(basePoints, source = {}) {
                state.comboTimer = 0;
                const previousBest = state.bestStreak;
                state.streak += 1;
                if (state.streak > state.bestStreak) {
                    state.bestStreak = state.streak;
                    if (state.bestStreak >= 4 && state.bestStreak > previousBest) {
                        addSocialMoment(`${playerName} pushed a x${state.bestStreak} streak!`, {
                            type: 'combo'
                        });
                    }
                }
                state.tailTarget = config.baseTrailLength + state.streak * config.trailGrowthPerStreak;
                const multiplier = 1 + state.streak * config.comboMultiplierStep;
                const finalPoints = Math.floor(basePoints * multiplier);
                state.score += finalPoints;
                if (challengeManager) {
                    challengeManager.recordEvent('score', { totalScore: state.score, deltaScore: finalPoints });
                }
                const originX = source.x ?? player.x + player.width * 0.5;
                const originY = source.y ?? player.y;
                const text = `+${finalPoints.toLocaleString()}${multiplier > 1.01 ? ` x${multiplier.toFixed(2)}` : ''}`;
                spawnFloatingText({
                    text,
                    x: originX,
                    y: originY,
                    color: source.color ?? '#fbbf24',
                    variant: source.type ?? 'score',
                    multiplier
                });
                if (finalPoints >= 600) {
                    triggerScreenShake(Math.min(16, 6 + finalPoints / 400), 280);
                }
            }

            function resetStreak() {
                state.streak = 0;
                state.tailTarget = config.baseTrailLength;
            }

            function finalizePendingSubmission({ recorded, reason = null, placement = null, runsToday = 0 } = {}) {
                if (!pendingSubmission) {
                    return null;
                }
                const summary = { ...pendingSubmission };
                const formattedTime = formatTime(summary.timeMs);
                const formattedScore = summary.score.toLocaleString();
                const timestamp = summary.recordedAt;
                lastRunSummary = {
                    player: summary.player,
                    timeMs: summary.timeMs,
                    score: summary.score,
                    nyan: summary.nyan,
                    bestStreak: summary.bestStreak,
                    placement,
                    recordedAt: timestamp,
                    runsToday,
                    recorded,
                    reason
                };
                updateSharePanel();
                const runDescriptor = runsToday
                    ? ` (${Math.min(runsToday, SUBMISSION_LIMIT)}/${SUBMISSION_LIMIT} today)`
                    : '';
                if (recorded) {
                    if (placement && placement <= 7) {
                        addSocialMoment(`${summary.player} entered the galaxy standings at #${placement}!${runDescriptor}`, {
                            type: 'leaderboard',
                            timestamp
                        });
                    } else {
                        addSocialMoment(`${summary.player} logged ${formattedTime} for ${formattedScore} pts${runDescriptor}.`, {
                            type: 'score',
                            timestamp
                        });
                    }
                } else if (reason === 'limit') {
                    addSocialMoment(`${summary.player} maxed out their daily flight logs for now.`, {
                        type: 'limit',
                        timestamp
                    });
                } else if (reason === 'skipped') {
                    addSocialMoment(`${summary.player} survived ${formattedTime} for ${formattedScore} pts.`, {
                        type: 'score',
                        timestamp
                    });
                } else if (reason === 'conflict') {
                    addSocialMoment(`${summary.player} already has a stronger log on the board.`, {
                        type: 'limit',
                        timestamp
                    });
                } else if (reason === 'error') {
                    addSocialMoment(`${summary.player}'s log hit turbulence. Retry shortly.`, {
                        type: 'limit',
                        timestamp
                    });
                }
                pendingSubmission = null;
                return { summary, formattedTime, formattedScore };
            }

            function triggerGameOver(message) {
                if (state.gameState !== 'running') return;
                state.gameState = 'gameover';
                audioManager.stopGameplayMusic();
                audioManager.stopHyperBeam();
                const finalTimeMs = state.elapsedTime;
                const runTimestamp = Date.now();
                const usage = getSubmissionUsage(playerName, runTimestamp);
                const limitReached = usage.count >= SUBMISSION_LIMIT;
                pendingSubmission = {
                    player: playerName,
                    timeMs: finalTimeMs,
                    score: state.score,
                    nyan: state.nyan,
                    bestStreak: state.bestStreak,
                    recordedAt: runTimestamp,
                    baseMessage: message,
                    quotaCount: usage.count,
                    limitReached
                };
                lastRunSummary = {
                    player: playerName,
                    timeMs: finalTimeMs,
                    score: state.score,
                    nyan: state.nyan,
                    bestStreak: state.bestStreak,
                    placement: null,
                    recordedAt: runTimestamp,
                    runsToday: usage.count,
                    recorded: false,
                    reason: limitReached ? 'limit' : 'pending'
                };
                updateSharePanel();
                updateTimerDisplay();
                const promptMessage = buildRunSummaryMessage(message, pendingSubmission, {
                    runsToday: usage.count,
                    limitReached,
                    prompt: !limitReached
                });
                const primaryText = limitReached ? 'Retry Flight' : 'Submit Flight Log';
                const primaryMode = limitReached ? 'retry' : 'submit';
                const secondaryConfig = limitReached
                    ? null
                    : { text: 'Skip Submission', launchMode: 'retry' };
                showOverlay(promptMessage, primaryText, {
                    title: '',
                    enableButton: true,
                    launchMode: primaryMode,
                    secondaryButton: secondaryConfig
                });
            }

            function skipScoreSubmission() {
                if (!pendingSubmission) {
                    return;
                }
                pendingSubmission.player = getPendingPlayerName();
                const runsToday = pendingSubmission.limitReached
                    ? Math.min(
                        typeof pendingSubmission.quotaCount === 'number'
                            ? pendingSubmission.quotaCount
                            : SUBMISSION_LIMIT,
                        SUBMISSION_LIMIT
                    )
                    : getSubmissionUsage(pendingSubmission.player, pendingSubmission.recordedAt).count;
                const reason = pendingSubmission.limitReached ? 'limit' : 'skipped';
                finalizePendingSubmission({
                    recorded: false,
                    reason,
                    runsToday
                });
            }

            async function attemptSubmitScore() {
                if (!pendingSubmission) {
                    return;
                }
                const submission = { ...pendingSubmission };
                submission.player = commitPlayerNameInput();
                pendingSubmission.player = submission.player;
                setOverlaySubmittingState(true);
                try {
                    const result = await recordHighScore(submission.timeMs, submission.score, {
                        player: submission.player,
                        bestStreak: submission.bestStreak,
                        nyan: submission.nyan,
                        recordedAt: submission.recordedAt
                    });
                    if (!result || !result.recorded) {
                        const runsToday = result?.runsToday ?? getSubmissionUsage(submission.player, submission.recordedAt).count;
                        const reason = result?.reason ?? 'limit';
                        const placement = result?.placement ?? null;
                        finalizePendingSubmission({ recorded: false, reason, placement, runsToday });
                        const message = buildRunSummaryMessage(submission.baseMessage, submission, {
                            runsToday,
                            limitReached: reason === 'limit',
                            conflict: reason === 'conflict',
                            errorMessage: result?.message ?? null
                        });
                        setOverlaySubmittingState(false);
                        const primaryLabel = reason === 'limit' ? 'Retry Flight' : getRetryControlText();
                        showOverlay(message, primaryLabel, { title: '', enableButton: true, launchMode: 'retry' });
                        return;
                    }
                    const runsToday = result.runsToday ?? getSubmissionUsage(submission.player, submission.recordedAt).count;
                    const placement = result.placement ?? null;
                    finalizePendingSubmission({
                        recorded: true,
                        reason: result.reason ?? null,
                        placement,
                        runsToday
                    });
                    updateHighScorePanel();
                    const message = buildRunSummaryMessage(submission.baseMessage, submission, {
                        placement,
                        runsToday,
                        success: result.source === 'remote',
                        offline: result.source === 'offline',
                        errorMessage: result.message ?? null
                    });
                    setOverlaySubmittingState(false);
                    showOverlay(message, getRetryControlText(), { title: '', enableButton: true, launchMode: 'retry' });
                } catch (error) {
                    console.error('Unexpected score submission failure', error);
                    const runsToday = getSubmissionUsage(submission.player, submission.recordedAt).count;
                    finalizePendingSubmission({ recorded: false, reason: 'error', runsToday });
                    const message = buildRunSummaryMessage(submission.baseMessage, submission, {
                        runsToday,
                        errorMessage: 'Unexpected error while submitting. Try again shortly.'
                    });
                    setOverlaySubmittingState(false);
                    showOverlay(message, 'Retry Flight', { title: '', enableButton: true, launchMode: 'retry' });
                }
            }

            function handleOverlayAction(mode) {
                const action = mode || (state.gameState === 'ready' ? 'launch' : 'retry');
                if (action === 'submit') {
                    const submissionPromise = attemptSubmitScore();
                    if (submissionPromise && typeof submissionPromise.catch === 'function') {
                        submissionPromise.catch((error) => {
                            console.error('Unhandled submission error', error);
                        });
                    }
                    return;
                }
                if (action === 'retry') {
                    skipScoreSubmission();
                    startGame();
                    return;
                }
                startGame();
            }

            function updateCombo(delta) {
                state.comboTimer += delta;
                if (state.comboTimer >= config.comboDecayWindow && state.streak > 0) {
                    resetStreak();
                }
                const ratio = clamp(1 - state.comboTimer / config.comboDecayWindow, 0, 1);
                const percentage = Math.round(ratio * 100);
                if (percentage !== lastComboPercent) {
                    if (comboFillEl) {
                        comboFillEl.style.width = `${percentage}%`;
                    }
                    comboMeterEl?.setAttribute('aria-valuenow', String(percentage));
                    lastComboPercent = percentage;
                }
                if (comboMeterEl) {
                    const charged = state.streak >= 5 && ratio > 0.4;
                    comboMeterEl.classList.toggle('charged', charged);
                }
            }

            function updateHUD() {
                const formattedScore = state.score.toLocaleString();
                if (formattedScore !== hudCache.score) {
                    hudCache.score = formattedScore;
                    if (scoreEl) {
                        scoreEl.textContent = formattedScore;
                    }
                }

                const formattedNyan = state.nyan.toLocaleString();
                if (formattedNyan !== hudCache.nyan) {
                    hudCache.nyan = formattedNyan;
                    if (nyanEl) {
                        nyanEl.textContent = formattedNyan;
                    }
                }

                const comboMultiplierText = `x${(1 + state.streak * config.comboMultiplierStep).toFixed(2)}`;
                if (comboMultiplierText !== hudCache.comboMultiplier) {
                    hudCache.comboMultiplier = comboMultiplierText;
                    if (streakEl) {
                        streakEl.textContent = comboMultiplierText;
                    }
                }

                const bestTailLengthText = `${Math.round(
                    config.baseTrailLength + state.bestStreak * config.trailGrowthPerStreak
                )}`;
                if (bestTailLengthText !== hudCache.bestTailLength) {
                    hudCache.bestTailLength = bestTailLengthText;
                    if (bestStreakEl) {
                        bestStreakEl.textContent = bestTailLengthText;
                    }
                }

                const marketCapText = `${(6.6 + state.score / 1400).toFixed(1)}K`;
                if (marketCapText !== hudCache.marketCap) {
                    hudCache.marketCap = marketCapText;
                    if (mcapEl) {
                        mcapEl.textContent = marketCapText;
                    }
                }

                const normalizedCollects = state.nyan / baseCollectScore;
                const volumeText = `${(2.8 + normalizedCollects * 0.6 + state.streak * 0.3).toFixed(1)}K`;
                if (volumeText !== hudCache.volume) {
                    hudCache.volume = volumeText;
                    if (volEl) {
                        volEl.textContent = volumeText;
                    }
                }

                const activeBoosts = powerUpTypes
                    .filter((type) => isPowerUpActive(type))
                    .map((type) => `${powerUpLabels[type]} ${(state.powerUpTimers[type] / 1000).toFixed(1)}s`);
                const powerUpText = activeBoosts.length ? activeBoosts.join(' | ') : 'None';
                if (powerUpText !== hudCache.powerUps) {
                    hudCache.powerUps = powerUpText;
                    if (powerUpsEl) {
                        powerUpsEl.textContent = powerUpText;
                    }
                }
            }

            function drawBackground() {
                ctx.fillStyle = '#05091f';
                ctx.fillRect(0, 0, viewport.width, viewport.height);
                const gradient = ctx.createLinearGradient(0, 0, 0, viewport.height);
                gradient.addColorStop(0, 'rgba(26, 35, 126, 0.85)');
                gradient.addColorStop(0.5, 'rgba(21, 11, 45, 0.85)');
                gradient.addColorStop(1, 'rgba(0, 2, 12, 0.95)');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, viewport.width, viewport.height);
            }

            function drawStars(time) {
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                for (const star of stars) {
                    const twinkle = (Math.sin(time * 0.002 + star.twinkleOffset) + 1) * 0.5;
                    ctx.fillStyle = `rgba(255, 255, 255, ${0.3 + twinkle * 0.7})`;
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
            }

            function drawTrail() {
                if (isPowerUpActive(PUMP_POWER) || pumpTailState.fade > 0) {
                    drawPumpTail();
                    return;
                }
                if (trail.length < 2) return;
                const style = activeTrailStyle ?? trailStyles.rainbow;
                ctx.save();
                if (style.type === 'palette' && Array.isArray(style.colors) && style.colors.length) {
                    for (let i = 0; i < trail.length; i++) {
                        const t = trail[i];
                        const alpha = i / trail.length;
                        const colorIndex = Math.min(style.colors.length - 1, Math.floor(alpha * style.colors.length));
                        ctx.globalAlpha = alpha;
                        ctx.fillStyle = style.colors[colorIndex] ?? '#7dd3fc';
                        ctx.fillRect(t.x - 36, t.y - 6, 72, 12);
                    }
                } else {
                    for (let i = 0; i < trail.length; i++) {
                        const t = trail[i];
                        const alpha = i / trail.length;
                        const hue = (alpha * 300 + performance.now() * 0.05) % 360;
                        ctx.fillStyle = `hsla(${hue}, 100%, 60%, ${alpha})`;
                        ctx.fillRect(t.x - 36, t.y - 6, 72, 12);
                    }
                }
                ctx.restore();
            }

            function drawShieldAura(drawX, drawY, time = performance.now()) {
                if (!isShieldActive()) return;
                const shieldConfig = config.defensePower ?? {};
                const auraColor = shieldConfig.auraColor ?? { r: 150, g: 214, b: 255 };
                const duration = config.powerUp.duration[SHIELD_POWER] ?? 1;
                const remaining = clamp(state.powerUpTimers[SHIELD_POWER] / duration, 0, 1);
                const pulseStrength = Math.sin(time * 0.007) * (shieldConfig.auraPulse ?? 0.18);
                const hitPulse = state.shieldHitPulse ?? 0;
                const baseRadius = Math.max(player.width, player.height) * (0.65 + pulseStrength + hitPulse * 0.18);
                const centerX = drawX + player.width * 0.5;
                const centerY = drawY + player.height * 0.5;

                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.globalCompositeOperation = 'lighter';

                const gradient = ctx.createRadialGradient(0, 0, baseRadius * 0.35, 0, 0, baseRadius);
                gradient.addColorStop(0, `rgba(${auraColor.r}, ${auraColor.g}, ${auraColor.b}, ${0.55 + hitPulse * 0.25})`);
                gradient.addColorStop(0.58, `rgba(${auraColor.r}, ${auraColor.g}, ${auraColor.b}, ${0.28 + remaining * 0.35})`);
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(0, 0, baseRadius, 0, Math.PI * 2);
                ctx.fill();

                const ringRadius = baseRadius * (0.88 + 0.06 * Math.sin(time * 0.012 + hitPulse));
                ctx.strokeStyle = `rgba(${auraColor.r}, ${auraColor.g}, ${auraColor.b}, ${0.35 + remaining * 0.4})`;
                ctx.lineWidth = 4.2 + hitPulse * 2.6;
                ctx.beginPath();
                ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
                ctx.stroke();

                const sparkCount = 7;
                for (let i = 0; i < sparkCount; i++) {
                    const angle = time * 0.0035 + i * (Math.PI * 2 / sparkCount);
                    const sparkRadius = ringRadius * (0.92 + 0.08 * Math.sin(time * 0.01 + i));
                    const px = Math.cos(angle) * sparkRadius;
                    const py = Math.sin(angle) * sparkRadius;
                    const sparkAlpha = 0.55 + 0.35 * Math.sin(time * 0.02 + i * 1.3 + hitPulse * 0.6);
                    ctx.save();
                    ctx.translate(px, py);
                    ctx.rotate(angle);
                    ctx.fillStyle = `rgba(${auraColor.r}, ${auraColor.g}, ${auraColor.b}, ${sparkAlpha})`;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, 7 + hitPulse * 3, 2.4 + hitPulse * 1.2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }

                ctx.restore();
            }

            function drawPlayer() {
                const now = performance.now();
                const bob = Math.sin(now * 0.005) * 4;
                const drawX = player.x;
                const drawY = player.y + bob;
                drawShieldAura(drawX, drawY, now);
                if (activePlayerImage.complete && activePlayerImage.naturalWidth !== 0) {
                    ctx.drawImage(activePlayerImage, drawX, drawY, player.width, player.height);
                } else {
                    const gradient = ctx.createLinearGradient(drawX, drawY, drawX + player.width, drawY + player.height);
                    gradient.addColorStop(0, '#ff9a9e');
                    gradient.addColorStop(0.5, '#fad0c4');
                    gradient.addColorStop(1, '#fad0c4');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(drawX, drawY, player.width, player.height);
                }

                if (isShieldActive()) {
                    drawShieldAura(drawX, drawY, now + 40);
                }
            }

            function drawObstacles() {
                for (const obstacle of obstacles) {
                    ctx.save();
                    ctx.translate(obstacle.x + obstacle.width / 2, obstacle.y + obstacle.height / 2);
                    ctx.rotate(obstacle.rotation);

                    if (obstacle.image && obstacle.image.complete && obstacle.image.naturalWidth > 0) {
                        ctx.drawImage(
                            obstacle.image,
                            -obstacle.width / 2,
                            -obstacle.height / 2,
                            obstacle.width,
                            obstacle.height
                        );
                    } else {
                        const radius = obstacle.width / 2;
                        ctx.beginPath();
                        ctx.moveTo(radius, 0);
                        for (let i = 1; i < 6; i++) {
                            const angle = i * (Math.PI * 2 / 6);
                            ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
                        }
                        ctx.closePath();
                        ctx.fillStyle = '#4f46e5';
                        ctx.fill();
                        ctx.strokeStyle = 'rgba(255,255,255,0.25)';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }

                    if (obstacle.hitFlash > 0) {
                        const flashAlpha = clamp(obstacle.hitFlash / 160, 0, 1);
                        ctx.fillStyle = `rgba(255, 255, 255, ${0.35 * flashAlpha})`;
                        ctx.fillRect(-obstacle.width / 2, -obstacle.height / 2, obstacle.width, obstacle.height);
                    }

                    ctx.restore();

                    if (obstacle.maxHealth > 1) {
                        const ratio = clamp(obstacle.health / obstacle.maxHealth, 0, 1);
                        const barWidth = obstacle.width;
                        const barHeight = 6;
                        const barX = obstacle.x;
                        const barY = obstacle.y - 10;
                        ctx.fillStyle = 'rgba(79,70,229,0.35)';
                        ctx.fillRect(barX, barY, barWidth, barHeight);
                        ctx.fillStyle = '#a5b4fc';
                        ctx.fillRect(barX, barY, barWidth * ratio, barHeight);
                    }
                }
            }

            function drawCollectibles(time) {
                for (const collectible of collectibles) {
                    ctx.save();
                    ctx.translate(collectible.x + collectible.width / 2, collectible.y + collectible.height / 2);
                    ctx.rotate(Math.sin(time * 0.004 + collectible.wobbleTime) * 0.2);
                    const pulse = Math.sin(time * 0.004 + collectible.wobbleTime);
                    const sprite = collectible.sprite;
                    const spriteReady = sprite?.complete && sprite.naturalWidth > 0;
                    const glowColors = collectible.glow ?? {};
                    const innerGlow = glowColors.inner ?? 'rgba(255, 255, 255, 0.9)';
                    const outerGlow = glowColors.outer ?? 'rgba(255, 215, 0, 0.2)';

                    const glowRadius = collectible.width * (0.62 + 0.08 * pulse);
                    const gradient = ctx.createRadialGradient(0, 0, glowRadius * 0.35, 0, 0, glowRadius);
                    gradient.addColorStop(0, innerGlow);
                    gradient.addColorStop(1, outerGlow);
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, glowRadius, 0, Math.PI * 2);
                    ctx.fill();

                    if (spriteReady) {
                        const drawSize = collectible.width * (0.9 + 0.1 * pulse);
                        ctx.drawImage(sprite, -drawSize / 2, -drawSize / 2, drawSize, drawSize);
                    } else {
                        const fallbackRadius = collectible.width * 0.48;
                        const fallbackGradient = ctx.createRadialGradient(0, 0, 4, 0, 0, fallbackRadius);
                        fallbackGradient.addColorStop(0, innerGlow);
                        fallbackGradient.addColorStop(1, outerGlow);
                        ctx.fillStyle = fallbackGradient;
                        ctx.beginPath();
                        ctx.arc(0, 0, fallbackRadius, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#0f172a';
                        ctx.font = `700 10px ${primaryFontStack}`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(collectible.label ?? 'POINTS', 0, 0);
                    }
                    ctx.restore();
                }
            }

            function drawPowerUps(time) {
                for (const powerUp of powerUps) {
                    ctx.save();
                    ctx.translate(powerUp.x + powerUp.width / 2, powerUp.y + powerUp.height / 2);
                    const pulse = 0.15 * Math.sin(time * 0.006 + powerUp.wobbleTime);
                    const radius = powerUp.width * (0.36 + pulse);
                    const color = powerUpColors[powerUp.type] ?? { r: 220, g: 220, b: 255 };
                    const gradient = ctx.createRadialGradient(0, 0, radius * 0.25, 0, 0, radius);
                    gradient.addColorStop(0, `rgba(${color.r}, ${color.g}, ${color.b}, 0.95)`);
                    gradient.addColorStop(0.65, `rgba(${color.r}, ${color.g}, ${color.b}, 0.6)`);
                    gradient.addColorStop(1, 'rgba(255,255,255,0.1)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, radius, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = 'rgba(255,255,255,0.4)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, radius * 0.7, 0, Math.PI * 2);
                    ctx.stroke();

                    const sprite = powerUpImages[powerUp.type];
                    const isSpriteReady = sprite?.complete && sprite.naturalWidth !== 0;
                    if (isSpriteReady) {
                        const drawSize = powerUp.width;
                        ctx.drawImage(sprite, -drawSize / 2, -drawSize / 2, drawSize, drawSize);
                    } else {
                        ctx.fillStyle = '#060b28';
                        ctx.font = `700 12px ${primaryFontStack}`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        const label = powerUpLabels[powerUp.type] ?? 'BOOST';
                        ctx.fillText(label.split(' ')[0], 0, -6);
                        if (label.includes(' ')) {
                            ctx.fillText(label.split(' ')[1], 0, 8);
                        }
                    }
                    ctx.restore();
                }
            }

            function drawAreaBursts() {
                if (!areaBursts.length) return;
                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                for (const burst of areaBursts) {
                    const opacity = clamp(burst.life / 650, 0, 1);
                    const gradient = ctx.createRadialGradient(burst.x, burst.y, burst.radius * 0.4, burst.x, burst.y, burst.radius);
                    gradient.addColorStop(0, `rgba(255, 185, 130, ${0.35 * opacity})`);
                    gradient.addColorStop(1, 'rgba(255, 120, 80, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(burst.x, burst.y, burst.radius, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = `rgba(255, 200, 150, ${0.5 * opacity})`;
                    ctx.lineWidth = 6;
                    ctx.beginPath();
                    ctx.arc(burst.x, burst.y, burst.radius * 0.85, 0, Math.PI * 2);
                    ctx.stroke();
                }
                ctx.restore();
            }

            function drawVillainExplosions() {
                if (!villainExplosions.length) return;
                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                for (const explosion of villainExplosions) {
                    const palette = explosion.palette ?? villainExplosionPalettes.villain1;
                    const alpha = clamp(explosion.life / explosion.maxLife, 0, 1);

                    switch (explosion.type) {
                        case 'ionBurst': {
                            const gradient = ctx.createRadialGradient(
                                explosion.x,
                                explosion.y,
                                Math.max(6, explosion.radius * 0.2),
                                explosion.x,
                                explosion.y,
                                Math.max(explosion.radius, 1)
                            );
                            gradient.addColorStop(
                                0,
                                `rgba(${palette.core.r}, ${palette.core.g}, ${palette.core.b}, ${0.65 * alpha})`
                            );
                            gradient.addColorStop(
                                0.6,
                                `rgba(${palette.halo.r}, ${palette.halo.g}, ${palette.halo.b}, ${0.4 * alpha})`
                            );
                            gradient.addColorStop(1, `rgba(${palette.halo.r}, ${palette.halo.g}, ${palette.halo.b}, 0)`);
                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(explosion.x, explosion.y, explosion.radius, 0, Math.PI * 2);
                            ctx.fill();

                            if (explosion.orbits) {
                                for (const orbit of explosion.orbits) {
                                    const orbitAlpha = alpha * 0.35;
                                    ctx.save();
                                    ctx.translate(explosion.x, explosion.y);
                                    ctx.rotate(orbit.angle);
                                    ctx.strokeStyle = `rgba(${palette.halo.r}, ${palette.halo.g}, ${palette.halo.b}, ${orbitAlpha})`;
                                    ctx.lineWidth = orbit.thickness;
                                    ctx.beginPath();
                                    ctx.ellipse(0, 0, orbit.radius, orbit.radius * orbit.eccentricity, 0, 0, Math.PI * 2);
                                    ctx.stroke();
                                    ctx.restore();
                                }
                            }

                            if (typeof explosion.ringRadius === 'number') {
                                ctx.strokeStyle = `rgba(${palette.core.r}, ${palette.core.g}, ${palette.core.b}, ${0.25 * alpha})`;
                                ctx.lineWidth = explosion.ringThickness ?? 6;
                                ctx.beginPath();
                                ctx.arc(explosion.x, explosion.y, explosion.ringRadius, 0, Math.PI * 2);
                                ctx.stroke();
                            }

                            if (explosion.swirl) {
                                const swirlSegments = 18;
                                ctx.strokeStyle = `rgba(${palette.core.r}, ${palette.core.g}, ${palette.core.b}, ${0.4 * alpha})`;
                                ctx.lineWidth = Math.max(2, (explosion.ringThickness ?? 6) * 0.4);
                                ctx.beginPath();
                                for (let i = 0; i < swirlSegments; i++) {
                                    const t = i / (swirlSegments - 1);
                                    const angle = explosion.swirl.angle + t * Math.PI * 2;
                                    const radius = explosion.radius * (0.2 + t * 0.8);
                                    const px = explosion.x + Math.cos(angle) * radius;
                                    const py = explosion.y + Math.sin(angle) * radius * 0.6;
                                    if (i === 0) {
                                        ctx.moveTo(px, py);
                                    } else {
                                        ctx.lineTo(px, py);
                                    }
                                }
                                ctx.stroke();
                            }

                            if (explosion.sparks) {
                                for (const spark of explosion.sparks) {
                                    const px = explosion.x + Math.cos(spark.angle) * spark.distance;
                                    const py = explosion.y + Math.sin(spark.angle) * spark.distance * 0.9;
                                    const sparkAlpha = alpha * 0.65;
                                    ctx.fillStyle = `rgba(${palette.spark.r}, ${palette.spark.g}, ${palette.spark.b}, ${sparkAlpha})`;
                                    ctx.beginPath();
                                    ctx.arc(px, py, spark.size, 0, Math.PI * 2);
                                    ctx.fill();
                                }
                            }
                            break;
                        }
                        case 'gravityRift': {
                            const gradient = ctx.createRadialGradient(
                                explosion.x,
                                explosion.y,
                                Math.max(4, explosion.radius * 0.12),
                                explosion.x,
                                explosion.y,
                                Math.max(explosion.radius, 1)
                            );
                            gradient.addColorStop(
                                0,
                                `rgba(${palette.core.r}, ${palette.core.g}, ${palette.core.b}, ${0.7 * alpha})`
                            );
                            gradient.addColorStop(
                                0.5,
                                `rgba(${palette.halo.r}, ${palette.halo.g}, ${palette.halo.b}, ${0.45 * alpha})`
                            );
                            gradient.addColorStop(1, `rgba(${palette.halo.r}, ${palette.halo.g}, ${palette.halo.b}, 0)`);
                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(explosion.x, explosion.y, explosion.radius, 0, Math.PI * 2);
                            ctx.fill();

                            if (explosion.shockwaves) {
                                for (const shock of explosion.shockwaves) {
                                    if (shock.delay > 0) continue;
                                    const shockAlpha = alpha * shock.opacity;
                                    ctx.strokeStyle = `rgba(${palette.halo.r}, ${palette.halo.g}, ${palette.halo.b}, ${shockAlpha})`;
                                    ctx.lineWidth = shock.lineWidth;
                                    ctx.beginPath();
                                    ctx.arc(explosion.x, explosion.y, shock.radius, 0, Math.PI * 2);
                                    ctx.stroke();
                                }
                            }

                            if (explosion.fractures) {
                                ctx.lineCap = 'round';
                                for (const fracture of explosion.fractures) {
                                    const fx = explosion.x + Math.cos(fracture.angle) * fracture.length;
                                    const fy = explosion.y + Math.sin(fracture.angle) * fracture.length;
                                    ctx.strokeStyle = `rgba(${palette.spark.r}, ${palette.spark.g}, ${palette.spark.b}, ${0.35 * alpha})`;
                                    ctx.lineWidth = fracture.width;
                                    ctx.beginPath();
                                    ctx.moveTo(explosion.x, explosion.y);
                                    ctx.lineTo(fx, fy);
                                    ctx.stroke();
                                }
                            }

                            if (explosion.embers) {
                                for (const ember of explosion.embers) {
                                    if (ember.opacity <= 0) continue;
                                    const ex = explosion.x + Math.cos(ember.angle) * ember.radius;
                                    const ey = explosion.y + Math.sin(ember.angle) * ember.radius * 0.85;
                                    const emberAlpha = alpha * ember.opacity;
                                    ctx.fillStyle = `rgba(${palette.spark.r}, ${palette.spark.g}, ${palette.spark.b}, ${emberAlpha})`;
                                    ctx.beginPath();
                                    ctx.arc(ex, ey, ember.size, 0, Math.PI * 2);
                                    ctx.fill();
                                }
                            }

                            if (explosion.core) {
                                ctx.save();
                                ctx.globalCompositeOperation = 'source-over';
                                ctx.fillStyle = 'rgba(6, 8, 20, 0.85)';
                                ctx.beginPath();
                                ctx.arc(explosion.x, explosion.y, explosion.core.radius, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.restore();
                            }
                            break;
                        }
                        default: {
                            const gradient = ctx.createRadialGradient(
                                explosion.x,
                                explosion.y,
                                Math.max(6, explosion.radius * 0.2),
                                explosion.x,
                                explosion.y,
                                Math.max(explosion.radius, 1)
                            );
                            gradient.addColorStop(
                                0,
                                `rgba(${palette.core.r}, ${palette.core.g}, ${palette.core.b}, ${0.55 * alpha})`
                            );
                            gradient.addColorStop(1, `rgba(${palette.halo.r}, ${palette.halo.g}, ${palette.halo.b}, 0)`);
                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(explosion.x, explosion.y, explosion.radius, 0, Math.PI * 2);
                            ctx.fill();

                            if (typeof explosion.ringRadius === 'number') {
                                const pulse = Math.sin(explosion.pulse ?? 0) * 0.5 + 0.5;
                                ctx.strokeStyle = `rgba(${palette.core.r}, ${palette.core.g}, ${palette.core.b}, ${0.35 * alpha * pulse})`;
                                ctx.lineWidth = explosion.ringThickness;
                                ctx.beginPath();
                                ctx.arc(explosion.x, explosion.y, explosion.ringRadius, 0, Math.PI * 2);
                                ctx.stroke();
                            }

                            if (explosion.spokes) {
                                ctx.lineCap = 'round';
                                for (const spoke of explosion.spokes) {
                                    const sx = explosion.x + Math.cos(spoke.angle) * spoke.length;
                                    const sy = explosion.y + Math.sin(spoke.angle) * spoke.length;
                                    ctx.strokeStyle = `rgba(${palette.spark.r}, ${palette.spark.g}, ${palette.spark.b}, ${0.6 * alpha})`;
                                    ctx.lineWidth = spoke.width;
                                    ctx.beginPath();
                                    ctx.moveTo(explosion.x, explosion.y);
                                    ctx.lineTo(sx, sy);
                                    ctx.stroke();
                                }
                            }
                            break;
                        }
                    }
                }
                ctx.restore();
            }

            function drawHyperBeam(time) {
                const bounds = hyperBeamState.bounds;
                const intensity = hyperBeamState.intensity;
                if (!bounds || intensity <= 0) {
                    return;
                }

                const hyperConfig = config.hyperBeam ?? {};
                const color = powerUpColors[HYPER_BEAM_POWER] ?? { r: 147, g: 197, b: 253 };
                const effectScale = reducedEffectsMode ? 0.7 : 1;
                const jitterAmplitude = (hyperConfig.jitterAmplitude ?? 18) * effectScale;
                const verticalJitter = Math.sin(time * 0.008 + hyperBeamState.wave) * jitterAmplitude * intensity;
                const top = clamp(bounds.y + verticalJitter * -0.5, 0, Math.max(0, viewport.height - bounds.height));
                const height = Math.min(bounds.height, viewport.height - top);
                if (height <= 0) {
                    return;
                }
                const midY = clamp(top + height / 2 + verticalJitter * 0.3, top, top + height);

                ctx.save();
                ctx.globalCompositeOperation = 'lighter';

                const outerGradient = ctx.createLinearGradient(bounds.x, top, bounds.x + bounds.width, top);
                const outerAlpha = Math.min(1, (0.32 + intensity * 0.28) * effectScale);
                const midAlpha = Math.min(1, (0.5 + intensity * 0.3) * effectScale);
                outerGradient.addColorStop(0, `rgba(${color.r}, ${color.g}, ${color.b}, ${outerAlpha})`);
                outerGradient.addColorStop(0.45, `rgba(${color.r}, ${color.g}, ${color.b}, ${midAlpha})`);
                outerGradient.addColorStop(1, 'rgba(17, 24, 39, 0)');
                ctx.fillStyle = outerGradient;
                ctx.fillRect(bounds.x, top, bounds.width, height);

                const coreHeight = Math.max(18, height * 0.36 * (reducedEffectsMode ? 0.85 : 1));
                const coreTop = clamp(midY - coreHeight / 2, top, top + height - coreHeight);
                const coreWidth = bounds.width * (reducedEffectsMode ? 0.8 : 0.9);
                const coreGradient = ctx.createLinearGradient(bounds.x, coreTop, bounds.x + coreWidth, coreTop);
                coreGradient.addColorStop(0, `rgba(236, 254, 255, ${Math.min(1, 0.85 * intensity * effectScale)})`);
                coreGradient.addColorStop(1, 'rgba(148, 210, 255, 0)');
                ctx.fillStyle = coreGradient;
                ctx.fillRect(bounds.x, coreTop, coreWidth, coreHeight);

                ctx.strokeStyle = `rgba(236, 254, 255, ${Math.min(1, 0.55 * intensity * effectScale)})`;
                ctx.lineWidth = Math.max(2, height * 0.12 * intensity * effectScale);
                ctx.beginPath();
                ctx.moveTo(bounds.x, midY + Math.sin(time * 0.014 + hyperBeamState.wave) * height * 0.08);
                ctx.lineTo(bounds.x + bounds.width, midY + Math.sin(time * 0.017 + hyperBeamState.wave) * height * 0.05);
                ctx.stroke();

                ctx.restore();
            }

            function drawProjectiles() {
                for (const projectile of projectiles) {
                    if (projectile.type === 'missile') {
                        ctx.save();
                        ctx.translate(projectile.x + projectile.width * 0.5, projectile.y + projectile.height * 0.5);
                        const angle = Math.atan2(projectile.vy, projectile.vx);
                        ctx.rotate(angle);
                        ctx.fillStyle = '#ffb74d';
                        ctx.fillRect(-projectile.width * 0.5, -projectile.height * 0.35, projectile.width, projectile.height * 0.7);
                        ctx.fillStyle = '#ff7043';
                        ctx.beginPath();
                        ctx.moveTo(-projectile.width * 0.6, -projectile.height * 0.5);
                        ctx.lineTo(-projectile.width * 0.2, 0);
                        ctx.lineTo(-projectile.width * 0.6, projectile.height * 0.5);
                        ctx.closePath();
                        ctx.fill();
                        ctx.fillStyle = '#263238';
                        ctx.fillRect(projectile.width * 0.1, -projectile.height * 0.2, projectile.width * 0.5, projectile.height * 0.4);
                        ctx.restore();
                    } else {
                        const gradient = ctx.createLinearGradient(projectile.x, projectile.y, projectile.x + projectile.width, projectile.y + projectile.height);
                        if (projectile.type === 'spread') {
                            gradient.addColorStop(0, '#b39ddb');
                            gradient.addColorStop(1, '#7e57c2');
                        } else {
                            gradient.addColorStop(0, '#00e5ff');
                            gradient.addColorStop(1, '#6a5acd');
                        }
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.moveTo(projectile.x, projectile.y);
                        ctx.lineTo(projectile.x + projectile.width, projectile.y + projectile.height * 0.5);
                        ctx.lineTo(projectile.x, projectile.y + projectile.height);
                        ctx.closePath();
                        ctx.fill();
                    }
                }
            }

            function drawParticles() {
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                for (const particle of particles) {
                    const alpha = clamp(particle.life / 500, 0, 1);
                    ctx.fillStyle = `rgba(${particle.color.r}, ${particle.color.g}, ${particle.color.b}, ${alpha.toFixed(2)})`;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
            }

            function stepNonRunning(delta) {
                updateCameraShake(delta);
                updateStars(delta);
                updateAsteroids(delta);
                updateParticles(delta);
                updateFloatingTexts(delta);
                updateAreaBursts(delta);
                updateVillainExplosions(delta);
                updateShieldEffects(delta);
                updateHyperBeam(delta);
                updatePumpTail(delta);
            }

            function stepRunning(delta) {
                state.elapsedTime += delta;
                if (challengeManager) {
                    challengeManager.recordEvent('time', { totalMs: state.elapsedTime });
                }
                updateIntelLore(state.elapsedTime);
                state.gameSpeed += config.speedGrowth * getSpeedRampMultiplier() * (delta / 1000);
                if (state.bossBattle.alertTimer > 0) {
                    state.bossBattle.alertTimer = Math.max(0, state.bossBattle.alertTimer - delta);
                }

                if (!state.bossBattle.triggered && state.elapsedTime >= BOSS_EVENT_TIME_MS) {
                    startBossBattle();
                }

                updateCameraShake(delta);
                updatePlayer(delta);
                updateProjectiles(delta);
                updateObstacles(delta);
                updateCollectibles(delta);
                updatePowerUps(delta);
                updateHyperBeam(delta);
                updateProjectilesCollisions();
                updateStars(delta);
                updateAsteroids(delta);
                updateParticles(delta);
                updateFloatingTexts(delta);
                updateSpawns(delta);
                updatePowerUpTimers(delta);
                updatePumpTail(delta);
                updatePowerBomb(delta);
                updateShieldEffects(delta);
                updateAreaBursts(delta);
                updateVillainExplosions(delta);
                updateCombo(delta);
            }

            function renderFrame(timestamp) {
                drawBackground();
                ctx.save();
                ctx.translate(cameraShake.offsetX ?? 0, cameraShake.offsetY ?? 0);
                drawStars(timestamp);
                drawAsteroids(timestamp);
                drawTrail();
                drawCollectibles(timestamp);
                drawPowerUps(timestamp);
                drawAreaBursts();
                drawVillainExplosions();
                drawObstacles();
                drawHyperBeam(timestamp);
                drawProjectiles();
                drawParticles();
                drawPlayer();
                drawFloatingTexts();
                ctx.restore();
                drawBossAlert(timestamp);
            }

            let lastTime = null;
            let accumulatedDelta = 0;
            const FIXED_TIMESTEP = 16;
            const MAX_ACCUMULATED_TIME = FIXED_TIMESTEP * 6;

            function gameLoop(timestamp = performance.now()) {
                requestAnimationFrame(gameLoop);

                if (state.gameState === 'ready') {
                    stepNonRunning(FIXED_TIMESTEP);
                    renderFrame(timestamp);
                    updateHUD();
                    updateTimerDisplay();
                    lastTime = timestamp;
                    accumulatedDelta = 0;
                    return;
                }

                if (lastTime === null) {
                    lastTime = timestamp;
                }

                let delta = timestamp - lastTime;
                lastTime = timestamp;

                if (delta > 200) {
                    delta = 200;
                } else if (delta < 0) {
                    delta = 0;
                }

                accumulatedDelta = Math.min(accumulatedDelta + delta, MAX_ACCUMULATED_TIME);

                while (accumulatedDelta >= FIXED_TIMESTEP) {
                    if (state.gameState === 'running') {
                        stepRunning(FIXED_TIMESTEP);
                    } else {
                        stepNonRunning(FIXED_TIMESTEP);
                    }
                    accumulatedDelta -= FIXED_TIMESTEP;
                }

                renderFrame(timestamp);
                updateHUD();
                updateTimerDisplay();
            }

            runCyborgLoadingSequence();
            createInitialStars();
            scheduleNextMeteorShower();
            requestAnimationFrame(gameLoop);
        });
    </script>
</body>
</html>
